<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bRPC – 文档</title>
    <link>https://brpc.incubator.apache.org/docs/</link>
    <description>Recent content in 文档 on bRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://brpc.incubator.apache.org/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: bRPC简介</title>
      <link>https://brpc.incubator.apache.org/docs/overview/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/overview/</guid>
      <description>
        
        
        &lt;h1 id=&#34;什么是rpc&#34;&gt;什么是RPC?&lt;/h1&gt;
&lt;p&gt;互联网上的机器大都通过&lt;a href=&#34;http://en.wikipedia.org/wiki/Internet_protocol_suite&#34;&gt;TCP/IP协议&lt;/a&gt;相互访问，但TCP/IP只是往远端发送了一段二进制数据，为了建立服务还有很多问题需要抽象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据以什么格式传输？不同机器间，网络间可能是不同的字节序，直接传输内存数据显然是不合适的；随着业务变化，数据字段往往要增加或删减，怎么兼容前后不同版本的格式？&lt;/li&gt;
&lt;li&gt;一个TCP连接可以被多个请求复用以减少开销么？多个请求可以同时发往一个TCP连接么?&lt;/li&gt;
&lt;li&gt;如何管理和访问很多机器？&lt;/li&gt;
&lt;li&gt;连接断开时应该干什么？&lt;/li&gt;
&lt;li&gt;万一server不发送回复怎么办？&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Remote_procedure_call&#34;&gt;RPC&lt;/a&gt;可以解决这些问题，它把网络交互类比为“client访问server上的函数”：client向server发送request后开始等待，直到server收到、处理、回复client后，client又再度恢复并根据response做出反应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/rpc.png&#34; alt=&#34;rpc.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们来看看上面的一些问题是如何解决的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据需要序列化，&lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;在这方面做的不错。用户填写protobuf::Message类型的request，RPC结束后，从同为protobuf::Message类型的response中取出结果。protobuf有较好的前后兼容性，方便业务调整字段。http广泛使用&lt;a href=&#34;http://www.json.org/&#34;&gt;json&lt;/a&gt;作为序列化方法。&lt;/li&gt;
&lt;li&gt;用户无需关心连接如何建立，但可以选择不同的&lt;a href=&#34;client.md#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F&#34;&gt;连接方式&lt;/a&gt;：短连接，连接池，单连接。&lt;/li&gt;
&lt;li&gt;大量机器一般通过命名服务被发现，可基于&lt;a href=&#34;https://en.wikipedia.org/wiki/Domain_Name_System&#34;&gt;DNS&lt;/a&gt;, &lt;a href=&#34;https://zookeeper.apache.org/&#34;&gt;ZooKeeper&lt;/a&gt;, &lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;etcd&lt;/a&gt;等实现。在百度内，我们使用BNS (Baidu Naming Service)。brpc也提供&lt;a href=&#34;client.md#%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1&#34;&gt;&amp;ldquo;list://&amp;ldquo;和&amp;quot;file://&amp;quot;&lt;/a&gt;。用户可以指定负载均衡算法，让RPC每次选出一台机器发送请求，包括: round-robin, randomized, &lt;a href=&#34;consistent_hashing.md&#34;&gt;consistent-hashing&lt;/a&gt;(murmurhash3 or md5)和 &lt;a href=&#34;lalb.md&#34;&gt;locality-aware&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;连接断开时可以重试。&lt;/li&gt;
&lt;li&gt;如果server没有在给定时间内回复，client会返回超时错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;哪里可以使用rpc&#34;&gt;哪里可以使用RPC?&lt;/h1&gt;
&lt;p&gt;几乎所有的网络交互。&lt;/p&gt;
&lt;p&gt;RPC不是万能的抽象，否则我们也不需要TCP/IP这一层了。但是在我们绝大部分的网络交互中，RPC既能解决问题，又能隔离更底层的网络问题。&lt;/p&gt;
&lt;p&gt;对于RPC常见的质疑有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的数据非常大，用protobuf序列化太慢了。首先这可能是个伪命题，你得用&lt;a href=&#34;cpu_profiler.md&#34;&gt;profiler&lt;/a&gt;证明慢了才是真的慢，其次很多协议支持携带二进制数据以绕过序列化。&lt;/li&gt;
&lt;li&gt;我传输的是流数据，RPC表达不了。事实上brpc中很多协议支持传递流式数据，包括&lt;a href=&#34;http_client.md#%E6%8C%81%E7%BB%AD%E4%B8%8B%E8%BD%BD&#34;&gt;http中的ProgressiveReader&lt;/a&gt;, h2的streams, &lt;a href=&#34;streaming_rpc.md&#34;&gt;streaming rpc&lt;/a&gt;, 和专门的流式协议RTMP。&lt;/li&gt;
&lt;li&gt;我的场景不需要回复。简单推理可知，你的场景中请求可丢可不丢，可处理也可不处理，因为client总是无法感知，你真的确认这是OK的？即使场景真的不需要，我们仍然建议用最小的结构体回复，因为这不大会是瓶颈，并且追查复杂bug时可能是很有价值的线索。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;什么是brpcimagesdocslogopng&#34;&gt;什么是&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/logo.png&#34; alt=&#34;brpc&#34;&gt;?&lt;/h1&gt;
&lt;p&gt;百度内最常使用的工业级RPC框架, 有1,000,000+个实例(不包含client)和上千种服务, 在百度内叫做&amp;rdquo;&lt;strong&gt;baidu-rpc&lt;/strong&gt;&amp;rdquo;. 目前只开源C++版本。&lt;/p&gt;
&lt;p&gt;你可以使用它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搭建能在&lt;strong&gt;一个端口&lt;/strong&gt;支持多协议的服务, 或访问各种服务
&lt;ul&gt;
&lt;li&gt;restful http/https, &lt;a href=&#34;https://http2.github.io/http2-spec&#34;&gt;h2&lt;/a&gt;/&lt;a href=&#34;https://grpc.io&#34;&gt;gRPC&lt;/a&gt;。使用brpc的http实现比&lt;a href=&#34;https://curl.haxx.se/libcurl/&#34;&gt;libcurl&lt;/a&gt;方便多了。从其他语言通过HTTP/h2+json访问基于protobuf的协议.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;redis_client.md&#34;&gt;redis&lt;/a&gt;和&lt;a href=&#34;memcache_client.md&#34;&gt;memcached&lt;/a&gt;, 线程安全，比官方client更方便。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/rtmp.h&#34;&gt;rtmp&lt;/a&gt;/&lt;a href=&#34;https://en.wikipedia.org/wiki/Flash_Video&#34;&gt;flv&lt;/a&gt;/&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Live_Streaming&#34;&gt;hls&lt;/a&gt;, 可用于搭建&lt;a href=&#34;https://github.com/brpc/media-server&#34;&gt;流媒体服务&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;hadoop_rpc(可能开源)&lt;/li&gt;
&lt;li&gt;支持&lt;a href=&#34;https://en.wikipedia.org/wiki/Remote_direct_memory_access&#34;&gt;rdma&lt;/a&gt;(即将开源)&lt;/li&gt;
&lt;li&gt;支持&lt;a href=&#34;thrift.md&#34;&gt;thrift&lt;/a&gt; , 线程安全，比官方client更方便&lt;/li&gt;
&lt;li&gt;各种百度内使用的协议: &lt;a href=&#34;baidu_std.md&#34;&gt;baidu_std&lt;/a&gt;, &lt;a href=&#34;streaming_rpc.md&#34;&gt;streaming_rpc&lt;/a&gt;, hulu_pbrpc, &lt;a href=&#34;https://github.com/baidu/sofa-pbrpc&#34;&gt;sofa_pbrpc&lt;/a&gt;, nova_pbrpc, public_pbrpc, ubrpc和使用nshead的各种协议.&lt;/li&gt;
&lt;li&gt;基于工业级的&lt;a href=&#34;https://raft.github.io&#34;&gt;RAFT算法&lt;/a&gt;实现搭建&lt;a href=&#34;https://en.wikipedia.org/wiki/High_availability&#34;&gt;高可用&lt;/a&gt;分布式系统，已在&lt;a href=&#34;https://github.com/brpc/braft&#34;&gt;braft&lt;/a&gt;开源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Server能&lt;a href=&#34;server.md&#34;&gt;同步&lt;/a&gt;或&lt;a href=&#34;server.md#%E5%BC%82%E6%AD%A5service&#34;&gt;异步&lt;/a&gt;处理请求。&lt;/li&gt;
&lt;li&gt;Client支持&lt;a href=&#34;client.md#%E5%90%8C%E6%AD%A5%E8%AE%BF%E9%97%AE&#34;&gt;同步&lt;/a&gt;、&lt;a href=&#34;client.md#%E5%BC%82%E6%AD%A5%E8%AE%BF%E9%97%AE&#34;&gt;异步&lt;/a&gt;、&lt;a href=&#34;client.md#%E5%8D%8A%E5%90%8C%E6%AD%A5&#34;&gt;半同步&lt;/a&gt;，或使用&lt;a href=&#34;combo_channel.md&#34;&gt;组合channels&lt;/a&gt;简化复杂的分库或并发访问。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;builtin_service.md&#34;&gt;通过http界面&lt;/a&gt;调试服务, 使用&lt;a href=&#34;cpu_profiler.md&#34;&gt;cpu&lt;/a&gt;, &lt;a href=&#34;heap_profiler.md&#34;&gt;heap&lt;/a&gt;, &lt;a href=&#34;contention_profiler.md&#34;&gt;contention&lt;/a&gt; profilers.&lt;/li&gt;
&lt;li&gt;获得&lt;a href=&#34;#%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BB%B6%E6%97%B6%E5%92%8C%E5%90%9E%E5%90%90&#34;&gt;更好的延时和吞吐&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;把你组织中使用的协议快速地&lt;a href=&#34;new_protocol.md&#34;&gt;加入brpc&lt;/a&gt;，或定制各类组件, 包括&lt;a href=&#34;load_balancing.md#%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1&#34;&gt;命名服务&lt;/a&gt; (dns, zk, etcd), &lt;a href=&#34;load_balancing.md#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&#34;&gt;负载均衡&lt;/a&gt; (rr, random, consistent hashing)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;brpc的优势&#34;&gt;brpc的优势&lt;/h1&gt;
&lt;h3 id=&#34;更友好的接口&#34;&gt;更友好的接口&lt;/h3&gt;
&lt;p&gt;只有三个(主要的)用户类: &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/server.h&#34;&gt;Server&lt;/a&gt;, &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/channel.h&#34;&gt;Channel&lt;/a&gt;, &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/controller.h&#34;&gt;Controller&lt;/a&gt;, 分别对应server端，client端，参数集合. 你不必推敲诸如&amp;quot;如何初始化XXXManager&amp;quot;, &amp;ldquo;如何组合各种组件&amp;rdquo;,  &amp;ldquo;XXXController的XXXContext间的关系是什么&amp;rdquo;。要做的很简单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建服务? 包含&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/server.h&#34;&gt;brpc/server.h&lt;/a&gt;并参考注释或&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/example/echo_c++/server.cpp&#34;&gt;示例&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;访问服务? 包含&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/channel.h&#34;&gt;brpc/channel.h&lt;/a&gt;并参考注释或&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/example/echo_c++/client.cpp&#34;&gt;示例&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;调整参数? 看看&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/controller.h&#34;&gt;brpc/controller.h&lt;/a&gt;. 注意这个类是Server和Channel共用的，分成了三段，分别标记为Client-side, Server-side和Both-side methods。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们尝试让事情变得更加简单，以命名服务为例，在其他RPC实现中，你也许需要复制一长段晦涩的代码才可使用，而在brpc中访问BNS可以这么写&lt;code&gt;&amp;quot;bns://node-name&amp;quot;&lt;/code&gt;，DNS是&lt;code&gt;&amp;quot;http://domain-name&amp;quot;&lt;/code&gt;，本地文件列表是&lt;code&gt;&amp;quot;file:///home/work/server.list&amp;quot;&lt;/code&gt;，相信不用解释，你也能明白这些代表什么。&lt;/p&gt;
&lt;h3 id=&#34;使服务更加可靠&#34;&gt;使服务更加可靠&lt;/h3&gt;
&lt;p&gt;brpc在百度内被广泛使用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map-reduce服务和table存储&lt;/li&gt;
&lt;li&gt;高性能计算和模型训练&lt;/li&gt;
&lt;li&gt;各种索引和排序服务&lt;/li&gt;
&lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它是一个经历过考验的实现。&lt;/p&gt;
&lt;p&gt;brpc特别重视开发和维护效率, 你可以通过浏览器或curl&lt;a href=&#34;builtin_service.md&#34;&gt;查看server内部状态&lt;/a&gt;, 分析在线服务的&lt;a href=&#34;cpu_profiler.md&#34;&gt;cpu热点&lt;/a&gt;, &lt;a href=&#34;heap_profiler.md&#34;&gt;内存分配&lt;/a&gt;和&lt;a href=&#34;contention_profiler.md&#34;&gt;锁竞争&lt;/a&gt;, 通过&lt;a href=&#34;bvar.md&#34;&gt;bvar&lt;/a&gt;统计各种指标并通过&lt;a href=&#34;vars.md&#34;&gt;/vars&lt;/a&gt;查看。&lt;/p&gt;
&lt;h3 id=&#34;更好的延时和吞吐&#34;&gt;更好的延时和吞吐&lt;/h3&gt;
&lt;p&gt;虽然大部分RPC实现都声称“高性能”，但数字仅仅是数字，要在广泛的场景中做到高性能仍是困难的。为了统一百度内的通信架构，brpc在性能方面比其他RPC走得更深。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对不同客户端请求的读取和解析是完全并发的，用户也不用区分”IO线程“和”处理线程&amp;quot;。其他实现往往会区分“IO线程”和“处理线程”，并把&lt;a href=&#34;http://en.wikipedia.org/wiki/File_descriptor&#34;&gt;fd&lt;/a&gt;（对应一个客户端）散列到IO线程中去。当一个IO线程在读取其中的fd时，同一个线程中的fd都无法得到处理。当一些解析变慢时，比如特别大的protobuf message，同一个IO线程中的其他fd都遭殃了。虽然不同IO线程间的fd是并发的，但你不太可能开太多IO线程，因为这类线程的事情很少，大部分时候都是闲着的。如果有10个IO线程，一个fd能影响到的”其他fd“仍有相当大的比例（10个即10%，而工业级在线检索要求99.99%以上的可用性）。这个问题在fd没有均匀地分布在IO线程中，或在多租户(multi-tenancy)环境中会更加恶化。在brpc中，对不同fd的读取是完全并发的，对同一个fd中不同消息的解析也是并发的。解析一个特别大的protobuf message不会影响同一个客户端的其他消息，更不用提其他客户端的消息了。更多细节看&lt;a href=&#34;io.md#%E6%94%B6%E6%B6%88%E6%81%AF&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;对同一fd和不同fd的写出是高度并发的。当多个线程都要对一个fd写出时（常见于单连接），第一个线程会直接在原线程写出，其他线程会以&lt;a href=&#34;http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom&#34;&gt;wait-free&lt;/a&gt;的方式托付自己的写请求，多个线程在高度竞争下仍可以在1秒内对同一个fd写入500万个16字节的消息。更多细节看&lt;a href=&#34;io.md#%E5%8F%91%E6%B6%88%E6%81%AF&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;尽量少的锁。高QPS服务可以充分利用一台机器的CPU。比如为处理请求&lt;a href=&#34;memory_management.md&#34;&gt;创建bthread&lt;/a&gt;, &lt;a href=&#34;timer_keeping.md&#34;&gt;设置超时&lt;/a&gt;, 根据回复&lt;a href=&#34;bthread_id.md&#34;&gt;找到RPC上下文&lt;/a&gt;, &lt;a href=&#34;bvar.md&#34;&gt;记录性能计数器&lt;/a&gt;都是高度并发的。即使服务的QPS超过50万，用户也很少在&lt;a href=&#34;contention_profiler.md&#34;&gt;contention profiler&lt;/a&gt;)中看到框架造成的锁竞争。&lt;/li&gt;
&lt;li&gt;服务器线程数自动调节。传统的服务器需要根据下游延时的调整自身的线程数，否则吞吐可能会受影响。在brpc中，每个请求均运行在新建立的&lt;a href=&#34;bthread.md&#34;&gt;bthread&lt;/a&gt;中，请求结束后线程就结束了，所以天然会根据负载自动调节线程数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;brpc和其他实现的性能对比见&lt;a href=&#34;benchmark.md&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 开始</title>
      <link>https://brpc.incubator.apache.org/docs/getting_started/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/getting_started/</guid>
      <description>
        
        
        &lt;h1 id=&#34;构建&#34;&gt;构建&lt;/h1&gt;
&lt;p&gt;brpc鼓励静态链接依赖，以便于每个运行brpc服务的机器不必再安装依赖。&lt;/p&gt;
&lt;p&gt;brpc有如下依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gflags/gflags&#34;&gt;gflags&lt;/a&gt;: Extensively used to define global options.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;: Serializations of messages, interfaces of services.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;leveldb&lt;/a&gt;: Required by &lt;a href=&#34;rpcz.md&#34;&gt;rpcz&lt;/a&gt; to record RPCs for tracing.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;支持的环境&#34;&gt;支持的环境&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ubuntulinuxmintwsl&#34;&gt;Ubuntu/LinuxMint/WSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fedoracentos&#34;&gt;Fedora/CentOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%BE%9D%E8%B5%96%E7%9A%84Linux&#34;&gt;自己构建依赖的Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#macos&#34;&gt;MacOS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ubuntulinuxmintwsl&#34;&gt;Ubuntu/LinuxMint/WSL&lt;/h2&gt;
&lt;h3 id=&#34;依赖准备&#34;&gt;依赖准备&lt;/h3&gt;
&lt;p&gt;安装通用依赖，&lt;a href=&#34;https://github.com/gflags/gflags&#34;&gt;gflags&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;leveldb&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install -y git g++ make libssl-dev libgflags-dev libprotobuf-dev libprotoc-dev protobuf-compiler libleveldb-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你需要静态链接leveldb：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install -y libsnappy-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要在样例中启用cpu/heap的profiler：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install -y libgoogle-perftools-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要运行测试，那么要安装并编译libgtest-dev（它没有被默认编译）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo apt-get install -y cmake libgtest-dev &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; /usr/src/gtest &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo cmake . &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo make &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo mv libgtest* /usr/lib/ &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gtest源码目录可能变动，如果&lt;code&gt;/usr/src/gtest&lt;/code&gt;不存在，请尝试&lt;code&gt;/usr/src/googletest/googletest&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;使用config_brpcsh编译brpc&#34;&gt;使用config_brpc.sh编译brpc&lt;/h3&gt;
&lt;p&gt;git克隆brpc，进入到项目目录，然后运行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ sh config_brpc.sh --headers&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/include --libs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/lib
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;修改编译器为clang，添加选项&lt;code&gt;--cxx=clang++ --cc=clang&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不想链接调试符号，添加选项&lt;code&gt;--nodebugsymbols&lt;/code&gt;，然后编译将会得到更轻量的二进制文件。&lt;/p&gt;
&lt;p&gt;使用glog版的brpc，添加选项&lt;code&gt;--with-glog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要启用 &lt;a href=&#34;../en/thrift.md&#34;&gt;thrift 支持&lt;/a&gt;，首先安装thrift并且添加选项&lt;code&gt;--with-thrift&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行样例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; example/echo_c++
$ make
$ ./echo_server &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;
$ ./echo_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述操作会链接brpc的静态库到样例中，如果你想链接brpc的共享库，请依次执行：&lt;code&gt;make clean&lt;/code&gt;和&lt;code&gt;LINK_SO=1 make&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt;
$ make
$ sh run_tests.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用cmake编译brpc&#34;&gt;使用cmake编译brpc&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;cmake -B build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cmake --build build -j6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要帮助VSCode或Emacs(LSP)去正确地理解代码，添加&lt;code&gt;-DCMAKE_EXPORT_COMPILE_COMMANDS=ON&lt;/code&gt;选项去生成&lt;code&gt;compile_commands.json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要修改编译器为clang，请修改环境变量&lt;code&gt;CC&lt;/code&gt;和&lt;code&gt;CXX&lt;/code&gt;为&lt;code&gt;clang&lt;/code&gt;和&lt;code&gt;clang++&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不想链接调试符号，请移除&lt;code&gt;build/CMakeCache.txt&lt;/code&gt;，然后用&lt;code&gt;-DWITH_DEBUG_SYMBOLS=OFF&lt;/code&gt;选项执行cmake。&lt;/p&gt;
&lt;p&gt;想要让brpc使用glog，用&lt;code&gt;-DWITH_GLOG=ON&lt;/code&gt;选项执行cmake。&lt;/p&gt;
&lt;p&gt;要启用 &lt;a href=&#34;../en/thrift.md&#34;&gt;thrift 支持&lt;/a&gt;，先安装thrift，然后用&lt;code&gt;-DWITH_THRIFT=ON&lt;/code&gt;选项执行cmake。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用cmake运行样例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; example/echo_c++
$ cmake -B build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cmake --build build -j4
$ ./echo_server &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;
$ ./echo_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述操作会链接brpc的静态库到样例中，如果你想链接brpc的共享库，请先移除&lt;code&gt;CMakeCache.txt&lt;/code&gt;，然后用&lt;code&gt;-DLINK_SO=ON&lt;/code&gt;选项重新执行cmake。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ mkdir build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cmake -DBUILD_UNIT_TESTS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;ON .. &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;fedoracentos&#34;&gt;Fedora/CentOS&lt;/h2&gt;
&lt;h3 id=&#34;依赖准备-1&#34;&gt;依赖准备&lt;/h3&gt;
&lt;p&gt;CentOS一般需要安装EPEL，否则很多包都默认不可用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo yum install epel-release
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装通用依赖：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo yum install git gcc-c++ make openssl-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装 &lt;a href=&#34;https://github.com/gflags/gflags&#34;&gt;gflags&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;leveldb&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo yum install gflags-devel protobuf-devel protobuf-compiler leveldb-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要在样例中启用cpu/heap的profiler：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo yum install gperftools-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要运行测试，那么要安装ligtest-dev:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;sudo yum install gtest-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用config_brpcsh编译brpc-1&#34;&gt;使用config_brpc.sh编译brpc&lt;/h3&gt;
&lt;p&gt;git克隆brpc，进入项目目录然后执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ sh config_brpc.sh --headers&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;/usr/include&amp;#34;&lt;/span&gt; --libs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;/usr/lib64 /usr/bin&amp;#34;&lt;/span&gt;
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;修改编译器为clang，添加选项&lt;code&gt;--cxx=clang++ --cc=clang&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不想链接调试符号，添加选项&lt;code&gt;--nodebugsymbols&lt;/code&gt; 然后编译将会得到更轻量的二进制文件。&lt;/p&gt;
&lt;p&gt;想要让brpc使用glog，添加选项：&lt;code&gt;--with-glog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要启用 &lt;a href=&#34;../en/thrift.md&#34;&gt;thrift 支持&lt;/a&gt;，先安装thrift，然后添加选项：&lt;code&gt;--with-thrift&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行样例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; example/echo_c++
$ make
$ ./echo_server &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;
$ ./echo_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述操作会链接brpc的静态库到样例中，如果你想链接brpc的共享库，请依次执行：&lt;code&gt;make clean&lt;/code&gt;和&lt;code&gt;LINK_SO=1 make&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt;
$ make
$ sh run_tests.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用cmake编译brpc-1&#34;&gt;使用cmake编译brpc&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&#34;#%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91brpc&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;自己构建依赖的linux&#34;&gt;自己构建依赖的Linux&lt;/h2&gt;
&lt;h3 id=&#34;依赖准备-2&#34;&gt;依赖准备&lt;/h3&gt;
&lt;p&gt;brpc默认会构建出静态库和共享库，因此它也需要依赖有静态库和共享库两个版本。&lt;/p&gt;
&lt;p&gt;以&lt;a href=&#34;https://github.com/gflags/gflags&#34;&gt;gflags&lt;/a&gt;为例，它默认不够尖共享库，你需要给&lt;code&gt;cmake&lt;/code&gt;指定选项去改变这一行为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ cmake . -DBUILD_SHARED_LIBS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; -DBUILD_STATIC_LIBS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;编译brpc&#34;&gt;编译brpc&lt;/h3&gt;
&lt;p&gt;还以gflags为例，&lt;code&gt;../gflags_dev&lt;/code&gt;表示gflags被克隆的位置。&lt;/p&gt;
&lt;p&gt;git克隆brpc。进入到项目目录然后运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ sh config_brpc.sh --headers&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;../gflags_dev /usr/include&amp;#34;&lt;/span&gt; --libs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;../gflags_dev /usr/lib64&amp;#34;&lt;/span&gt;
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们给&lt;code&gt;--headers&lt;/code&gt;和&lt;code&gt;--libs&lt;/code&gt;传递多个路径使得脚本能够在多个地方进行检索。你也可以打包所有依赖和brpc一起放到一个目录中，然后把目录传递给 &amp;ndash;headers/&amp;ndash;libs选项，它会递归搜索所有子目录直到找到必须的文件。&lt;/p&gt;
&lt;p&gt;修改编译器为clang，添加选项&lt;code&gt;--cxx=clang++ --cc=clang&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不想链接调试符号，添加选项&lt;code&gt;--nodebugsymbols&lt;/code&gt;，然后编译将会得到更轻量的二进制文件。&lt;/p&gt;
&lt;p&gt;使用glog版的brpc，添加选项&lt;code&gt;--with-glog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要启用&lt;a href=&#34;../en/thrift.md&#34;&gt;thrift 支持&lt;/a&gt;，首先安装thrift并且添加选项&lt;code&gt;--with-thrift&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ ls my_dev
gflags_dev protobuf_dev leveldb_dev brpc_dev
$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; brpc_dev
$ sh config_brpc.sh --headers&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;.. --libs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;..
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用cmake编译brpc-2&#34;&gt;使用cmake编译brpc&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&#34;#%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91brpc&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;macos&#34;&gt;MacOS&lt;/h2&gt;
&lt;p&gt;注意：在相同运行环境下，当前Mac版brpc的性能比Linux版差2.5倍。如果你的服务是性能敏感的，请不要使用MacOs作为你的生产环境。&lt;/p&gt;
&lt;h3 id=&#34;依赖准备-3&#34;&gt;依赖准备&lt;/h3&gt;
&lt;p&gt;安装通用依赖：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;brew install openssl git gnu-getopt coreutils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装&lt;a href=&#34;https://github.com/gflags/gflags&#34;&gt;gflags&lt;/a&gt;，&lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt;，&lt;a href=&#34;https://github.com/google/leveldb&#34;&gt;leveldb&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;brew install gflags protobuf leveldb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要在样例中启用cpu/heap的profiler：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;brew install gperftools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你要运行测试，那么要安装并编译googletest（它没有被默认编译）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;git clone https://github.com/google/googletest -b release-1.10.0 &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; googletest/googletest &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; build &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cmake -DCMAKE_CXX_FLAGS&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;-std=c++11&amp;#34;&lt;/span&gt; .. &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编译完成后，复制include/和lib/目录到/usr/local/include和/usr/local/lib目录中，以便于让所有应用都能使用gtest。&lt;/p&gt;
&lt;h3 id=&#34;使用config_brpcsh编译brpc-2&#34;&gt;使用config_brpc.sh编译brpc&lt;/h3&gt;
&lt;p&gt;git克隆brpc，进入到项目目录然后运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ sh config_brpc.sh --headers&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/local/include --libs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/usr/local/lib --cc&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;clang --cxx&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;clang++
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不想链接调试符号，添加选项&lt;code&gt;--nodebugsymbols&lt;/code&gt;，然后编译将会得到更轻量的二进制文件。&lt;/p&gt;
&lt;p&gt;使用glog版的brpc，添加选项&lt;code&gt;--with-glog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要启用&lt;a href=&#34;../en/thrift.md&#34;&gt;thrift 支持&lt;/a&gt;，首先安装thrift并且添加选项&lt;code&gt;--with-thrift&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行样例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; example/echo_c++
$ make
$ ./echo_server &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;
$ ./echo_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述操作会链接brpc的静态库到样例中，如果你想链接brpc的共享库，请依次执行：&lt;code&gt;make clean&lt;/code&gt;和&lt;code&gt;LINK_SO=1 make&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ &lt;span style=&#34;color:#204a87&#34;&gt;cd&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;test&lt;/span&gt;
$ make
$ sh run_tests.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;使用cmake编译brpc-3&#34;&gt;使用cmake编译brpc&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&#34;#%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91brpc&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;支持的依赖&#34;&gt;支持的依赖&lt;/h1&gt;
&lt;h2 id=&#34;gcc-48-71&#34;&gt;GCC: 4.8-7.1&lt;/h2&gt;
&lt;p&gt;c++11被默认启用，以去除去boost的依赖（比如atomic）。&lt;/p&gt;
&lt;p&gt;GCC7中over-aligned的问题暂时被禁止。&lt;/p&gt;
&lt;p&gt;使用其他版本的gcc可能会产生编译警告，请联系我们予以修复。&lt;/p&gt;
&lt;p&gt;请在makefile中给cxxflags增加&lt;code&gt;-D__const__=&lt;/code&gt;选项以避免&lt;a href=&#34;thread_local.md&#34;&gt;gcc4+中的errno问题&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;clang-35-40&#34;&gt;Clang: 3.5-4.0&lt;/h2&gt;
&lt;p&gt;无已知问题。&lt;/p&gt;
&lt;h2 id=&#34;glibc-212-225&#34;&gt;glibc: 2.12-2.25&lt;/h2&gt;
&lt;p&gt;无已知问题。&lt;/p&gt;
&lt;h2 id=&#34;protobuf-24&#34;&gt;protobuf: 2.4+&lt;/h2&gt;
&lt;p&gt;同一个文件兼容pb 3.x版本和pb 2.x版本：
不要使用proto3新增的类型，并且在proto文件的起始位置添加&lt;code&gt;syntax=proto2;&lt;/code&gt;声明。
&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/tools/add_syntax_equal_proto2_to_all.sh&#34;&gt;tools/add_syntax_equal_proto2_to_all.sh&lt;/a&gt;这个脚本可以给所有没有这行声明的proto文件添加&lt;code&gt;syntax=&amp;quot;proto2&amp;quot;&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;pb 3.x中的Arena至今没被支持。&lt;/p&gt;
&lt;h2 id=&#34;gflags-20-221&#34;&gt;gflags: 2.0-2.2.1&lt;/h2&gt;
&lt;p&gt;无已知问题。&lt;/p&gt;
&lt;h2 id=&#34;openssl-097-11&#34;&gt;openssl: 0.97-1.1&lt;/h2&gt;
&lt;p&gt;被https功能需要。&lt;/p&gt;
&lt;h2 id=&#34;tcmalloc-17-25&#34;&gt;tcmalloc: 1.7-2.5&lt;/h2&gt;
&lt;p&gt;brpc默认&lt;strong&gt;不&lt;/strong&gt;链接 &lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;tcmalloc&lt;/a&gt;。用户按需要链接tcmalloc。&lt;/p&gt;
&lt;p&gt;和glibc内置的ptmalloc相比，tcmalloc通常能提升性能。然而不同版本的tcmalloc可能表现迥异。例如：tcmalloc 2.1与 tcmalloc 1.7和2.5相比，可能会让brpc的多线程样例性能显著恶化（tcmalloc中的一个自旋锁导致的）。甚至不同的小版本号之间变现也可能不同。当你的程序表现不符合预期的时候，移除tcmalloc然后尝试其他版本。&lt;/p&gt;
&lt;p&gt;用gcc4.8.2编译然后链接更早版本GCC编译的tcmalloc，可能会让程序中main()函数之前挂掉或者死锁，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/tcmalloc_stuck.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;当你遇到这个问题的时候，请用同一个GCC重新编译tcmalloc。&lt;/p&gt;
&lt;p&gt;另外一个使用tcmalloc的常见问题是，它不会像 ptmalloc一样及时地归还内存给系统。因此当有一个无效的内存访问的时候，程序可能不会直接挂掉，取而代之的是它可能在一个不相关的地方挂掉，或者甚至一直不挂掉。当你的程序出现怪异的内存问题的时候，尝试移除tcmalloc。&lt;/p&gt;
&lt;p&gt;如果你要使用&lt;a href=&#34;cpu_profiler.md&#34;&gt;cpu profiler&lt;/a&gt;或&lt;a href=&#34;heap_profiler.md&#34;&gt;heap profiler&lt;/a&gt;，要链接&lt;code&gt;libtcmalloc_and_profiler.a&lt;/code&gt;。这两个 profiler都是基于tcmalloc的。而&lt;a href=&#34;contention_profiler.md&#34;&gt;contention profiler&lt;/a&gt;不需要tcmalloc。&lt;/p&gt;
&lt;p&gt;当你移除tcmalloc的时候，不仅要移除tcmalloc的链接，也要移除宏&lt;code&gt;-DBRPC_ENABLE_CPU_PROFILER&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;glog-33&#34;&gt;glog: 3.3+&lt;/h2&gt;
&lt;p&gt;brpc实现了一个默认的&lt;a href=&#34;../../src/butil/logging.h&#34;&gt;日志功能&lt;/a&gt;它和glog冲突。要替换成glog，可以给config_brpc.sh增加*&amp;ndash;with-glog*选项或者给cmake增加&lt;code&gt;-DWITH_GLOG=ON&lt;/code&gt;选项。&lt;/p&gt;
&lt;h2 id=&#34;valgrind-38&#34;&gt;valgrind: 3.8+&lt;/h2&gt;
&lt;p&gt;brpc会自动检测valgrind（然后注册bthread的栈）。不支持老版本的valgrind（比如3.2）。&lt;/p&gt;
&lt;h2 id=&#34;thrift-093-0110&#34;&gt;thrift: 0.9.3-0.11.0&lt;/h2&gt;
&lt;p&gt;无已知问题。&lt;/p&gt;
&lt;h1 id=&#34;实例追踪&#34;&gt;实例追踪&lt;/h1&gt;
&lt;p&gt;我们提供了一个程序去帮助你追踪和监控所有brpc实例。 只需要在某处运行 &lt;a href=&#34;https://github.com/brpc/brpc/tree/master/tools/trackme_server/&#34;&gt;trackme_server&lt;/a&gt; 然后再带着 -trackme_server=SERVER参数启动需要被追踪的实例。trackme_server将从实例周期性地收到ping消息然后打印日志。您可以从日志中聚合实例地址，并调用实例的内置服务以获取更多信息。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 性能基准</title>
      <link>https://brpc.incubator.apache.org/docs/benchmark/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/benchmark/</guid>
      <description>
        
        
        &lt;h1 id=&#34;序言&#34;&gt;序言&lt;/h1&gt;
&lt;p&gt;在多核的前提下，性能和线程是紧密联系在一起的。线程间的跳转对高频IO操作的性能有决定性作用: 一次跳转意味着至少3-20微秒的延时，由于每个核心的L1 cache独立（我们的cpu L2 cache也是独立的），随之而来是大量的cache miss，一些变量的读取、写入延时会从纳秒级上升几百倍至微秒级: 等待cpu把对应的cacheline同步过来。有时这带来了一个出乎意料的结果，当每次的处理都很简短时，一个多线程程序未必比一个单线程程序更快。因为前者可能在每次付出了大的切换代价后只做了一点点“正事”，而后者在不停地做“正事”。不过单线程也是有代价的，它工作良好的前提是“正事”都很快，否则一旦某次变慢就使后续的所有“正事”都被延迟了。在一些处理时间普遍较短的程序中，使用（多个不相交的）单线程能最大程度地”做正事“，由于每个请求的处理时间确定，延时表现也很稳定，各种http server正是这样。但我们的检索服务要做的事情可就复杂多了，有大量的后端服务需要访问，广泛存在的长尾请求使每次处理的时间无法确定，排序策略也越来越复杂。如果还是使用（多个不相交的）单线程的话，一次难以预计的性能抖动，或是一个大请求可能导致后续一堆请求被延迟。&lt;/p&gt;
&lt;p&gt;为了避免请求之间相互影响，请求级的线程跳转是brpc必须付出的代价，我们能做的是使&lt;a href=&#34;io.md#the-full-picture&#34;&gt;线程跳转最优化&lt;/a&gt;。不过，对服务的性能测试还不能很好地体现这点。测试中的处理往往极为简单，使得线程切换的影响空前巨大，通过控制多线程和单线程处理的比例，我们可以把一个测试服务的qps从100万到500万操纵自如（同机），这损伤了性能测试结果的可信度。要知道，真实的服务并不是在累加一个数字，或者echo一个字符串，一个qps几百万的echo程序没有指导意义。鉴于此，在发起性能测试一年后（15年底），在brpc又经历了1200多次改动后，我们需要review所有的测试，加强其中的线程因素，以获得对真实场景有明确意义的结果。具体来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求不应等长，要有长尾。这能考察RPC能否让请求并发，否则一个慢请求会影响大量后续请求。&lt;/li&gt;
&lt;li&gt;要有多级server的场景。server内用client访问下游server，这能考察server和client的综合表现。&lt;/li&gt;
&lt;li&gt;要有一个client访问多个server的场景。这能考察负载均衡是否足够并发，真实场景中很少一个client只访问一个server。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们希望这套测试场景对其他服务的性能测试有借鉴意义。&lt;/p&gt;
&lt;h1 id=&#34;测试目标&#34;&gt;测试目标&lt;/h1&gt;
&lt;h2 id=&#34;ub&#34;&gt;UB&lt;/h2&gt;
&lt;p&gt;百度在08年开发的RPC框架，在百度产品线广泛使用，已被brpc代替。UB的每个请求独占一个连接(连接池)，在大规模服务中每台机器都需要保持大量的连接，限制了其使用场景，像百度的分布式系统没有用UB。UB只支持nshead+mcpack协议，也没怎么考虑扩展性，所以增加新协议和新功能往往要调整大段代码，在实践中大部分人“知难而退”了。UB缺乏调试和运维接口，服务的运行状态对用户基本是黑盒，只能靠低效地打日志来追踪问题，服务出现问题时常要拉上维护者一起排查，效率很低。UB有多个变种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ubrpc: 百度在10年基于UB开发的RPC框架，用.idl文件(类似.proto)描述数据的schema，而不是手动打包。这个RPC有被使用，但不广泛。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;nova_pbrpc: 百度网盟团队在12年基于UB开发的RPC框架，用protobuf代替mcpack作为序列化方法，协议是nshead + user&amp;rsquo;s protobuf。&lt;/li&gt;
&lt;li&gt;public_pbrpc: 百度在13年初基于UB开发的RPC框架，用protobuf代替mcpack作为序列化方法，但协议与nova_pbrpc不同，大致是nshead + meta protobuf。meta protobuf中有个string字段包含user&amp;rsquo;s protobuf。由于用户数据要序列化两次，这个RPC的性能很差，没有被推广开来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们以在百度网盟团队广泛使用的nova_pbrpc为UB的代表。测试时其代码为r10500。早期的UB支持CPOOL和XPOOL，分别使用&lt;a href=&#34;http://linux.die.net/man/2/select&#34;&gt;select&lt;/a&gt;和&lt;a href=&#34;http://kircher-schwanninger.de/michael/publications/lf.pdf&#34;&gt;leader-follower模型&lt;/a&gt;，后来提供了EPOLL，使用&lt;a href=&#34;http://man7.org/linux/man-pages/man7/epoll.7.html&#34;&gt;epoll&lt;/a&gt;处理多路连接。鉴于产品线大都是用EPOLL模型，我们的UB配置也使用EPOLL。UB只支持&lt;a href=&#34;client.md#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F&#34;&gt;连接池&lt;/a&gt;，结果用“&lt;strong&gt;ubrpc_mc&lt;/strong&gt;&amp;ldquo;指代（mc代表&amp;quot;multiple
connection&amp;rdquo;）。虽然这个名称不太准确（见上文对ubrpc的介绍），但在本文的语境下，请默认ubrpc = UB。&lt;/p&gt;
&lt;h2 id=&#34;hulu-pbrpc&#34;&gt;hulu-pbrpc&lt;/h2&gt;
&lt;p&gt;百度在13年基于saber(kylin变种)和protobuf实现的RPC框架，hulu在多线程实现上有较多问题，已被brpc代替，测试时其代码为&lt;code&gt;pbrpc_2-0-15-27959_PD_BL&lt;/code&gt;。hulu-pbrpc只支持单连接，结果用“&lt;strong&gt;hulu-pbrpc&lt;/strong&gt;&amp;ldquo;指代。&lt;/p&gt;
&lt;h2 id=&#34;brpc&#34;&gt;brpc&lt;/h2&gt;
&lt;p&gt;INF在2014年底开发至今的rpc产品，支持百度内所有协议（不限于protobuf），并第一次统一了百度主要分布式系统和业务线的RPC框架。测试时代码为r31906。brpc既支持单连接也支持连接池，前者的结果用&amp;rdquo;&lt;strong&gt;baidu-rpc&lt;/strong&gt;&amp;ldquo;指代，后者用“&lt;strong&gt;baidu-rpc_mc&lt;/strong&gt;&amp;ldquo;指代。&lt;/p&gt;
&lt;h2 id=&#34;sofa-pbrpc&#34;&gt;sofa-pbrpc&lt;/h2&gt;
&lt;p&gt;百度大搜团队在13年基于boost::asio和protobuf实现的RPC框架，有多个版本，咨询相关同学后，确认ps/opensource下的和github上的较新，且会定期同步。故测试使用使用ps/opensource下的版本。测试时其代码为&lt;code&gt;sofa-pbrpc_1-0-2_BRANCH&lt;/code&gt;。sofa-pbrpc只支持单连接，结果用“&lt;strong&gt;sofa-pbrpc&lt;/strong&gt;”指代。&lt;/p&gt;
&lt;h2 id=&#34;apache-thrift&#34;&gt;apache thrift&lt;/h2&gt;
&lt;p&gt;thrift是由facebook最早在07年开发的序列化方法和rpc框架，包含独特的序列化格式和IDL，支持很多编程语言。开源后改名&lt;a href=&#34;https://thrift.apache.org/&#34;&gt;apache thrift&lt;/a&gt;，fb自己有一个&lt;a href=&#34;https://github.com/facebook/fbthrift&#34;&gt;fbthrift分支&lt;/a&gt;，我们使用的是apache thrift。测试时其代码为&lt;code&gt;thrift_0-9-1-400_PD_BL&lt;/code&gt;。thrift的缺点是: 代码看似分层清晰，client和server选择很多，但没有一个足够通用，每个server实现都只能解决很小一块场景，每个client都线程不安全，实际使用很麻烦。由于thrift没有线程安全的client，所以每个线程中都得建立一个client，使用独立的连接。在测试中thrift其实是占了其他实现的便宜: 它的client不需要处理多线程问题。thrift的结果用&amp;rdquo;&lt;strong&gt;thrift_mc&lt;/strong&gt;&amp;ldquo;指代。&lt;/p&gt;
&lt;h2 id=&#34;grpc&#34;&gt;gRPC&lt;/h2&gt;
&lt;p&gt;由google开发的rpc框架，使用http/2和protobuf 3.0，测试时其代码为&lt;a href=&#34;https://github.com/grpc/grpc/tree/release-0_11&#34;&gt;https://github.com/grpc/grpc/tree/release-0_11&lt;/a&gt;。gRPC并不是stubby，定位更像是为了推广http/2和protobuf 3.0，但鉴于很多人对它的表现很感兴趣，我们也（很麻烦地）把它加了进来。gRPC的结果用&amp;rdquo;&lt;strong&gt;grpc&lt;/strong&gt;&amp;ldquo;指代。&lt;/p&gt;
&lt;h1 id=&#34;测试方法&#34;&gt;测试方法&lt;/h1&gt;
&lt;p&gt;如序言中解释的那样，性能数字有巨大的调整空间。这里的关键在于，我们对RPC的底线要求是什么，脱离了这个底线，测试中的表现就严重偏离真实环境中的了。&lt;/p&gt;
&lt;p&gt;这个底线我们认为是&lt;strong&gt;RPC必须能处理长尾&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在百度的环境中，这是句大白话，哪个产品线，哪个系统没有长尾呢？作为承载大部分服务的RPC框架自然得处理好长尾，减少长尾对正常请求的影响。但在实现层面，这个问题对设计的影响太大了。如果测试中没有长尾，那么RPC实现就可以假设每个请求都差不多快，这时候最优的方法是用多个线程独立地处理请求。由于没有上下文切换和cache一致性同步，程序的性能会显著高于多个线程协作时的表现。&lt;/p&gt;
&lt;p&gt;比如简单的echo程序，处理一个请求只需要200-300纳秒，单个线程可以达到300-500万的吞吐。但如果多个线程协作，即使在极其流畅的系统中，也要付出3-5微秒的上下文切换代价和1微秒的cache同步代价，这还没有考虑多个线程间的其他互斥逻辑，一般来说单个线程的吞吐很难超过10万，即使24核全部用满，吞吐也只有240万，不及一个线程。这正是以http server为典型的服务选用&lt;a href=&#34;threading_overview.md#%E5%8D%95%E7%BA%BF%E7%A8%8Breactor&#34;&gt;单线程模型&lt;/a&gt;的原因（多个线程独立运行eventloop）: 大部分http请求的处理时间是可预测的，对下游的访问也不会有任何阻塞代码。这个模型可以最大化cpu利用率，同时提供可接受的延时。&lt;/p&gt;
&lt;p&gt;多线程付出这么大的代价是为了&lt;strong&gt;隔离请求间的影响&lt;/strong&gt;。一个计算复杂或索性阻塞的过程不会影响到其他请求，1%的长尾最终只会影响到1%的性能。而多个独立的线程是保证不了这点的，一个请求进入了一个线程就等于“定了终生”，如果前面的请求慢了一下，那也只能跟着慢了。1%的长尾会影响远超1%的请求，最终表现不佳。换句话说，乍看上去多线程模型“慢”了，但在真实应用中反而会获得更好的综合性能。&lt;/p&gt;
&lt;p&gt;延时能精确地体现出长尾的干扰作用，如果普通请求的延时没有被长尾请求干扰，就说明RPC成功地隔离了请求。而QPS无法体现这点，只要CPU都在忙，即使一个正常请求进入了挤满长尾的队列而被严重延迟，最终的QPS也变化不大。为了测量长尾的干扰作用，我们在涉及到延时的测试中都增加了1%的长尾请求。&lt;/p&gt;
&lt;h1 id=&#34;开始测试&#34;&gt;开始测试&lt;/h1&gt;
&lt;h2 id=&#34;环境&#34;&gt;环境&lt;/h2&gt;
&lt;p&gt;性能测试使用的机器配置为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机1: CPU开超线程24核，E5-2620 @ 2.00GHz；64GB内存；OS linux 2.6.32_1-15-0-0&lt;/li&gt;
&lt;li&gt;多机1（15台+8台）: CPU均未开超线程12核，其中15台的CPU为E5-2420 @ 1.90GHz.，64GB内存，千兆网卡，无法开启多队列。其余8台为E5-2620 2.0GHz，千兆网卡，绑定多队列到前8个核。这些长期测试机器比较杂，跨了多个机房，测试中延时在1ms以上的就是这批机器。&lt;/li&gt;
&lt;li&gt;多机2（30台）: CPU未开超线程12核，E5-2620 v3 @ 2.40GHz.；96GB内存；OS linux 2.6.32_1-17-0-0；万兆网卡，绑定多队列到前8个核。这是临时借用的新机器，配置非常好，都在广州机房，延时非常短，测试中延时在几百微秒的就是这批机器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面所有的曲线图是使用brpc开发的dashboard程序绘制的，去掉路径后可以看到和所有brpc
server一样的&lt;a href=&#34;builtin_service.md&#34;&gt;内置服务&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;如无特殊说明，所有测试中的配置只是数量差异（线程数，请求大小，client个数etc），而不是模型差异。我们确保用户看到的qps和延时是同一个场景的不同维度，而不是无法统一的两个场景。&lt;/p&gt;
&lt;p&gt;所有RPC server都配置了24个工作线程，这些线程一般运行用户的处理逻辑。关于每种RPC的特殊说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UB: 配置了12个reactor线程，使用EPOOL模型。连接池限制数配置为线程个数（24）&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 额外配置了12个IO线程。这些线程会处理fd读取，请求解析等任务。hulu有个“共享队列“的配置项，默认不打开，作用是把fd静态散列到多个线程中，由于线程间不再争抢，hulu的qps会显著提高，但会明显地被长尾影响（原因见&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95&#34;&gt;测试方法&lt;/a&gt;）。考虑到大部分使用者并不会去改配置，我们也选择不打开。&lt;/li&gt;
&lt;li&gt;thrift: 额外配置了12个IO线程。这些线程会处理fd读取，请求解析等任务。thrift的client不支持多线程，每个线程得使用独立的client，连接也都是分开的。&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 按照sofa同学的要求，把io_service_pool_size配置为24，work_thread_num配置为1。大概含义是使用独立的24组线程池，每组1个worker thread。和hulu不打开“共享队列”时类似，这个配置会显著提高sofa-pbrpc的QPS，但同时使它失去了处理长尾的能力。如果你在真实产品中使用，我们不建议这个配置。（而应该用io_service_pool_size=1, work_thread_num=24)&lt;/li&gt;
&lt;li&gt;brpc: 尽管brpc的client运行在bthread中时会获得10%~20%的QPS提升和更低的延时，但测试中的client都运行统一的pthread中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的RPC client都以多个线程同步方式发送，这种方法最接近于真实系统中的情况，在考察QPS时也兼顾了延时因素。&lt;/p&gt;
&lt;p&gt;一种流行的方案是client不停地往连接中写入数据看server表现，这个方法的弊端在于: server一下子能读出大量请求，不同RPC的比拼变成了“for循环执行用户代码”的比拼，而不是分发请求的效率。在真实系统中server很少能同时读到超过4个请求。这个方法也完全放弃了延时，client其实是让server陷入了雪崩时才会进入的状态，所有请求都因大量排队而超时了。&lt;/p&gt;
&lt;h2 id=&#34;同机单client单server在不同请求下的qps越高越好&#34;&gt;同机单client→单server在不同请求下的QPS（越高越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;单机1&lt;/a&gt;上。图中的数值均为用户数据的字节数，实际的请求尺寸还要包括协议头，一般会增加40字节左右。&lt;/p&gt;
&lt;p&gt;（X轴是用户数据的字节数，Y轴是对应的QPS）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/qps_vs_reqsize.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;以_mc结尾的曲线代表client和server保持多个连接（线程数个），在本测试中会有更好的表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc: 当请求包小于16KB时，单连接下的吞吐超过了多连接的ubrpc_mc和thrift_mc，随着请求包变大，内核对单个连接的写入速度成为瓶颈。而多连接下的brpc则达到了测试中最高的2.3GB/s。注意: 虽然使用连接池的brpc在发送大包时吞吐更高，但也会耗费更多的CPU（UB和thrift也是这样）。下图中的单连接brpc已经可以提供800多兆的吞吐，足以打满万兆网卡，而使用的CPU可能只有多链接下的1/2(写出过程是&lt;a href=&#34;io.md#%E5%8F%91%E6%B6%88%E6%81%AF&#34;&gt;wait-free的&lt;/a&gt;)，真实系统中请优先使用单链接。&lt;/li&gt;
&lt;li&gt;thrift: 初期明显低于brpc，随着包变大超过了单连接的brpc。&lt;/li&gt;
&lt;li&gt;UB:和thrift类似的曲线，但平均要低4-5万QPS，在32K包时超过了单连接的brpc。整个过程中QPS几乎没变过。&lt;/li&gt;
&lt;li&gt;gRPC: 初期几乎与UB平行，但低1万左右，超过8K开始下降。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc和sofa-pbrpc: 512字节前高于UB和gRPC，但之后就急转直下，相继垫底。这个趋势是写不够并发的迹象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同机单client单server在不同线程数下的qps越高越好&#34;&gt;同机单client→单server在不同线程数下的QPS（越高越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;单机1&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;（X轴是线程数，Y轴是对应的QPS）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/qps_vs_threadnum.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;brpc: 随着发送线程增加，QPS在快速增加，有很好的多线程扩展性。&lt;/p&gt;
&lt;p&gt;UB和thrift: 8个线程下高于brpc，但超过8个线程后被brpc迅速超过，thrift继续“平移”，UB出现了明显下降。&lt;/p&gt;
&lt;p&gt;gRPC，hulu-pbrpc，sofa-pbrpc: 几乎重合，256个线程时相比1个线程时只有1倍的提升，多线程扩展性不佳。&lt;/p&gt;
&lt;h2 id=&#34;同机单client单server在固定qps下的延时cdfvarsmd统计和查看分位值越左越好越直越好&#34;&gt;同机单client→单server在固定QPS下的延时&lt;a href=&#34;vars.md#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E7%9C%8B%E5%88%86%E4%BD%8D%E5%80%BC&#34;&gt;CDF&lt;/a&gt;（越左越好，越直越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;单机1&lt;/a&gt;上。考虑到不同RPC的处理能力，我们选择了一个较低、在不少系统中会达到的的QPS: 1万。&lt;/p&gt;
&lt;p&gt;本测试中有1%的长尾请求耗时5毫秒，长尾请求的延时不计入结果，因为我们考察的是普通请求是否被及时处理了。&lt;/p&gt;
&lt;p&gt;（X轴是延时（微秒），Y轴是小于X轴延时的请求比例）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/latency_cdf.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc: 平均延时短，几乎没有被长尾影响。&lt;/li&gt;
&lt;li&gt;UB和thrift: 平均延时比brpc高1毫秒，受长尾影响不大。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 走向和UB和thrift类似，但平均延时进一步增加了1毫秒。&lt;/li&gt;
&lt;li&gt;gRPC : 初期不错，到长尾区域后表现糟糕，直接有一部分请求超时了。（反复测试都是这样，像是有bug）&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 30%的普通请求（上图未显示）被长尾严重干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跨机多client单server的qps越高越好&#34;&gt;跨机多client→单server的QPS（越高越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;多机1&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;（X轴是client数，Y轴是对应的QPS）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/qps_vs_multi_client.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc: 随着cilent增加，server的QPS在快速增加，有不错的client扩展性。&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 随着client增加，server的QPS也在快速增加，但幅度不如brpc，client扩展性也不错。从16个client到32个client时的提升较小。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 随着client增加，server的QPS在增加，但幅度进一步小于sofa-pbrpc。&lt;/li&gt;
&lt;li&gt;UB: 增加client几乎不能增加server的QPS。&lt;/li&gt;
&lt;li&gt;thrift: 平均QPS低于UB，增加client几乎不能增加server的QPS。&lt;/li&gt;
&lt;li&gt;gRPC: 垫底、增加client几乎不能增加server的QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跨机多client单server在固定qps下的延时cdfvarsmd统计和查看分位值越左越好越直越好&#34;&gt;跨机多client→单server在固定QPS下的延时&lt;a href=&#34;vars.md#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E7%9C%8B%E5%88%86%E4%BD%8D%E5%80%BC&#34;&gt;CDF&lt;/a&gt;（越左越好，越直越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;多机1&lt;/a&gt;上。负载均衡算法为round-robin或RPC默认提供的。由于有32个client且一些RPC的单client能力不佳，我们为每个client仅设定了2500QPS，这是一个真实业务系统能达到的数字。&lt;/p&gt;
&lt;p&gt;本测试中有1%的长尾请求耗时15毫秒，长尾请求的延时不计入结果，因为我们考察的是普通请求是否被及时处理了。&lt;/p&gt;
&lt;p&gt;（X轴是延时（微秒），Y轴是小于X轴延时的请求比例）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/multi_client_latency_cdf.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc: 平均延时短，几乎没有被长尾影响。&lt;/li&gt;
&lt;li&gt;UB和thrift: 平均延时短，受长尾影响小，平均延时高于brpc&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 14%的普通请求被长尾严重干扰。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 15%的普通请求被长尾严重干扰。&lt;/li&gt;
&lt;li&gt;gRPC: 已经完全失控，非常糟糕。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跨机多client多server在固定qps下的延时cdfvarsmd统计和查看分位值越左越好越直越好&#34;&gt;跨机多client→多server在固定QPS下的延时&lt;a href=&#34;vars.md#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E7%9C%8B%E5%88%86%E4%BD%8D%E5%80%BC&#34;&gt;CDF&lt;/a&gt;（越左越好，越直越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;多机2&lt;/a&gt;上。20台每台运行4个client，多线程同步访问10台server。负载均衡算法为round-robin或RPC默认提供的。由于gRPC访问多server较麻烦且有很大概率仍表现不佳，这个测试不包含gRPC。&lt;/p&gt;
&lt;p&gt;本测试中有1%的长尾请求耗时10毫秒，长尾请求的延时不计入结果，因为我们考察的是普通请求是否被及时处理了。&lt;/p&gt;
&lt;p&gt;（X轴是延时（微秒），Y轴是小于X轴延时的请求比例）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/multi_server_latency_cdf.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc和UB: 平均延时短，几乎没有被长尾影响。&lt;/li&gt;
&lt;li&gt;thrift: 平均延时显著高于brpc和UB。&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 2.5%的普通请求被长尾严重干扰。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 22%的普通请求被长尾严重干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;跨机多client多server多server在固定qps下的延时cdfvarsmd统计和查看分位值越左越好越直越好&#34;&gt;跨机多client→多server→多server在固定QPS下的延时&lt;a href=&#34;vars.md#%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%9F%A5%E7%9C%8B%E5%88%86%E4%BD%8D%E5%80%BC&#34;&gt;CDF&lt;/a&gt;（越左越好，越直越好）&lt;/h2&gt;
&lt;p&gt;本测试运行在&lt;a href=&#34;#%E7%8E%AF%E5%A2%83&#34;&gt;多机2&lt;/a&gt;上。14台每台运行4个client，多线程同步访问8台server，这些server还会同步访问另外8台server。负载均衡算法为round-robin或RPC默认提供的。由于gRPC访问多server较麻烦且有很大概率仍表现不佳，这个测试不包含gRPC。&lt;/p&gt;
&lt;p&gt;本测试中有1%的长尾请求耗时10毫秒，长尾请求的延时不计入结果，因为我们考察的是普通请求是否被及时处理了。&lt;/p&gt;
&lt;p&gt;（X轴是延时（微秒），Y轴是小于X轴延时的请求比例）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/twolevel_server_latency_cdf.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brpc: 平均延时短，几乎没有被长尾影响。&lt;/li&gt;
&lt;li&gt;UB: 平均延时短，长尾区域略差于brpc。&lt;/li&gt;
&lt;li&gt;thrift: 平均延时显著高于brpc和UB。&lt;/li&gt;
&lt;li&gt;sofa-pbrpc: 17%的普通请求被长尾严重干扰，其中2%的请求延时极长。&lt;/li&gt;
&lt;li&gt;hulu-pbrpc: 基本消失在视野中，已无法正常工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;结论&#34;&gt;结论&lt;/h1&gt;
&lt;p&gt;brpc: 在吞吐，平均延时，长尾处理上都表现优秀。&lt;/p&gt;
&lt;p&gt;UB: 平均延时和长尾处理的表现都不错，吞吐的扩展性较差，提高线程数和client数几乎不能提升吞吐。&lt;/p&gt;
&lt;p&gt;thrift: 单机的平均延时和吞吐尚可，多机的平均延时明显高于brpc和UB。吞吐的扩展性较差，提高线程数和client数几乎不能提升吞吐。&lt;/p&gt;
&lt;p&gt;sofa-pbrpc: 处理小包的吞吐尚可，大包的吞吐显著低于其他RPC，延时受长尾影响很大。&lt;/p&gt;
&lt;p&gt;hulu-pbrpc: 单机表现和sofa-pbrpc类似，但多机的延时表现极差。&lt;/p&gt;
&lt;p&gt;gRPC: 几乎在所有参与的测试中垫底，可能它的定位是给google cloud platform的用户提供一个多语言，对网络友好的实现，性能还不是要务。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 下载bRPC</title>
      <link>https://brpc.incubator.apache.org/docs/downloadbrpc/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/downloadbrpc/</guid>
      <description>
        
        
        &lt;!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the &#34;License&#34;); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}
--&gt;
&lt;h2 id=&#34;下载-apache-brpc-incubating&#34;&gt;下载 Apache bRPC (incubating)&lt;/h2&gt;
&lt;p&gt;Apache brpc（孵化）作为源工件发布。我们很高兴宣布我们的1.0.0版本已经发布如下了！&lt;/p&gt;
&lt;h3 id=&#34;候选版本&#34;&gt;候选版本&lt;/h3&gt;
&lt;!--when pass vote, we can change it back to Release Artifacts
--&gt;
&lt;table class=&#34;table table-hover sortable&#34;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;b&gt;名字&lt;/b&gt;&lt;/th&gt;
            &lt;th&gt;&lt;b&gt;存档&lt;/b&gt;&lt;/th&gt;
            &lt;th&gt;&lt;b&gt;加密算法&lt;/b&gt;&lt;/th&gt;
            &lt;th&gt;&lt;b&gt;签名&lt;/b&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Apache brpc (incubating) 1.0.0 (tar.gz)&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://www.apache.org/dyn/closer.lua/incubator/brpc/1.0.0/apache-brpc-1.0.0-incubating-src.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://downloads.apache.org/incubator/brpc/1.0.0/apache-brpc-1.0.0-incubating-src.tar.gz.sha512&#34;&gt;SHA-512&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://downloads.apache.org/incubator/brpc/1.0.0/apache-brpc-1.0.0-incubating-src.tar.gz.asc&#34;&gt;ASC&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Apache brpc (incubating)  1.0.0-rc02 (tar.gz)&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://www.apache.org/dyn/closer.lua/incubator/brpc/1.0.0-rc02/apache-brpc-1.0.0-rc02-incubating-src.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://downloads.apache.org/incubator/brpc/1.0.0-rc02/apache-brpc-1.0.0-rc02-incubating-src.tar.gz.sha512&#34;&gt;SHA-512&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://downloads.apache.org/incubator/brpc/1.0.0-rc02/apache-brpc-1.0.0-rc02-incubating-src.tar.gz.asc&#34;&gt;ASC&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;!--tr&gt;
            &lt;td&gt;Release Notes&lt;/td&gt;
            &lt;td&gt;&lt;a href=&#34;https://brpc.incubator.apache.org/releases/spark/{{ site.data.project.latest_release }}/release-notes&#34;&gt;{{ site.data.project.latest_release }}&lt;/a&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr--&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;选择&lt;em&gt;tar&lt;/em&gt;或&lt;em&gt;zip&lt;/em&gt;格式的源发行版，并使用相应的&lt;em&gt;pgp&lt;/em&gt;签名（使用&lt;a href=&#34;https://downloads.apache.org/incubator/brpc/KEYS&#34;&gt;密钥&lt;/a&gt;中的提交者文件）进行&lt;a href=&#34;https://www.apache.org/dyn/closer.cgi#verify&#34;&gt;验证&lt;/a&gt;。如果您无法做到这一点，可以使用&lt;em&gt;md5&lt;/em&gt;哈希文件检查下载是否已完成。&lt;/p&gt;
&lt;p&gt;为了快速下载，当前的源发行版托管在镜像服务器上；较旧的源发行版在&lt;a href=&#34;https://archive.apache.org/dist/incubator/brpc/&#34;&gt;存档&lt;/a&gt;中。如果从镜像下载失败，请重试，第二次下载可能会成功。&lt;/p&gt;
&lt;p&gt;为了安全起见，哈希文件和签名文件始终托管在&lt;a href=&#34;https://www.apache.org&#34;&gt;Apache&lt;/a&gt;上。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FAQ</title>
      <link>https://brpc.incubator.apache.org/docs/faq/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/faq/</guid>
      <description>
        
        
        &lt;p&gt;查看 &lt;a href=&#34;https://github.com/apache/incubator-brpc/issues&#34;&gt;https://github.com/apache/incubator-brpc/issues&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 用户</title>
      <link>https://brpc.incubator.apache.org/docs/users/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/users/</guid>
      <description>
        
        
        &lt;div id=&#34;overview&#34;&gt;
  &lt;div class=&#34;contain&#34; style=&#34;width: auto; margin: 0 auto&#34;&gt;
    &lt;h2 class=&#34;section-head&#34;&gt;谁在使用&lt;/h2&gt;
    &lt;h3&gt;在&lt;a href=&#34;https://github.com/apache/incubator-brpc-website/issues/1307&#34;&gt;Wanted: who’s using bRPC&lt;/a&gt; 上面提交你的使用场景来帮助bRPC变的更好
    &lt;/h3&gt;
    &lt;td align=&#34;center&#34;  valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;http://home.baidu.com/index.html&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/baidu_logo.svg&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.iqiyi.com&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/iqiyi_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://bytedance.com/zh/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/bytedance_logo.svg&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.bilibili.com/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/bilibili_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://bigo.tv/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/bigo_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.didiglobal.com/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/didi_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.capitalonline.net/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/cdsshouyun_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.amap.com/&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/gaode_logo.png&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;middle&#34;&gt;
      &lt;a href=&#34;https://www.weibo.com&#34; target=&#34;_blank&#34;&gt;
        &lt;img width=&#34;222px&#34; style=&#34;margin: 0 10px;&#34; src=&#34;https://brpc.incubator.apache.org/images/community/weibo_logo.svg&#34;&gt;
      &lt;/a&gt;
    &lt;/td&gt;
  &lt;/div&gt;
&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: 社区</title>
      <link>https://brpc.incubator.apache.org/docs/community/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/community/</guid>
      <description>
        
        
        &lt;!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the &#34;License&#34;); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}
--&gt;
&lt;h2 id=&#34;apache-brpc-孵化-社区&#34;&gt;Apache brpc (孵化) 社区&lt;/h2&gt;
&lt;p&gt;每个志愿者项目的力量都来自参与其中的人。我们邀请您尽可能多或少地参与。&lt;/p&gt;
&lt;p&gt;你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用我们的项目并提供反馈。&lt;/li&gt;
&lt;li&gt;向我们提供用例。&lt;/li&gt;
&lt;li&gt;报告错误并提交补丁。&lt;/li&gt;
&lt;li&gt;贡献代码、测试用例和文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多有关信息，请访问[贡献]页面。&lt;/p&gt;
&lt;h3 id=&#34;邮件列表&#34;&gt;邮件列表&lt;/h3&gt;
&lt;p&gt;使用bRPC获取帮助或在我们的邮件列表中为项目做出贡献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;dev@brpc.apache.org&#34;&gt;dev@brpc.apache.org&lt;/a&gt;适用于希望为bRPC贡献代码的人。&lt;a href=&#34;mailto:dev-subscribe@brpc.apache.org?subject=send%20this%20email%20to%20subscribe&#34;&gt;订阅&lt;/a&gt;, &lt;a href=&#34;mailto:dev-unsubscribe@brpc.apache.org?subject=send%20this%20email%20to%20unsubscribe&#34;&gt;取消订阅&lt;/a&gt;, &lt;a href=&#34;https://www.mail-archive.com/dev@brpc.apache.org/&#34;&gt;存档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;commits@brpc.apache.org&#34;&gt;commits@brpc.apache.org&lt;/a&gt;用于向bRPC提交消息和修补程序。&lt;a href=&#34;mailto:commits-subscribe@brpc.apache.org?subject=send%20this%20email%20to%20subscribe&#34;&gt;订阅&lt;/a&gt;, &lt;a href=&#34;mailto:commits-unsubscribe@brpc.apache.org?subject=send%20this%20email%20to%20unsubscribe&#34;&gt;取消订阅&lt;/a&gt;, &lt;a href=&#34;https://www.mail-archive.com/commits@brpc.apache.org/&#34;&gt;存档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;问题追踪&#34;&gt;问题追踪&lt;/h3&gt;
&lt;h4 id=&#34;bug报告&#34;&gt;Bug报告&lt;/h4&gt;
&lt;p&gt;发现bug? 在&lt;a href=&#34;https://github.com/apache/incubator-brpc/issues&#34;&gt;问题追踪&lt;/a&gt;页面中提交问题。&lt;/p&gt;
&lt;p&gt;在提交问题之前，请：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证该错误是否确实存在。&lt;/li&gt;
&lt;li&gt;搜索问题追踪器，以确认没有报告您发现的错误的现有问题。&lt;/li&gt;
&lt;li&gt;考虑自己在bRPC的源代码中跟踪bug并提交一个补丁和bug报告。这对bRPC开发人员来说是一个很好的省时方法，并且有助于确保bug能够快速修复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;功能请求&#34;&gt;功能请求&lt;/h4&gt;
&lt;p&gt;我们也欢迎对新功能的增强请求。请求越具体，理由越充分，它被纳入未来版本的可能性就越大。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/apache/incubator-brpc/issues&#34;&gt;https://github.com/apache/incubator-brpc/issues&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;源代码&#34;&gt;源代码&lt;/h3&gt;
&lt;p&gt;可以通过github上的&lt;a href=&#34;https://github.com/apache/incubator-brpc&#34;&gt;源代码库&lt;/a&gt;访问项目源代码。&lt;/p&gt;
&lt;h3 id=&#34;网站源代码&#34;&gt;网站源代码&lt;/h3&gt;
&lt;p&gt;可以通过github上的&lt;a href=&#34;https://github.com/apache/incubator-brpc-website&#34;&gt;网站源代码库&lt;/a&gt;访问项目网站源代码。&lt;/p&gt;
&lt;h3 id=&#34;brpc团队成员&#34;&gt;bRPC团队成员&lt;/h3&gt;
&lt;table class=&#34;table table-hover&#34;&gt;
    &lt;tr&gt;
        &lt;th&gt;&lt;b&gt;Photo&lt;/b&gt;&lt;/th&gt;
        &lt;th&gt;&lt;b&gt;Full Name&lt;/b&gt;&lt;/th&gt;
        &lt;th&gt;&lt;b&gt;Apache ID&lt;/b&gt;&lt;/th&gt;
        &lt;th&gt;&lt;b&gt;GitHub&lt;/b&gt;&lt;/th&gt;
        &lt;th&gt;&lt;b&gt;Role&lt;/b&gt;&lt;/th&gt;
        &lt;th&gt;&lt;b&gt;Affiliation&lt;/b&gt;&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/jamesge&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/6566535?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;James Ge&lt;/td&gt;
        &lt;td&gt;jamesge&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/jamesge&#34;&gt;jamesge&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/zyearn&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/4475779?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Jiashun Zhu&lt;/td&gt;
        &lt;td&gt;jiashunzhu&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/zyearn&#34;&gt;zyearn&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/chenzhangyi&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/6805583?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Zhangyi Chen&lt;/td&gt;
        &lt;td&gt;zychen&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/chenzhangyi&#34;&gt;chenzhangyi&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/old-bear&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/1525532?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Bear Jiang&lt;/td&gt;
        &lt;td&gt;jrjbear&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/old-bear&#34;&gt;old-bear&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/ipconfigme&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/2500750?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;fisherman&lt;/td&gt;
        &lt;td&gt;fisherman&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/ipconfigme&#34;&gt;ipconfigme&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/tanzhongyi003&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/20179982?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Jerry Tan&lt;/td&gt;
        &lt;td&gt;jerrytan&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/tanzhongyi003&#34;&gt;tanzhongyi003&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/gydong&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/3294444?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Gaidong Mou&lt;/td&gt;
        &lt;td&gt;gydong&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/gydong&#34;&gt;gydong&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/TousakaRin&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/8801314?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;He Lei&lt;/td&gt;
        &lt;td&gt;leander&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/TousakaRin&#34;&gt;TousakaRin&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/cdjingit&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/31362185?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Cai daojing&lt;/td&gt;
        &lt;td&gt;caidj&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/cdjingit&#34;&gt;cdjingit&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;PPMC&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/lorinlee&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/16054841?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Li Lei&lt;/td&gt;
        &lt;td&gt;lorinlee&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/lorinlee&#34;&gt;lorinlee&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Committer&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/guodongxiaren&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/5945107?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Wang wei&lt;/td&gt;
        &lt;td&gt;guodong&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/guodongxiaren&#34;&gt;guodongxiaren&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Committer&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/wwbmmm&#34;&gt;&lt;img width=&#34;64&#34; src=&#34;https://avatars.githubusercontent.com/u/3894631?v=4&#34;&gt;&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Weibing Wang&lt;/td&gt;
        &lt;td&gt;weibingwang&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;http://github.com/wwbmmm&#34;&gt;wwbmmm&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;Committer&lt;/td&gt;
        &lt;td&gt;apache&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

      </description>
    </item>
    
  </channel>
</rss>
