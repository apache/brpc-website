<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bRPC – 内置服务</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/</link><description>Recent content in 内置服务 on bRPC</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://brpc.incubator.apache.org/zh/docs/builtin-services/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: builtin services</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/buildin_services/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/buildin_services/</guid><description>
&lt;h1 id="什么是内置服务">什么是内置服务？&lt;/h1>
&lt;p>内置服务以多种形式展现服务器内部状态，提高你开发和调试服务的效率。brpc通过HTTP协议提供内置服务，可通过浏览器或curl访问，服务器会根据User-Agent返回纯文本或html，你也可以添加?console=1要求返回纯文本。我们在自己的开发机上启动了&lt;a href="http://brpc.baidu.com:8765/">一个长期运行的例子&lt;/a>(只能百度内访问)，你可以点击后随便看看。如果服务端口被限（比如百度内不是所有的端口都能被笔记本访问到），可以使用&lt;a href="../../tools/rpc_view/">rpc_view&lt;/a>转发。&lt;/p>
&lt;p>下面是分别从浏览器和终端访问的截图，注意其中的logo是百度内部的名称，在开源版本中是brpc。&lt;/p>
&lt;p>&lt;strong>从浏览器访问&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/builtin_service_more.png" alt="img">&lt;/p>
&lt;p>&lt;strong>从命令行访问&lt;/strong> &lt;img src="https://brpc.incubator.apache.org/images/docs/builtin_service_from_console.png" alt="img">&lt;/p>
&lt;h1 id="安全模式">安全模式&lt;/h1>
&lt;p>出于安全考虑，直接对外服务需要隐藏内置服务（包括经过nginx或其他http server转发流量的），具体方法请阅读&lt;a href="../../server/basics/#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F">这里&lt;/a>。&lt;/p>
&lt;h1 id="主要服务">主要服务&lt;/h1>
&lt;p>&lt;a href="../status/">/status&lt;/a>: 显示所有服务的主要状态。&lt;/p>
&lt;p>&lt;a href="../vars/">/vars&lt;/a>: 用户可定制的，描绘各种指标的计数器。&lt;/p>
&lt;p>&lt;a href="../connections/">/connections&lt;/a>: 所有连接的统计信息。&lt;/p>
&lt;p>&lt;a href="../flags/">/flags&lt;/a>: 所有gflags的状态，可动态修改。&lt;/p>
&lt;p>&lt;a href="../rpcz">/rpcz&lt;/a>: 查看所有的RPC的细节。&lt;/p>
&lt;p>&lt;a href="../cpu_profiler">cpu profiler&lt;/a>: 分析cpu热点。&lt;/p>
&lt;p>&lt;a href="../heap_profiler">heap profiler&lt;/a>: 分析内存占用。&lt;/p>
&lt;p>&lt;a href="../contention_profiler">contention profiler&lt;/a>: 分析锁竞争。&lt;/p>
&lt;h1 id="其他服务">其他服务&lt;/h1>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/version">/version&lt;/a>: 查看服务器的版本。用户可通过Server::set_version()设置Server的版本，如果用户没有设置，框架会自动为用户生成，规则：&lt;code>brpc_server_&amp;lt;service-name1&amp;gt;_&amp;lt;service-name2&amp;gt; ...&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/version_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/health">/health&lt;/a>: 探测服务的存活情况。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/health_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/protobufs">/protobufs&lt;/a>: 查看程序中所有的protobuf结构体。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/protobufs_service.png" alt="img">&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vlog">/vlog&lt;/a>: 查看程序中当前可开启的&lt;a href="../../c++-base/streaming-log#vlog">VLOG&lt;/a> (对glog无效)。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vlog_service.png" alt="img">&lt;/p>
&lt;p>/dir: 浏览服务器上的所有文件，方便但非常危险，默认关闭。&lt;/p>
&lt;p>/threads: 查看进程内所有线程的运行状况，调用时对程序性能影响较大，默认关闭。&lt;/p></description></item><item><title>Docs: status</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/status/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/status/</guid><description>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/status">/status&lt;/a>可以访问服务的主要统计信息。这些信息和/vars是同源的，但按服务重新组织方便查看。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/status.png" alt="img">&lt;/p>
&lt;p>上图中字段的含义分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>non_service_error&lt;/strong>: 在service处理过程之外的错误个数。当获取到合法的service，之后发生的错误就算&lt;em>service_error&lt;/em>，否则算&lt;em>non_service_error&lt;/em>（比如请求解析失败，service名称不存在，请求并发度超限被拒绝等）。作为对比，服务过程中对后端服务的访问错误不是&lt;em>non_service_error&lt;/em>。即使写出的response代表错误，此error也被记入对应的service，而不是&lt;em>non_service_error&lt;/em>。&lt;/li>
&lt;li>&lt;strong>connection_count&lt;/strong>: 向该server发起请求的连接个数。不包含记录在/vars/rpc_channel_connection_count的对外连接的个数。&lt;/li>
&lt;li>&lt;strong>example.EchoService&lt;/strong>: 服务的完整名称，包含proto中的包名。&lt;/li>
&lt;li>&lt;strong>Echo (EchoRequest) returns (EchoResponse)&lt;/strong>: 方法签名，一个服务可包含多个方法，点击request/response上的链接可查看对应的protobuf结构体。&lt;/li>
&lt;li>&lt;strong>count&lt;/strong>: 成功处理的请求总个数。&lt;/li>
&lt;li>&lt;strong>error&lt;/strong>: 失败的请求总个数。&lt;/li>
&lt;li>&lt;strong>latency&lt;/strong>: 在html下是&lt;em>从右到左&lt;/em>分别是过去60秒，60分钟，24小时，30天的平均延时。纯文本下是10秒内(&lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>控制)的平均延时。&lt;/li>
&lt;li>&lt;strong>latency_percentiles&lt;/strong>: 是延时的80%, 90%, 99%, 99.9%分位值，统计窗口默认10秒(&lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>控制)，在html下有曲线。&lt;/li>
&lt;li>&lt;strong>latency_cdf&lt;/strong>: 用&lt;a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">CDF&lt;/a>展示分位值, 只能在html下查看。&lt;/li>
&lt;li>&lt;strong>max_latency&lt;/strong>: 在html下&lt;em>从右到左&lt;/em>分别是过去60秒，60分钟，24小时，30天的最大延时。纯文本下是10秒内(&lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>控制)的最大延时。&lt;/li>
&lt;li>&lt;strong>qps&lt;/strong>: 在html下从右到左分别是过去60秒，60分钟，24小时，30天的平均qps(Queries Per Second)。纯文本下是10秒内(&lt;a href="http://brpc.baidu.com:8765/flags/bvar_dump_interval">-bvar_dump_interval&lt;/a>控制)的平均qps。&lt;/li>
&lt;li>&lt;strong>processing&lt;/strong>: (新版改名为concurrency)正在处理的请求个数。在压力归0后若此指标仍持续不为0，server则很有可能bug，比如忘记调用done了或卡在某个处理步骤上了。&lt;/li>
&lt;/ul>
&lt;p>用户可通过让对应Service实现&lt;a href="https://github.com/brpc/brpc/blob/master/src/brpc/describable.h">brpc::Describable&lt;/a>自定义在/status页面上的描述.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">class&lt;/span> &lt;span style="color:#000">MyService&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">public&lt;/span> &lt;span style="color:#000">XXXService&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">public&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">Describable&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">public&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">Describe&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">std&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">ostream&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">os&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">DescribeOptions&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span> &lt;span style="color:#000">options&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">os&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;my_status: blahblah&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比如:&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/status_2.png" alt="img">&lt;/p></description></item><item><title>Docs: vars</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/vars/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/vars/</guid><description>
&lt;p>&lt;a href="https://github.com/brpc/brpc/tree/master/src/bvar/">bvar&lt;/a>是多线程环境下的计数器类库，方便记录和查看用户程序中的各类数值，它利用了thread local存储减少了cache bouncing，相比UbMonitor(百度内的老计数器库)几乎不会给程序增加性能开销，也快于竞争频繁的原子操作。brpc集成了bvar，&lt;a href="http://brpc.baidu.com:8765/vars">/vars&lt;/a>可查看所有曝光的bvar，&lt;a href="http://brpc.baidu.com:8765/vars/rpc_socket_count">/vars/VARNAME&lt;/a>可查阅某个bvar，增加计数器的方法请查看&lt;a href="../../bvar/bvar/">bvar&lt;/a>。brpc大量使用了bvar提供统计数值，当你需要在多线程环境中计数并展现时，应该第一时间想到bvar。但bvar不能代替所有的计数器，它的本质是把写时的竞争转移到了读：读得合并所有写过的线程中的数据，而不可避免地变慢了。当你读写都很频繁或得基于最新值做一些逻辑判断时，你不应该用bvar。&lt;/p>
&lt;h2 id="查询方法">查询方法&lt;/h2>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars">/vars&lt;/a> : 列出所有曝光的bvar&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/rpc_socket_count">/vars/NAME&lt;/a>：查询名字为NAME的bvar&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/pid;process_cpu_usage;rpc_controller_count">/vars/NAME1,NAME2,NAME3&lt;/a>：查询名字为NAME1或NAME2或NAME3的bvar&lt;/p>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/vars/rpc_server*_count;iobuf_blo$k_*">/vars/foo*,b$r&lt;/a>：查询名字与某一统配符匹配的bvar，注意用$代替?匹配单个字符，因为?是URL的保留字符。&lt;/p>
&lt;p>以下动画演示了如何使用过滤功能。你可以把包含过滤表达式的url复制粘贴给他人，他们点开后将看到相同的计数器条目。(数值可能随运行变化)&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_1.gif" alt="img">&lt;/p>
&lt;p>/vars左上角有一个搜索框能加快寻找特定bvar的速度，在这个搜索框你只需键入bvar名称的一部分，框架将补上*进行模糊查找。不同的名称间可以逗号、分号或空格分隔。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_2.gif" alt="img">&lt;/p>
&lt;p>你也可以在命令行中访问vars：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ curl brpc.baidu.com:8765/vars/bthread*
bthread_creation_count : 125134
bthread_creation_latency : 3
bthread_creation_latency_50 : 3
bthread_creation_latency_90 : 5
bthread_creation_latency_99 : 7
bthread_creation_latency_999 : 12
bthread_creation_latency_9999 : 12
bthread_creation_latency_cdf : &amp;#34;click to view&amp;#34;
bthread_creation_latency_percentiles : &amp;#34;[3,5,7,12]&amp;#34;
bthread_creation_max_latency : 7
bthread_creation_qps : 100
bthread_group_status : &amp;#34;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 &amp;#34;
bthread_num_workers : 24
bthread_worker_usage : 1.01056
&lt;/code>&lt;/pre>&lt;h2 id="查看历史趋势">查看历史趋势&lt;/h2>
&lt;p>点击大部分数值型的bvar会显示其历史趋势。每个可点击的bvar记录了过去60秒，60分钟，24小时，30天总计174个值。当有1000个可点击bvar时大约会占1M内存。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_3.gif" alt="img">&lt;/p>
&lt;h2 id="统计和查看分位值">统计和查看分位值&lt;/h2>
&lt;p>x%分位值（percentile）是指把一段时间内的N个统计值排序，排在第N * x%位的值。比如一段时间内有1000个值，先从小到大排序，排在第500位(1000 * 50%)的值是50%分位值（即中位数），排在第990位的是99%分位值(1000 * 99%)，排在第999位的是99.9%分位值。分位值能比平均值更准确的刻画数值的分布，对理解系统行为有重要意义。工业级应用的SLA一般在99.97%以上(此为百度对二级系统的要求，一级是99.99%以上)，一些系统即使平均值不错，但不佳的长尾区域也会明显拉低和打破SLA。分位值能帮助分析长尾区域。&lt;/p>
&lt;p>分位值可以绘制为CDF曲线和按时间变化的曲线。&lt;/p>
&lt;p>&lt;strong>下图是分位值的CDF&lt;/strong>，横轴是比例(排序位置/总数)，纵轴是对应的分位值。比如横轴=50%处对应的纵轴值便是50%分位值。如果系统要求的性能指标是&amp;quot;99.9%的请求在xx毫秒内完成“，那么你就得看下99.9%那儿的值。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_4.png" alt="img">&lt;/p>
&lt;p>为什么叫它&lt;a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">CDF&lt;/a>? 当选定一个纵轴值y时，对应横轴的含义是&amp;quot;数值 &amp;lt;= y的比例”，由于数值一般来自随机采样，横轴也可以理解为“数值 &amp;lt;= y的概率”，或P(数值 &amp;lt;= y)，这就是CDF的定义。&lt;/p>
&lt;p>CDF的导数是&lt;a href="https://en.wikipedia.org/wiki/Probability_density_function">概率密度函数&lt;/a>。如果把CDF的纵轴分为很多小段，对每个小段计算两端对应的横轴值之差，并把这个差作为新的横轴，那么我们便绘制了PDF曲线，就像顺时针旋转了90度的正态分布那样。但中位数的密度往往很高，在PDF中很醒目，这使得边上的长尾很扁而不易查看，所以大部分系统测量结果选择CDF曲线而不是PDF曲线。&lt;/p>
&lt;p>可用一些简单规则衡量CDF曲线好坏：&lt;/p>
&lt;ul>
&lt;li>越平越好。一条水平线是最理想的，这意味着所有的数值都相等，没有任何等待，拥塞，停顿。当然这是不可能的。&lt;/li>
&lt;li>99%和100%间的面积越小越好：99%之后是长尾的聚集地，对大部分系统的SLA有重要影响。&lt;/li>
&lt;/ul>
&lt;p>一条缓慢上升且长尾区域面积不大的CDF便是不错的曲线。&lt;/p>
&lt;p>&lt;strong>下图是按分位值按时间变化的曲线&lt;/strong>，包含了4条曲线，横轴是时间，纵轴从上到下分别对应99.9%，99%，90%，50%分位值。颜色从上到下也越来越浅（从橘红到土黄）。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_5.png" alt="img">&lt;/p>
&lt;p>滑动鼠标可以阅读对应数据点的值，上图中显示的是”39秒种前的99%分位值是330&lt;strong>微秒&lt;/strong>”。这幅图中不包含99.99%的曲线，因为99.99%分位值常明显大于99.9%及以下的分位值，画在一起的话会使得其他曲线变得很”矮“，难以辨认。你可以点击以&amp;quot;_latency_9999&amp;quot;结尾的bvar独立查看99.99%曲线。按时间变化曲线可以看到分位值的变化趋势，对分析系统的性能变化很实用。&lt;/p>
&lt;p>brpc的服务都会自动统计延时分布，用户不用自己加了。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_6.png" alt="img">&lt;/p>
&lt;p>你可以用bvar::LatencyRecorder统计任何代码的延时，这么做(更具体的使用方法请查看&lt;a href="../../bvar/bvar-c++/">bvar-c++&lt;/a>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;bvar/bvar.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">bvar&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">LatencyRecorder&lt;/span> &lt;span style="color:#000">g_latency_recorder&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;client&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// expose this recorder
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">void&lt;/span> &lt;span style="color:#000">foo&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">g_latency_recorder&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#000">my_latency&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果这个程序使用了brpc server，那么你应该已经可以在/vars看到client_latency, client_latency_cdf等变量，点击便可查看动态曲线。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/vars_7.png" alt="img">&lt;/p>
&lt;h2 id="非brpc-server">非brpc server&lt;/h2>
&lt;p>如果你的程序只是一个brpc client或根本没有使用brpc，并且你也想看到动态曲线，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p></description></item><item><title>Docs: connections</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/connections/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/connections/</guid><description>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/connections">connections服务&lt;/a>可以查看所有的连接。一个典型的页面如下：&lt;/p>
&lt;p>server_socket_count: 5&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CreatedTime&lt;/th>
&lt;th>RemoteSide&lt;/th>
&lt;th>SSL&lt;/th>
&lt;th>Protocol&lt;/th>
&lt;th>fd&lt;/th>
&lt;th>BytesIn/s&lt;/th>
&lt;th>In/s&lt;/th>
&lt;th>BytesOut/s&lt;/th>
&lt;th>Out/s&lt;/th>
&lt;th>BytesIn/m&lt;/th>
&lt;th>In/m&lt;/th>
&lt;th>BytesOut/m&lt;/th>
&lt;th>Out/m&lt;/th>
&lt;th>SocketId&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630840&lt;/td>
&lt;td>172.22.38.217:51379&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>19&lt;/td>
&lt;td>1300&lt;/td>
&lt;td>1&lt;/td>
&lt;td>269&lt;/td>
&lt;td>1&lt;/td>
&lt;td>68844&lt;/td>
&lt;td>53&lt;/td>
&lt;td>115860&lt;/td>
&lt;td>53&lt;/td>
&lt;td>257&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630857&lt;/td>
&lt;td>172.22.38.217:51380&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>20&lt;/td>
&lt;td>1308&lt;/td>
&lt;td>1&lt;/td>
&lt;td>5766&lt;/td>
&lt;td>1&lt;/td>
&lt;td>68884&lt;/td>
&lt;td>53&lt;/td>
&lt;td>129978&lt;/td>
&lt;td>53&lt;/td>
&lt;td>258&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:09.630880&lt;/td>
&lt;td>172.22.38.217:51381&lt;/td>
&lt;td>No&lt;/td>
&lt;td>http&lt;/td>
&lt;td>21&lt;/td>
&lt;td>1292&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1447&lt;/td>
&lt;td>1&lt;/td>
&lt;td>67672&lt;/td>
&lt;td>52&lt;/td>
&lt;td>143414&lt;/td>
&lt;td>52&lt;/td>
&lt;td>259&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:01.324587&lt;/td>
&lt;td>127.0.0.1:55385&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>15&lt;/td>
&lt;td>1480&lt;/td>
&lt;td>20&lt;/td>
&lt;td>880&lt;/td>
&lt;td>20&lt;/td>
&lt;td>88020&lt;/td>
&lt;td>1192&lt;/td>
&lt;td>52260&lt;/td>
&lt;td>1192&lt;/td>
&lt;td>512&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2015/09/21-21:32:01.325969&lt;/td>
&lt;td>127.0.0.1:55387&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>17&lt;/td>
&lt;td>4016&lt;/td>
&lt;td>40&lt;/td>
&lt;td>1554&lt;/td>
&lt;td>40&lt;/td>
&lt;td>238879&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>92660&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>1024&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>channel_socket_count: 1&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>CreatedTime&lt;/th>
&lt;th>RemoteSide&lt;/th>
&lt;th>SSL&lt;/th>
&lt;th>Protocol&lt;/th>
&lt;th>fd&lt;/th>
&lt;th>BytesIn/s&lt;/th>
&lt;th>In/s&lt;/th>
&lt;th>BytesOut/s&lt;/th>
&lt;th>Out/s&lt;/th>
&lt;th>BytesIn/m&lt;/th>
&lt;th>In/m&lt;/th>
&lt;th>BytesOut/m&lt;/th>
&lt;th>Out/m&lt;/th>
&lt;th>SocketId&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2015/09/21-21:32:01.325870&lt;/td>
&lt;td>127.0.0.1:8765&lt;/td>
&lt;td>No&lt;/td>
&lt;td>baidu_std&lt;/td>
&lt;td>16&lt;/td>
&lt;td>1554&lt;/td>
&lt;td>40&lt;/td>
&lt;td>4016&lt;/td>
&lt;td>40&lt;/td>
&lt;td>92660&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>238879&lt;/td>
&lt;td>2384&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>channel_short_socket_count: 0&lt;/p>
&lt;p>上述信息分为三段：&lt;/p>
&lt;ul>
&lt;li>第一段是server接受(accept)的连接。&lt;/li>
&lt;li>第二段是server与下游的单连接（使用brpc::Channel建立），fd为-1的是虚拟连接，对应第三段中所有相同RemoteSide的连接。&lt;/li>
&lt;li>第三段是server与下游的短连接或连接池(pooled connections)，这些连接从属于第二段中的相同RemoteSide的虚拟连接。&lt;/li>
&lt;/ul>
&lt;p>表格标题的含义：&lt;/p>
&lt;ul>
&lt;li>RemoteSide : 远端的ip和端口。&lt;/li>
&lt;li>SSL：是否使用SSL加密，若为Yes的话，一般是HTTPS连接。&lt;/li>
&lt;li>Protocol : 使用的协议，可能为baidu_std hulu_pbrpc sofa_pbrpc memcache http public_pbrpc nova_pbrpc nshead_server等。&lt;/li>
&lt;li>fd : file descriptor（文件描述符），可能为-1。&lt;/li>
&lt;li>BytesIn/s : 上一秒读入的字节数&lt;/li>
&lt;li>In/s : 上一秒读入的消息数（消息是对request和response的统称）&lt;/li>
&lt;li>BytesOut/s : 上一秒写出的字节数&lt;/li>
&lt;li>Out/s : 上一秒写出的消息数&lt;/li>
&lt;li>BytesIn/m: 上一分钟读入的字节数&lt;/li>
&lt;li>In/m: 上一分钟读入的消息数&lt;/li>
&lt;li>BytesOut/m: 上一分钟写出的字节数&lt;/li>
&lt;li>Out/m: 上一分钟写出的消息数&lt;/li>
&lt;li>SocketId ：内部id，用于debug，用户不用关心。&lt;/li>
&lt;/ul>
&lt;p>典型截图分别如下所示：&lt;/p>
&lt;p>单连接：&lt;img src="https://brpc.incubator.apache.org/images/docs/single_conn.png" alt="img">&lt;/p>
&lt;p>连接池：&lt;img src="https://brpc.incubator.apache.org/images/docs/pooled_conn.png" alt="img">&lt;/p>
&lt;p>短连接：&lt;img src="https://brpc.incubator.apache.org/images/docs/short_conn.png" alt="img">&lt;/p></description></item><item><title>Docs: flags</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/flags/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/flags/</guid><description>
&lt;p>brpc使用gflags管理配置。如果你的程序也使用gflags，那么你应该已经可以修改和brpc相关的flags，你可以浏览&lt;a href="http://brpc.baidu.com:8765/flags">flags服务&lt;/a>了解每个flag的具体功能。如果你的程序还没有使用gflags，我们建议你使用，原因如下：&lt;/p>
&lt;ul>
&lt;li>命令行和文件均可传入，前者方便做测试，后者适合线上运维。放在文件中的gflags可以reload。而configure只支持从文件读取配置。&lt;/li>
&lt;li>你可以在浏览器中查看brpc服务器中所有gflags，并对其动态修改（如果允许的话）。configure不可能做到这点。&lt;/li>
&lt;li>gflags分散在和其作用紧密关联的文件中，更好管理。而使用configure需要聚集到一个庞大的读取函数中。&lt;/li>
&lt;/ul>
&lt;h1 id="usage-of-gflags">Usage of gflags&lt;/h1>
&lt;p>gflags一般定义在需要它的源文件中。#include &amp;lt;gflags/gflags.h&amp;gt;后在全局scope加入DEFINE_&lt;em>&amp;lt;type&amp;gt;&lt;/em>(&lt;em>&amp;lt;name&amp;gt;&lt;/em>, &lt;em>&amp;lt;default-value&amp;gt;&lt;/em>, &lt;em>&amp;lt;description&amp;gt;&lt;/em>); 比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;gflags/gflags.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_bool&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">false&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Show log_id in hexadecimal&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;seconds between consecutive health-checkings&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般在main函数开头用ParseCommandLineFlags处理程序参数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">#include&lt;/span> &lt;span style="color:#8f5902;font-style:italic">&amp;lt;gflags/gflags.h&amp;gt;&lt;/span>&lt;span style="color:#8f5902;font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">argc&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">char&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">argv&lt;/span>&lt;span style="color:#000;font-weight:bold">[])&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">google&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">ParseCommandLineFlags&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">argc&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">argv&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">true&lt;/span>&lt;span style="color:#8f5902;font-style:italic">/*表示把识别的参数从argc/argv中删除*/&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果要从conf/gflags.conf中加载gflags，则可以加上参数-flagfile=conf/gflags.conf。如果希望默认（什么参数都不加）就从文件中读取，则可以在程序中直接给flagfile赋值，一般这么写&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">google&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">SetCommandLineOption&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;flagfile&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;conf/gflags.conf&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>程序启动时会检查conf/gflags.conf是否存在，如果不存在则会报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ ./my_program
conf/gflags.conf: No such file or directory
&lt;/code>&lt;/pre>&lt;p>更具体的使用指南请阅读&lt;a href="http://gflags.github.io/gflags/">官方文档&lt;/a>。&lt;/p>
&lt;h1 id="flagfile">flagfile&lt;/h1>
&lt;p>在命令行中参数和值之间可不加等号，而在flagfile中一定要加。比如&lt;code>./myapp -param 7&lt;/code>是ok的，但在&lt;code>./myapp -flagfile=./gflags.conf&lt;/code>对应的gflags.conf中一定要写成 &lt;strong>-param=7&lt;/strong> 或 &lt;strong>&amp;ndash;param=7&lt;/strong>，否则就不正确且不会报错。&lt;/p>
&lt;p>在命令行中字符串可用单引号或双引号包围，而在flagfile中不能加。比如&lt;code>./myapp -name=&amp;quot;tom&amp;quot;&lt;/code>或&lt;code>./myapp -name='tom'&lt;/code>都是ok的，但在&lt;code>./myapp -flagfile=./gflags.conf&lt;/code>对应的gflags.conf中一定要写成 &lt;strong>-name=tom&lt;/strong> 或 &lt;strong>&amp;ndash;name=tom&lt;/strong>，如果写成-name=&amp;ldquo;tom&amp;quot;的话，引号也会作为值的一部分。配置文件中的值可以有空格，比如gflags.conf中写成-name=value with spaces是ok的，参数name的值就是value with spaces，而在命令行中要用引号括起来。&lt;/p>
&lt;p>flagfile中参数可由单横线(如-foo)或双横线(如&amp;ndash;foo)打头，但不能以三横线或更多横线打头，否则的话是无效参数且不会报错!&lt;/p>
&lt;p>flagfile中以&lt;code>#开头的行被认为是注释。开头的空格和空白行都会被忽略。&lt;/code>&lt;/p>
&lt;p>flagfile中可以使用&lt;code>--flagfile包含另一个flagfile。&lt;/code>&lt;/p>
&lt;h1 id="change-gflag-on-the-fly">Change gflag on-the-fly&lt;/h1>
&lt;p>&lt;a href="http://brpc.baidu.com:8765/flags">flags服务&lt;/a>可以查看服务器进程中所有的gflags。修改过的flags会以红色高亮。“修改过”指的是修改这一行为，即使再改回默认值，仍然会显示为红色。&lt;/p>
&lt;p>/flags：列出所有的gflags&lt;/p>
&lt;p>/flags/NAME：查询名字为NAME的gflag&lt;/p>
&lt;p>/flags/NAME1,NAME2,NAME3：查询名字为NAME1或NAME2或NAME3的gflag&lt;/p>
&lt;p>/flags/foo*,b$r：查询名字与某一统配符匹配的gflag，注意用$代替?匹配单个字符，因为?在url中有特殊含义。&lt;/p>
&lt;p>访问/flags/NAME?setvalue=VALUE即可动态修改一个gflag的值，validator会被调用。&lt;/p>
&lt;p>为了防止误修改，需要动态修改的gflag必须有validator，显示此类gflag名字时有(R)后缀。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/reloadable_flags.png" alt="img">&lt;/p>
&lt;p>&lt;em>修改成功后会显示如下信息&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/flag_setvalue.png" alt="img">&lt;/p>
&lt;p>&lt;em>尝试修改不允许修改的gflag会显示如下错误信息&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/set_flag_reject.png" alt="img">&lt;/p>
&lt;p>&lt;em>设置一个不允许的值会显示如下错误（flag值不会变化）&lt;/em>：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/set_flag_invalid_value.png" alt="img">&lt;/p>
&lt;p>r31658之后支持可视化地修改，在浏览器上访问时将看到(R)下多了下划线：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/the_r_after_flag.png" alt="img">&lt;/p>
&lt;p>点击后在一个独立页面可视化地修改对应的flag：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/set_flag_with_form.png" alt="img">&lt;/p>
&lt;p>填入true后确定：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/set_flag_with_form_2.png" alt="img">&lt;/p>
&lt;p>返回/flags可以看到对应的flag已经被修改了：&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/set_flag_with_form_3.png" alt="img">&lt;/p>
&lt;p>关于重载gflags，重点关注：&lt;/p>
&lt;ul>
&lt;li>避免在一段代码中多次调用同一个gflag，应把该gflag的值保存下来并调用该值。因为gflag的值随时可能变化，而产生意想不到的结果。&lt;/li>
&lt;li>使用google::GetCommandLineOption()访问string类型的gflag，直接访问是线程不安全的。&lt;/li>
&lt;li>处理逻辑和副作用应放到validator里去。比如修改FLAGS_foo后得更新另一处的值，如果只是写在程序初始化的地方，而不是validator里，那么重载时这段逻辑就运行不到了。&lt;/li>
&lt;/ul>
&lt;p>如果你确认某个gflag不需要额外的线程同步和处理逻辑就可以重载，那么可以用如下方式为其注册一个总是返回true的validator：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_bool&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87">false&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Show log_id in hexadecimal&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">BRPC_VALIDATE_GFLAG&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">hex_log_id&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">PassValidate&lt;/span>&lt;span style="color:#8f5902;font-style:italic">/*always true*/&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个flag是单纯的开关，修改后不需要更新其他数据（没有处理逻辑），代码中前面看到true后面看到false也不会产生什么后果（不需要线程同步），所以我们让其默认可重载。&lt;/p>
&lt;p>对于int32和int64类型，有一个判断是否为正数的常用validator：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">DEFINE_int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;seconds between consecutive health-checkings&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">BRPC_VALIDATE_GFLAG&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">health_check_interval&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">brpc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">PositiveInteger&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上操作都可以在命令行中进行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ curl brpc.baidu.com:8765/flags/health_check_interval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name &lt;span style="color:#000;font-weight:bold">|&lt;/span> Value &lt;span style="color:#000;font-weight:bold">|&lt;/span> Description &lt;span style="color:#000;font-weight:bold">|&lt;/span> Defined At
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>health_check_interval &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>R&lt;span style="color:#ce5c00;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">3&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> seconds between consecutive health-checkings &lt;span style="color:#000;font-weight:bold">|&lt;/span> src/brpc/socket_map.cpp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>1.0.251.32399后增加了-immutable_flags，打开后所有的gflags将不能被动态修改。当一个服务对某个gflag值比较敏感且不希望在线上被误改，可打开这个开关。打开这个开关的同时也意味着你无法动态修改线上的配置，每次修改都要重启程序，对于还在调试阶段或待收敛阶段的程序不建议打开。&lt;/p></description></item><item><title>Docs: rpcz</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/rpcz/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/rpcz/</guid><description>
&lt;p>用户能通过/rpcz看到最近请求的详细信息，并可以插入注释（annotation），不同于tracing system（如&lt;a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf">dapper&lt;/a>）以全局视角看到整体系统的延时分布，rpcz更多是一个调试工具，虽然角色有所不同，但在brpc中rpcz和tracing的数据来源是一样的。当每秒请求数小于1万时，rpcz会记录所有的请求，超过1万时，rpcz会随机忽略一些请求把采样数控制在1万左右。rpcz可以淘汰时间窗口之前的数据，通过-span_keeping_seconds选项设置，默认1小时。&lt;a href="http://brpc.baidu.com:8765/rpcz">一个长期运行的例子&lt;/a>。&lt;/p>
&lt;p>关于开销：我们的实现完全规避了线程竞争，开销极小，在qps 30万的测试场景中，观察不到明显的性能变化，对大部分应用而言应该是“free”的。即使采集了几千万条请求，rpcz也不会增加很多内存，一般在50兆以内。rpcz会占用一些磁盘空间（就像日志一样），如果设定为存一个小时的数据，一般在几百兆左右。&lt;/p>
&lt;h2 id="开关方法">开关方法&lt;/h2>
&lt;p>默认不开启，加入&lt;a href="http://brpc.baidu.com:8765/flags/*rpcz*">-enable_rpcz&lt;/a>选项会在启动后开启。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Value&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Defined At&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>enable_rpcz (R)&lt;/td>
&lt;td>true (default:false)&lt;/td>
&lt;td>Turn on rpcz&lt;/td>
&lt;td>src/baidu/rpc/builtin/rpcz_service.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_hex_log_id (R)&lt;/td>
&lt;td>false&lt;/td>
&lt;td>Show log_id in hexadecimal&lt;/td>
&lt;td>src/baidu/rpc/builtin/rpcz_service.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_database_dir&lt;/td>
&lt;td>./rpc_data/rpcz&lt;/td>
&lt;td>For storing requests/contexts collected by rpcz.&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_keep_span_db&lt;/td>
&lt;td>false&lt;/td>
&lt;td>Don&amp;rsquo;t remove DB of rpcz at program&amp;rsquo;s exit&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>rpcz_keep_span_seconds (R)&lt;/td>
&lt;td>3600&lt;/td>
&lt;td>Keep spans for at most so many seconds&lt;/td>
&lt;td>src/baidu/rpc/span.cpp&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>若启动时未加-enable_rpcz，则可在启动后访问SERVER_URL/rpcz/enable动态开启rpcz，访问SERVER_URL/rpcz/disable则关闭，这两个链接等价于访问SERVER_URL/flags/enable_rpcz?setvalue=true和SERVER_URL/flags/enable_rpcz?setvalue=false。在r31010之后，rpc在html版本中增加了一个按钮可视化地开启和关闭。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/rpcz_4.png" alt="img">&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/rpcz_5.png" alt="img">&lt;/p>
&lt;p>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;h2 id="数据展现">数据展现&lt;/h2>
&lt;p>/rpcz展现的数据分为两层。&lt;/p>
&lt;h3 id="第一层">第一层&lt;/h3>
&lt;p>看到最新请求的概况，点击链接进入第二层。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/rpcz_6.png" alt="img">&lt;/p>
&lt;h3 id="第二层">第二层&lt;/h3>
&lt;p>看到某系列(trace)或某个请求(span)的详细信息。一般通过点击链接进入，也可以把trace=和span=作为query-string拼出链接&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/rpcz_7.png" alt="img">&lt;/p>
&lt;p>内容说明：&lt;/p>
&lt;ul>
&lt;li>时间分为了绝对时间（如2015/01/21-20:20:30.817392，小数点后精确到微秒）和前一个时间的差值（如. 19，代表19微秒)。&lt;/li>
&lt;li>trace=ID有点像“session id”，对应一个系统中完成一次对外服务牵涉到的所有服务，即上下游server都共用一个trace-id。span=ID对应一个server或client中一个请求的处理过程。trace-id和span-id在概率上唯一。&lt;/li>
&lt;li>第一层页面中的request=和response=后的是数据包的字节数，包括附件但不包括协议meta。第二层中request和response的字节数一般在括号里，比如&amp;quot;Responded(13)&amp;ldquo;中的13。&lt;/li>
&lt;li>点击链接可能会访问其他server上的rpcz，点浏览器后退一般会返回到之前的页面位置。&lt;/li>
&lt;li>I&amp;rsquo;m the last call, I&amp;rsquo;m about to &amp;hellip;都是用户的annotation。&lt;/li>
&lt;/ul>
&lt;h2 id="annotation">Annotation&lt;/h2>
&lt;p>只要你使用了brpc，就可以使用&lt;a href="https://github.com/brpc/brpc/blob/master/src/brpc/traceprintf.h">TRACEPRINTF&lt;/a>打印内容到事件流中，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">TRACEPRINTF&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hello rpcz %d&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">123&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这条annotation会按其发生时间插入到对应请求的rpcz中。从这个角度看，rpcz是请求级的日志。如果你用TRACEPRINTF打印了沿路的上下文，便可看到请求在每个阶段停留的时间，牵涉到的数据集和参数。这是个很有用的功能。&lt;/p></description></item><item><title>Docs: cpu profiler</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/cpu_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/cpu_profiler/</guid><description>
&lt;p>brpc可以分析程序中的热点函数。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;ol>
&lt;li>链接&lt;code>libtcmalloc_and_profiler.a&lt;/code>
&lt;ol>
&lt;li>这么写也开启了tcmalloc，不建议单独链接cpu profiler而不链接tcmalloc，可能越界访问导致&lt;a href="https://github.com/gperftools/gperftools/blob/master/README#L226">crash&lt;/a>.可能由于tcmalloc不及时归还内存，越界访问不会crash。&lt;/li>
&lt;li>如果tcmalloc使用frame pointer而不是libunwind回溯栈，请确保在CXXFLAGS或CFLAGS中加上&lt;code>-fno-omit-frame-pointer&lt;/code>，否则函数间的调用关系会丢失，最后产生的图片中都是彼此独立的函数方框。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>定义宏BRPC_ENABLE_CPU_PROFILER, 一般加入编译参数-DBRPC_ENABLE_CPU_PROFILER。&lt;/li>
&lt;li>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/li>
&lt;/ol>
&lt;p>注意要关闭Server端的认证，否则可能会看到这个：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/profile
Use of uninitialized value in substitution (s///) at tools/pprof line 2703.
http://localhost:9002/profile/symbol doesn&amp;#39;t exist
&lt;/code>&lt;/pre>&lt;p>server端可能会有这样的日志：&lt;/p>
&lt;pre tabindex="0">&lt;code>FATAL: 12-26 10:01:25: * 0 [src/brpc/policy/giano_authenticator.cpp:65][4294969345] Giano fails to verify credentical, 70003
WARNING: 12-26 10:01:25: * 0 [src/brpc/input_messenger.cpp:132][4294969345] Authentication failed, remote side(127.0.0.1:22989) of sockfd=5, close it
&lt;/code>&lt;/pre>&lt;h1 id="查看方法">查看方法&lt;/h1>
&lt;ol>
&lt;li>通过builtin service的 /hotspots/cpu 页面查看&lt;/li>
&lt;li>通过pprof 工具查看，如 tools/pprof &amp;ndash;text localhost:9002/pprof/profile&lt;/li>
&lt;/ol>
&lt;h1 id="控制采样频率">控制采样频率&lt;/h1>
&lt;p>启动前设置环境变量：export CPUPROFILE_FREQUENCY=xxx&lt;/p>
&lt;p>默认值为: 100&lt;/p>
&lt;h1 id="控制采样时间">控制采样时间&lt;/h1>
&lt;p>url加上?seconds=秒数，如/hotspots/cpu?seconds=5&lt;/p>
&lt;h1 id="图示">图示&lt;/h1>
&lt;p>下图是一次运行cpu profiler后的结果：&lt;/p>
&lt;ul>
&lt;li>左上角是总体信息，包括时间，程序名，总采样数等等。&lt;/li>
&lt;li>View框中可以选择查看之前运行过的profile结果，Diff框中可选择查看和之前的结果的变化量，重启后清空。&lt;/li>
&lt;li>代表函数调用的方框中的字段从上到下依次为：函数名，这个函数本身（除去所有子函数）占的采样数和比例，这个函数及调用的所有子函数累计的采样数和比例。采样数越大框越大。&lt;/li>
&lt;li>方框之间连线上的数字表示被采样到的上层函数对下层函数的调用数，数字越大线越粗。&lt;/li>
&lt;/ul>
&lt;p>热点分析一般开始于找到最大的框最粗的线考察其来源及去向。&lt;/p>
&lt;p>cpu profiler的原理是在定期被调用的SIGPROF handler中采样所在线程的栈，由于handler（在linux 2.6后）会被随机地摆放于活跃线程的栈上运行，cpu profiler在运行一段时间后能以很大的概率采集到所有活跃线程中的活跃函数，最后根据栈代表的函数调用关系汇总为调用图，并把地址转换成符号，这就是我们看到的结果图了。采集频率由环境变量CPUPROFILE_FREQUENCY控制，默认100，即每秒钟100次或每10ms一次。在实践中cpu profiler对原程序的影响不明显。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/echo_cpu_profiling.png" alt="img">&lt;/p>
&lt;p>在Linux下，你也可以使用&lt;a href="https://github.com/brpc/brpc/blob/master/tools/pprof">pprof&lt;/a>或gperftools中的pprof进行profiling。&lt;/p>
&lt;p>比如&lt;code>pprof --text localhost:9002 --seconds=5&lt;/code>的意思是统计运行在本机9002端口的server的cpu情况，时长5秒。一次运行的例子如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text 0.0.0.0:9002 --seconds=5
Gathering CPU profile from http://0.0.0.0:9002/pprof/profile?seconds=5 for 5 seconds to
/home/gejun/pprof/echo_server.1419501210.0.0.0.0
Be patient...
Wrote profile to /home/gejun/pprof/echo_server.1419501210.0.0.0.0
Removing funlockfile from all stack traces.
Total: 2946 samples
1161 39.4% 39.4% 1161 39.4% syscall
248 8.4% 47.8% 248 8.4% bthread::TaskControl::steal_task
227 7.7% 55.5% 227 7.7% writev
87 3.0% 58.5% 88 3.0% ::cpp_alloc
74 2.5% 61.0% 74 2.5% __read_nocancel
46 1.6% 62.6% 48 1.6% tc_delete
42 1.4% 64.0% 42 1.4% brpc::Socket::Address
41 1.4% 65.4% 41 1.4% epoll_wait
35 1.2% 66.6% 35 1.2% memcpy
33 1.1% 67.7% 33 1.1% __pthread_getspecific
33 1.1% 68.8% 33 1.1% brpc::Socket::Write
33 1.1% 69.9% 33 1.1% epoll_ctl
28 1.0% 70.9% 42 1.4% brpc::policy::ProcessRpcRequest
27 0.9% 71.8% 27 0.9% butil::IOBuf::_push_back_ref
27 0.9% 72.7% 27 0.9% bthread::TaskGroup::ending_sched
&lt;/code>&lt;/pre>&lt;p>省略–text进入交互模式，如下图所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof localhost:9002 --seconds=5
Gathering CPU profile from http://0.0.0.0:9002/pprof/profile?seconds=5 for 5 seconds to
/home/gejun/pprof/echo_server.1419501236.0.0.0.0
Be patient...
Wrote profile to /home/gejun/pprof/echo_server.1419501236.0.0.0.0
Removing funlockfile from all stack traces.
Welcome to pprof! For help, type &amp;#39;help&amp;#39;.
(pprof) top
Total: 2954 samples
1099 37.2% 37.2% 1099 37.2% syscall
253 8.6% 45.8% 253 8.6% bthread::TaskControl::steal_task
240 8.1% 53.9% 240 8.1% writev
90 3.0% 56.9% 90 3.0% ::cpp_alloc
67 2.3% 59.2% 67 2.3% __read_nocancel
47 1.6% 60.8% 47 1.6% butil::IOBuf::_push_back_ref
42 1.4% 62.2% 56 1.9% brpc::policy::ProcessRpcRequest
41 1.4% 63.6% 41 1.4% epoll_wait
38 1.3% 64.9% 38 1.3% epoll_ctl
37 1.3% 66.1% 37 1.3% memcpy
35 1.2% 67.3% 35 1.2% brpc::Socket::Address
&lt;/code>&lt;/pre>&lt;h1 id="macos的额外配置">MacOS的额外配置&lt;/h1>
&lt;p>在MacOS下，gperftools中的perl pprof脚本无法将函数地址转变成函数名，解决办法是：&lt;/p>
&lt;ol>
&lt;li>安装&lt;a href="https://github.com/google/pprof">standalone pprof&lt;/a>，并把下载的pprof二进制文件路径写入环境变量GOOGLE_PPROF_BINARY_PATH中&lt;/li>
&lt;li>安装llvm-symbolizer（将函数符号转化为函数名），直接用brew安装即可：&lt;code>brew install llvm&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="火焰图">火焰图&lt;/h1>
&lt;p>若需要结果以火焰图的方式展示，请下载并安装&lt;a href="https://github.com/brendangregg/FlameGraph">FlameGraph&lt;/a>工具，将环境变量FLAMEGRAPH_PL_PATH正确设置到本地的/path/to/flamegraph.pl后启动server即可。&lt;/p></description></item><item><title>Docs: heap profiler</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/heap_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/heap_profiler/</guid><description>
&lt;p>brpc可以分析内存是被哪些函数占据的。heap profiler的原理是每分配满一些内存就采样调用处的栈，“一些”由环境变量TCMALLOC_SAMPLE_PARAMETER控制，默认524288，即512K字节。根据栈表现出的函数调用关系汇总为我们看到的结果图。在实践中heap profiler对原程序的影响不明显。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>链接&lt;code>libtcmalloc_and_profiler.a&lt;/code>&lt;/p>
&lt;ol>
&lt;li>如果tcmalloc使用frame pointer而不是libunwind回溯栈，请确保在CXXFLAGS或CFLAGS中加上&lt;code>-fno-omit-frame-pointer&lt;/code>，否则函数间的调用关系会丢失，最后产生的图片中都是彼此独立的函数方框。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>在shell中&lt;code>export TCMALLOC_SAMPLE_PARAMETER=524288&lt;/code>。该变量指每分配这么多字节内存时做一次统计，默认为0，代表不开启内存统计。&lt;a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">官方文档&lt;/a>建议设置为524288。这个变量也可在运行前临时设置，如&lt;code>TCMALLOC_SAMPLE_PARAMETER=524288 ./server&lt;/code>。如果没有这个环境变量，可能会看到这样的结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/heap
Fetching /pprof/heap profile from http://localhost:9002/pprof/heap to
/home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap
Wrote profile to /home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap
/home/gejun/pprof/echo_server.1419559063.localhost.pprof.heap: header size &amp;gt;= 2**16
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>注意要关闭Server端的认证，否则可能会看到这个：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text localhost:9002/pprof/heap
Use of uninitialized value in substitution (s///) at tools/pprof line 2703.
http://localhost:9002/pprof/symbol doesn&amp;#39;t exist
&lt;/code>&lt;/pre>&lt;p>server端可能会有这样的日志：&lt;/p>
&lt;pre tabindex="0">&lt;code>FATAL: 12-26 10:01:25: * 0 [src/brpc/policy/giano_authenticator.cpp:65][4294969345] Giano fails to verify credentical, 70003
WARNING: 12-26 10:01:25: * 0 [src/brpc/input_messenger.cpp:132][4294969345] Authentication failed, remote side(127.0.0.1:22989) of sockfd=5, close it
&lt;/code>&lt;/pre>&lt;h1 id="图示">图示&lt;/h1>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/heap_profiler_1.png" alt="img">&lt;/p>
&lt;p>左上角是当前程序通过malloc分配的内存总量，顺着箭头上的数字可以看到内存来自哪些函数。&lt;/p>
&lt;p>点击左上角的text选择框可以查看文本格式的结果，有时候这种按分配量排序的形式更方便。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/heap_profiler_2.png" alt="img">&lt;/p>
&lt;p>左上角的两个选择框作用分别是：&lt;/p>
&lt;ul>
&lt;li>View：当前正在看的profile。选择&amp;lt;new profile&amp;gt;表示新建一个。新建完毕后，View选择框中会出现新profile，URL也会被修改为对应的地址。这意味着你可以通过粘贴URL分享结果，点击链接的人将看到和你一模一样的结果，而不是重做profiling的结果。你可以在框中选择之前的profile查看。历史profiie保留最近的32个，可通过&lt;a href="http://brpc.baidu.com:8765/flags/max_profiles_kept">&amp;ndash;max_profiles_kept&lt;/a>调整。&lt;/li>
&lt;li>Diff：和选择的profile做对比。&lt;none>表示什么都不选。如果你选择了之前的某个profile，那么将看到View框中的profile相比Diff框中profile的变化量。&lt;/li>
&lt;/ul>
&lt;p>下图演示了勾选Diff和Text的效果。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/heap_profiler_3.gif" alt="img">&lt;/p>
&lt;p>在Linux下，你也可以使用pprof脚本（tools/pprof）在命令行中查看文本格式结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tools/pprof --text db-rpc-dev00.db01:8765/pprof/heap
Fetching /pprof/heap profile from http://db-rpc-dev00.db01:8765/pprof/heap to
/home/gejun/pprof/play_server.1453216025.db-rpc-dev00.db01.pprof.heap
Wrote profile to /home/gejun/pprof/play_server.1453216025.db-rpc-dev00.db01.pprof.heap
Adjusting heap profiles for 1-in-524288 sampling rate
Heap version 2
Total: 38.9 MB
35.8 92.0% 92.0% 35.8 92.0% ::cpp_alloc
2.1 5.4% 97.4% 2.1 5.4% butil::FlatMap
0.5 1.3% 98.7% 0.5 1.3% butil::IOBuf::append
0.5 1.3% 100.0% 0.5 1.3% butil::IOBufAsZeroCopyOutputStream::Next
0.0 0.0% 100.0% 0.6 1.5% MallocExtension::GetHeapSample
0.0 0.0% 100.0% 0.5 1.3% ProfileHandler::Init
0.0 0.0% 100.0% 0.5 1.3% ProfileHandlerRegisterCallback
0.0 0.0% 100.0% 0.5 1.3% __do_global_ctors_aux
0.0 0.0% 100.0% 1.6 4.2% _end
0.0 0.0% 100.0% 0.5 1.3% _init
0.0 0.0% 100.0% 0.6 1.5% brpc::CloseIdleConnections
0.0 0.0% 100.0% 1.1 2.9% brpc::GlobalUpdate
0.0 0.0% 100.0% 0.6 1.5% brpc::PProfService::heap
0.0 0.0% 100.0% 1.9 4.9% brpc::Socket::Create
0.0 0.0% 100.0% 2.9 7.4% brpc::Socket::Write
0.0 0.0% 100.0% 3.8 9.7% brpc::Span::CreateServerSpan
0.0 0.0% 100.0% 1.4 3.5% brpc::SpanQueue::Push
0.0 0.0% 100.0% 1.9 4.8% butil::ObjectPool
0.0 0.0% 100.0% 0.8 2.0% butil::ResourcePool
0.0 0.0% 100.0% 1.0 2.6% butil::iobuf::tls_block
0.0 0.0% 100.0% 1.0 2.6% bthread::TimerThread::Bucket::schedule
0.0 0.0% 100.0% 1.6 4.1% bthread::get_stack
0.0 0.0% 100.0% 4.2 10.8% bthread_id_create
0.0 0.0% 100.0% 1.1 2.9% bvar::Variable::describe_series_exposed
0.0 0.0% 100.0% 1.0 2.6% bvar::detail::AgentGroup
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::Percentile::operator
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::PercentileSamples
0.0 0.0% 100.0% 0.5 1.3% bvar::detail::Sampler::schedule
0.0 0.0% 100.0% 6.5 16.8% leveldb::Arena::AllocateNewBlock
0.0 0.0% 100.0% 0.5 1.3% leveldb::VersionSet::LogAndApply
0.0 0.0% 100.0% 4.2 10.8% pthread_mutex_unlock
0.0 0.0% 100.0% 0.5 1.3% pthread_once
0.0 0.0% 100.0% 0.5 1.3% std::_Rb_tree
0.0 0.0% 100.0% 1.5 3.9% std::basic_string
0.0 0.0% 100.0% 3.5 9.0% std::string::_Rep::_S_create
&lt;/code>&lt;/pre>&lt;p>brpc还提供一个类似的growth profiler分析内存的分配去向（不考虑释放）。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/growth_profiler.png" alt="img">&lt;/p>
&lt;h1 id="macos的额外配置">MacOS的额外配置&lt;/h1>
&lt;ol>
&lt;li>安装&lt;a href="https://github.com/google/pprof">standalone pprof&lt;/a>，并把下载的pprof二进制文件路径写入环境变量GOOGLE_PPROF_BINARY_PATH中&lt;/li>
&lt;li>安装llvm-symbolizer（将函数符号转化为函数名），直接用brew安装即可：&lt;code>brew install llvm&lt;/code>&lt;/li>
&lt;/ol></description></item><item><title>Docs: contention profiler</title><link>https://brpc.incubator.apache.org/zh/docs/builtin-services/contention_profiler/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://brpc.incubator.apache.org/zh/docs/builtin-services/contention_profiler/</guid><description>
&lt;p>brpc可以分析花在等待锁上的时间及发生等待的函数。&lt;/p>
&lt;h1 id="开启方法">开启方法&lt;/h1>
&lt;p>按需开启。无需配置，不依赖tcmalloc，不需要链接frame pointer或libunwind。如果只是brpc client或没有使用brpc，看&lt;a href="../../client/dummy-server/">这里&lt;/a>。&lt;/p>
&lt;h1 id="图示">图示&lt;/h1>
&lt;p>当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为&lt;strong>contention&lt;/strong>。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条wait-free，耗时10-20ns的原子操作，非常快。而锁一旦发生竞争，一些线程就要陷入睡眠，再次醒来触发了OS的调度代码，代价至少为3-5us。所以让锁尽量无竞争，让所有线程“一起飞”是需要高性能的server的永恒话题。&lt;/p>
&lt;p>r31906后brpc支持contention profiler，可以分析在等待锁上花费了多少时间。等待过程中线程是睡着的不会占用CPU，所以contention profiler中的时间并不是cpu时间，也不会出现在&lt;a href="../cpu_profiler/">cpu profiler&lt;/a>中。cpu profiler可以抓到特别频繁的锁（以至于花费了很多cpu），但耗时真正巨大的临界区往往不是那么频繁，而无法被cpu profiler发现。**contention profiler和cpu profiler好似互补关系，前者分析等待时间（被动），后者分析忙碌时间。**还有一类由用户基于condition或sleep发起的主动等待时间，无需分析。&lt;/p>
&lt;p>目前contention profiler支持pthread_mutex_t（非递归）和bthread_mutex_t，开启后每秒最多采集1000个竞争锁，这个数字由参数-bvar_collector_expected_per_second控制（同时影响rpc_dump）。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Value&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Defined At&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>bvar_collector_expected_per_second&lt;/td>
&lt;td>1000&lt;/td>
&lt;td>Expected number of samples to be collected per second&lt;/td>
&lt;td>bvar/collector.cpp&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果一秒内竞争锁的次数Ｎ超过了1000，那么每把锁会有1000/N的概率被采集。在我们的各类测试场景中（qps在10万-60万不等）没有观察到被采集程序的性能有明显变化。&lt;/p>
&lt;p>我们通过实际例子来看下如何使用contention profiler，点击“contention”按钮（more左侧）后就会开启默认10秒的分析过程。下图是libraft中的一个示例程序的锁状况，这个程序是3个节点复制组的leader，qps在10-12万左右。左上角的&lt;strong>Total seconds: 2.449&lt;/strong>是采集时间内（10秒）在锁上花费的所有等待时间。注意是“等待”，无竞争的锁不会被采集也不会出现在下图中。顺着箭头往下走能看到每份时间来自哪些函数。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/raft_contention_1.png" alt="img">&lt;/p>
&lt;p>上图有点大，让我们放大一个局部看看。下图红框中的0.768是这个局部中最大的数字，它代表raft::LogManager::get_entry在等待涉及到bvar::detail::UniqueLockBase的函数上共等待了0.768秒（10秒内）。我们如果觉得这个时间不符合预期，就可以去排查代码。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/raft_contention_2.png" alt="img">&lt;/p>
&lt;p>点击上方的count选择框，可以查看锁的竞争次数。选择后左上角变为了&lt;strong>Total samples: 439026&lt;/strong>，代表采集时间内总共的锁竞争次数（估算）。图中箭头上的数字也相应地变为了次数，而不是时间。对比同一份结果的时间和次数，可以更深入地理解竞争状况。&lt;/p>
&lt;p>&lt;img src="https://brpc.incubator.apache.org/images/docs/raft_contention_3.png" alt="img">&lt;/p></description></item></channel></rss>