<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bRPC â€“ RPC in depth</title>
    <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/</link>
    <description>Recent content in RPC in depth on bRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="https://brpc.incubator.apache.org/docs/rpc-in-depth/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: New Protocol</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/new-protocol/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/new-protocol/</guid>
      <description>
        
        
        &lt;h1 id=&#34;multi-protocol-support-in-the-server-side&#34;&gt;Multi-protocol support in the server side&lt;/h1&gt;
&lt;p&gt;brpc server supports all protocols in the same port, and it makes deployment and maintenance more convenient in most of the time. Since the format of different protocols is very different, it is hard to support all protocols in the same port unambiguously. In consider of decoupling and extensibility, it is also hard to build a multiplexer for all protocols. Thus our way is to classify all protocols into three categories and try one by one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First-class protocol: Special characters are marked in front of the protocol data, for example, the data of protocol &lt;a href=&#34;https://github.com/apache/incubator-brpc/blob/master/docs/cn/baidu_std.md&#34;&gt;baidu_std&lt;/a&gt; and hulu_pbrpc begins with &amp;lsquo;PRPC&amp;rsquo; and &amp;lsquo;HULU&amp;rsquo; respectively. Parser just check first four characters to know whether the protocol is matched. This class of protocol is checked first and all these protocols can share one TCP connection.&lt;/li&gt;
&lt;li&gt;Second-class protocol: Some complex protocols without special marked characters can only be detected after several input data are parsed. Currently only HTTP is classified into this category.&lt;/li&gt;
&lt;li&gt;Third-class protocol: Special characters are in the middle of the protocol data, such as the magic number of nshead protocol is the 25th-28th characters. It is complex to handle this case because without reading first 28 bytes, we cannot determine whether the protocol is nshead. If it is tried before http, http messages less than 28 bytes may not be parsed, since the parser consider it as an incomplete nshead message.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Considering that there will be only one protocol in most connections, we record the result of last selection so that it will be tried first when further data comes. It reduces the overhead of matching protocols to nearly zero for long connections. Although the process of matching protocols will be run every time for short connections, the bottleneck of short connections is not in here and this method is still fast enough. If there are lots of new protocols added into brpc in the future, we may consider some heuristic methods to match protocols.&lt;/p&gt;
&lt;h1 id=&#34;multi-protocol-support-in-the-client-side&#34;&gt;Multi-protocol support in the client side&lt;/h1&gt;
&lt;p&gt;Unlike the server side that protocols must be dynamically determined based on the data on the connection, the client side as the originator, naturally know their own protocol format. As long as the protocol data is sent through connection pool or short connection, which means it has exclusive usage of that connection, then the protocol can have any complex (or bad) format. Since the client will record the protocol when sending the data, it will use that recorded protocol to parse the data without any matching overhead when responses come back. There is no magic number in some protocols like memcache, redis, it is hard to distinguish them in the server side, but it has no problem in the client side.&lt;/p&gt;
&lt;h1 id=&#34;support-new-protocols&#34;&gt;Support new protocols&lt;/h1&gt;
&lt;p&gt;brpc is designed to add new protocols at any time, just proceed as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The protocol that begins with nshead has unified support, just read &lt;a href=&#34;https://github.com/apache/incubator-brpc/blob/master/docs/cn/nshead_service.md&#34;&gt;this&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;add-protocoltype&#34;&gt;add ProtocolType&lt;/h2&gt;
&lt;p&gt;Add new protocol type in ProtocolType in &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/options.proto&#34;&gt;options.proto&lt;/a&gt;. If you need to add new protocol, please contact us to add it for you to make sure there is no conflict with protocols of others.&lt;/p&gt;
&lt;p&gt;Currently we support in ProtocolType(at the middle of 2018):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProtocolType&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_UNKNOWN&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_BAIDU_STD&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_STREAMING_RPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_HULU_PBRPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_SOFA_PBRPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_RTMP&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_HTTP&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_PUBLIC_PBRPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_NOVA_PBRPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_NSHEAD_CLIENT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// implemented in brpc-ub
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_NSHEAD&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_HADOOP_RPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_HADOOP_SERVER_RPC&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_MONGO&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;13&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// server side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_UBRPC_COMPACK&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;14&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_DIDX_CLIENT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;15&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;         &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_REDIS&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;               &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_MEMCACHE&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;17&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;            &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_ITP&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;18&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_NSHEAD_MCPACK&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;19&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_DISP_IDL&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;            &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_ERSDA_CLIENT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;21&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;        &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_UBRPC_MCPACK2&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;22&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;       &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Reserve special protocol for cds-agent, which depends on FIFO right now
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_CDS_AGENT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;23&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;           &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_ESP&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;24&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;                 &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Client side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_THRIFT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;              &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Server side only
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;implement-callbacks&#34;&gt;Implement Callbacks&lt;/h2&gt;
&lt;p&gt;All callbacks are defined in struct Protocol, which is defined in &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/protocol.h&#34;&gt;protocol.h&lt;/a&gt;. Among all these callbacks, &lt;code&gt;parse&lt;/code&gt; is a callback that must be implemented. Besides, &lt;code&gt;process_request&lt;/code&gt; must be implemented in the server side and &lt;code&gt;serialize_request&lt;/code&gt;, &lt;code&gt;pack_request&lt;/code&gt;, &lt;code&gt;process_response&lt;/code&gt; must be implemented in the client side.&lt;/p&gt;
&lt;p&gt;It is difficult to implement callbacks of the protocol. These codes are not like the codes that ordinary users use which has good prompts and protections. You have to figure it out how to handle similar code in other protocols and implement your own protocol, then send it to us to do code review.&lt;/p&gt;
&lt;h3 id=&#34;parse&#34;&gt;parse&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParseResult&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Parse&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;butil&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IOBuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;source&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Socket&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;socket&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;read_eof&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;arg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to cut messages from source. Client side and server side must share the same parse function. The returned message will be passed to &lt;code&gt;process_request&lt;/code&gt;(server side) or &lt;code&gt;process_response&lt;/code&gt;(client side).&lt;/p&gt;
&lt;p&gt;Argument: source is the binary content from remote side, socket is the corresponding connection, read_eof is true iff the connection is closed by remote, arg is a pointer to the corresponding server in server client and NULL in client side.&lt;/p&gt;
&lt;p&gt;ParseResult could be an error or a cut message, its possible value contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PARSE_ERROR_TRY_OTHERS: current protocol is not matched, the framework would try next protocol. The data in source cannot be comsumed.&lt;/li&gt;
&lt;li&gt;PARSE_ERROR_NOT_ENOUGH_DATA: the input data hasn&amp;rsquo;t violated the current protocol yet, but the whole message cannot be detected as well. When there is new data from connection, new data will be appended to source and parse function is called again. If we can determine that data fits current protocol, the content of source can also be transferred to the internal state of protocol. For example, if source doesn&amp;rsquo;t contain a whole http message, it will be consumed by http parser to avoid repeated parsing.&lt;/li&gt;
&lt;li&gt;PARSE_ERROR_TOO_BIG_DATA: message size is too big, the connection will be closed to protect server.&lt;/li&gt;
&lt;li&gt;PARSE_ERROR_NO_RESOURCE: internal error, such as resource allocation failure. Connections will be closed.&lt;/li&gt;
&lt;li&gt;PARSE_ERROR_ABSOLUTELY_WRONG: it is supposed to be some protocols(magic number is matched), but the format is not as expected. Connection will be closed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;serialize_request&#34;&gt;serialize_request&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SerializeRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;butil&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IOBuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;request_buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                                 &lt;span style=&#34;color:#000&#34;&gt;Controller&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;cntl&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                                 &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;google&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;protobuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Message&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;request&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to serialize request into request_buf that client must implement. It happens before a RPC call and will only be called once. Necessary information needed by some protocols(such as http) is contained in cntl. Return true if succeed, otherwise false.&lt;/p&gt;
&lt;h3 id=&#34;pack_request&#34;&gt;pack_request&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PackRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;butil&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IOBuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; 
                           &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;uint64_t&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;correlation_id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;google&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;protobuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;MethodDescriptor&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;Controller&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;controller&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;butil&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IOBuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;request_buf&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Authenticator&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;auth&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to pack request_buf into msg, which is called every time before sending messages to server(including retrying). When auth is not NULL, authentication information is also needed to be packed. Return 0 if succeed, otherwise -1.&lt;/p&gt;
&lt;h3 id=&#34;process_request&#34;&gt;process_request&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ProcessRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;InputMessageBase&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;msg_base&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to parse request messages in the server side that server must implement. It and parse() may run in different threads. Multiple process_request may run simultaneously. After the processing is done, msg_base-&amp;gt;Destroy() must be called. In order to prevent forgetting calling Destroy, consider using DestroyingPtr&amp;lt;&amp;gt;.&lt;/p&gt;
&lt;h3 id=&#34;process_response&#34;&gt;process_response&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ProcessResponse&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;InputMessageBase&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to parse message response in client side that client must implement. It and parse() may run in different threads. Multiple process_request may run simultaneously. After the processing is done, msg_base-&amp;gt;Destroy() must be called. In order to prevent forgetting calling Destroy, consider using DestroyingPtr&amp;lt;&amp;gt;.&lt;/p&gt;
&lt;h3 id=&#34;verify&#34;&gt;verify&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Verify&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;InputMessageBase&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;msg&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to authenticate connections, it is called when the first message is received. It is must be implemented by servers that need authentication, otherwise the function pointer can be NULL. Return true if succeed, otherwise false.&lt;/p&gt;
&lt;h3 id=&#34;parse_server_address&#34;&gt;parse_server_address&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ParseServerAddress&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;butil&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;EndPoint&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;server_addr_and_port&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function converts server_addr_and_port(an argument of Channel.Init) to butil::EndPoint, which is optional. Some protocols may differ in the expression and understanding of server addresses.&lt;/p&gt;
&lt;h3 id=&#34;get_method_name&#34;&gt;get_method_name&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;std&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;GetMethodName&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)(&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;google&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;protobuf&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;MethodDescriptor&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;method&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                                            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Controller&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This function is used to customize method name, which is optional.&lt;/p&gt;
&lt;h3 id=&#34;supported_connection_type&#34;&gt;supported_connection_type&lt;/h3&gt;
&lt;p&gt;Used to mark the supported connection method. If all connection methods are supported, this value should set to CONNECTION_TYPE_ALL. If connection pools and short connections are supported, this value should set to CONNECTION_TYPE_POOLED_AND_SHORT.&lt;/p&gt;
&lt;h3 id=&#34;name&#34;&gt;name&lt;/h3&gt;
&lt;p&gt;The name of the protocol, which appears in the various configurations and displays, should be as short as possible and must be a string constant.&lt;/p&gt;
&lt;h2 id=&#34;register-to-global&#34;&gt;Register to global&lt;/h2&gt;
&lt;p&gt;RegisterProtocol should be called to &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/global.cpp&#34;&gt;register implemented protocol&lt;/a&gt; to brpc, just like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Protocol&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;http_protocol&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParseHttpMessage&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;SerializeHttpRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;PackHttpRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;ProcessHttpRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ProcessHttpResponse&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;VerifyHttpRequest&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ParseHttpServerAddress&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;GetHttpMethodName&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#000&#34;&gt;CONNECTION_TYPE_POOLED_AND_SHORT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                           &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RegisterProtocol&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PROTOCOL_HTTP&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;http_protocol&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;exit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Atomic instructions</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/atomic-instructions/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/atomic-instructions/</guid>
      <description>
        
        
        &lt;p&gt;We know that locks are extensively used in multi-threaded programming to avoid &lt;a href=&#34;http://en.wikipedia.org/wiki/Race_condition&#34;&gt;race conditions&lt;/a&gt; when modifying shared data. When the lock becomes a bottleneck, we try to walk around it by using atomic instructions. But it is difficult to write correct code with atomic instructions in generally and it is even hard to understand race conditions, &lt;a href=&#34;https://en.wikipedia.org/wiki/ABA_problem&#34;&gt;ABA problems&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Memory_barrier&#34;&gt;memory fences&lt;/a&gt;. This article tries to introduce basics on atomic instructions(under &lt;a href=&#34;http://en.wikipedia.org/wiki/Symmetric_multiprocessing&#34;&gt;SMP&lt;/a&gt;). Since &lt;a href=&#34;http://en.cppreference.com/w/cpp/atomic/atomic&#34;&gt;Atomic instructions&lt;/a&gt; are formally introduced in C++11, we use the APIs directly.&lt;/p&gt;
&lt;p&gt;As the name implies, atomic instructions cannot be divided into more sub-instructions. For example, &lt;code&gt;x.fetch(n)&lt;/code&gt; atomically adds n to x, any internal state is not observable &lt;strong&gt;to software&lt;/strong&gt;. Common atomic instructions are listed below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Atomic Instructions(type of x is std::atomic&amp;lt;int&amp;gt;)&lt;/th&gt;
&lt;th&gt;Descriptions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x.load()&lt;/td&gt;
&lt;td&gt;return the value of x.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x.store(n)&lt;/td&gt;
&lt;td&gt;store n to x and return nothing.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x.exchange(n)&lt;/td&gt;
&lt;td&gt;set x to n and return the value just before the modification&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x.compare_exchange_strong(expected_ref, desired)&lt;/td&gt;
&lt;td&gt;If x is equal to expected_ref, set x to desired and return true. Otherwise write current x to expected_ref and return false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x.compare_exchange_weak(expected_ref, desired)&lt;/td&gt;
&lt;td&gt;may have &lt;a href=&#34;http://en.wikipedia.org/wiki/Spurious_wakeup&#34;&gt;spurious wakeup&lt;/a&gt; comparing to compare_exchange_strong&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x.fetch_add(n), x.fetch_sub(n)&lt;/td&gt;
&lt;td&gt;do x += n, x-= n atomically. Return the value just before the modification.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You can already use these instructions to count something atomically, such as counting number of operations from multiple threads. However two problems may arise:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The operation is not as fast as expected.&lt;/li&gt;
&lt;li&gt;Even if multi-threaded accesses to some resources are controlled by a few atomic instructions that seem to be correct, the program still has great chance to crash.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cacheline&#34;&gt;Cacheline&lt;/h1&gt;
&lt;p&gt;An atomic instruction is fast when there&amp;rsquo;s no contentions or it&amp;rsquo;s accessed only by one thread. &amp;ldquo;Contentions&amp;rdquo; happen when multiple threads access the same &lt;a href=&#34;https://en.wikipedia.org/wiki/CPU_cache#Cache_entries&#34;&gt;cacheline&lt;/a&gt;. Modern CPU extensively use caches and divide caches into multiple levels to get high performance with a low price. The Intel E5-2620 widely used in Baidu has 32K L1 dcache and icache, 256K L2 cache and 15M L3 cache. L1 and L2 cache is owned by each core, while L3 cache is shared by all cores. Although it is very fast for one core to write data into its own L1 cache(4 cycles, ~2ns), make the data in L1 cache seen by other cores is not, because cachelines touched by the data need to be synchronized to other cores. This process is atomic and transparent to software and no instructions can be interleaved between. Applications have to wait for the completion of &lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_coherence&#34;&gt;cache coherence&lt;/a&gt;, which takes much longer time than writing local cache. It involves a complicated hardware algorithm and makes atomic instructions slow under high contentions. A single fetch_add may take more than 700ns in E5-2620 when a few threads are highly contented on the instruction. Accesses to the memory frequently shared and modified by multiple threads are not fast generally. For example, even if a critical section looks small, the spinlock protecting it may still not perform well. The cause is that the instructions used in spinlock such as exchange, fetch_add etc, need to wait for latest cachelines. It&amp;rsquo;s not surprising to see that one or two instructions take several microseconds.&lt;/p&gt;
&lt;p&gt;In order to improve performance, we need to avoid frequently synchronizing cachelines, which not only affects performance of the atomic instruction itself, but also overall performance of the program. The most effective solution is straightforward: &lt;strong&gt;avoid sharing as much as possible&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A program relying on a global multiple-producer-multiple-consumer(MPMC) queue is hard to scale well on many CPU cores, because throughput of the queue is limited by delays of cache coherence, rather than number of cores. It would be better to use multiple SPMC or MPSC queues, or even SPSC queues instead, to avoid contentions from the very beginning.&lt;/li&gt;
&lt;li&gt;Another example is counters. If all threads modify a counter frequently, the performance will be poor because all cores are busy synchronizing the same cacheline. If the counter is only used for printing logs periodically or something low-priority like that, we can let each thread modify its own thread-local variables and combine all thread-local data before reading, yielding &lt;a href=&#34;../../bvar/bvar/&#34;&gt;much better performance&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A related programming trap is false sharing: Accesses to infrequently updated or even read-only variables are significantly slowed down because other variables in the same cacheline are frequently updated. Variables used in multi-threaded environment should be grouped by accessing frequencies or patterns, variables that are modified by that other threads frequently should be put into separated cachelines. To align a variable or struct by cacheline, &lt;code&gt;include &amp;lt;butil/macros.h&amp;gt;&lt;/code&gt; and tag it with macro &lt;code&gt;BAIDU_CACHELINE_ALIGNMENT&lt;/code&gt;, grep source code of brpc for examples.&lt;/p&gt;
&lt;h1 id=&#34;memory-fence&#34;&gt;Memory fence&lt;/h1&gt;
&lt;p&gt;Just atomic counting cannot synchronize accesses to resources, simple structures like &lt;a href=&#34;https://en.wikipedia.org/wiki/Spinlock&#34;&gt;spinlock&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Reference_counting&#34;&gt;reference counting&lt;/a&gt; that seem correct may crash as well. The key is &lt;strong&gt;instruction reordering&lt;/strong&gt;, which may change the order of read/write and cause instructions behind to be reordered to front if there are no dependencies. &lt;a href=&#34;http://preshing.com/20120625/memory-ordering-at-compile-time/&#34;&gt;Compiler&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Out-of-order_execution&#34;&gt;CPU&lt;/a&gt; both may reorder.&lt;/p&gt;
&lt;p&gt;The motivation is natural: CPU wants to fill each cycle with instructions and execute as many as possible instructions within given time. As said in above section, an instruction for loading memory may cost hundreds of nanoseconds due to cacheline synchronization. A efficient solution for synchronizing multiple cachelines is to move them simultaneously rather than one-by-one. Thus modifications to multiple variables by a thread may be visible to another thread in a different order. On the other hand, different threads need different data, synchronizing on-demand is reasonable and may also change order between cachelines.&lt;/p&gt;
&lt;p&gt;For example: the first variable plays the role of switch, controlling accesses to following variables. When these variables are synchronized to other CPU cores, new values may be visible in a different order, and the first variable may not be the first updated, which causes other threads to think that the following variables are still valid, which are actually not, causing undefined behavior. Check code snippet below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Thread 1
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// ready was initialized to false
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ready&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Thread2
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ready&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a human perspective, the code is correct because thread2 only accesses &lt;code&gt;p&lt;/code&gt; when &lt;code&gt;ready&lt;/code&gt; is true which means p is initialized according to the logic in thread1. But the code may not run as expected on multi-core machines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ready = true&lt;/code&gt; in thread1 may be reordered before &lt;code&gt;p.init()&lt;/code&gt; by compiler or CPU, making thread2 see uninitialized &lt;code&gt;p&lt;/code&gt; when  &lt;code&gt;ready&lt;/code&gt; is true. The same reordering may happen in thread2 as well. Some instructions in &lt;code&gt;p.bar()&lt;/code&gt; may be reordered before checking &lt;code&gt;ready&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Even if above reorderings do not happen, cachelines of &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; may be synchronized independently to the CPU core that thread2 runs, making thread2 see unitialized &lt;code&gt;p&lt;/code&gt; when &lt;code&gt;ready&lt;/code&gt; is true.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: On x86/x64, &lt;code&gt;load&lt;/code&gt; has acquire semantics and &lt;code&gt;store&lt;/code&gt; has release semantics by default, the code above may run correctly provided that reordering by compiler is turned off.&lt;/p&gt;
&lt;p&gt;With this simple example, you may get a glimpse of the complexity of atomic instructions. In order to solve the reordering issue, CPU and compiler offer &lt;a href=&#34;http://en.wikipedia.org/wiki/Memory_barrier&#34;&gt;memory fences&lt;/a&gt; to let programmers decide the visibility order between instructions. boost and C++11 conclude memory fence into following types:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;memory order&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_relaxed&lt;/td&gt;
&lt;td&gt;there are no synchronization or ordering constraints imposed on other reads or writes, only this operation&amp;rsquo;s atomicity is guaranteed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_consume&lt;/td&gt;
&lt;td&gt;no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_acquire&lt;/td&gt;
&lt;td&gt;no reads or writes in the current thread can be reordered before this load.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_release&lt;/td&gt;
&lt;td&gt;no reads or writes in the current thread can be reordered after this store.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_acq_rel&lt;/td&gt;
&lt;td&gt;No memory reads or writes in the current thread can be reordered before or after this store.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_order_seq_cst&lt;/td&gt;
&lt;td&gt;Any operation with this memory order is both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Above example can be modified as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Thread1
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// ready was initialized to false
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;init&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;ready&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;store&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;std&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;memory_order_release&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Thread2
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ready&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;load&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;std&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;memory_order_acquire&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The acquire fence in thread2 matches the release fence in thread1, making thread2 see all memory operations before the release fence in thread1 when thread2 sees &lt;code&gt;ready&lt;/code&gt; being set to true.&lt;/p&gt;
&lt;p&gt;Note that memory fence does not guarantee visibility. Even if thread2 reads &lt;code&gt;ready&lt;/code&gt; just after thread1 sets it to true, thread2 is not guaranteed to see the new value, because cache synchronization takes time. Memory fence guarantees ordering between visibilities: &amp;ldquo;If I see the new value of a, I should see the new value of b as well&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;A related problem: How to know whether a value is updated or not? Two cases in generally:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The value is special. In above example, &lt;code&gt;ready=true&lt;/code&gt; is a special value. Once &lt;code&gt;ready&lt;/code&gt; is true, &lt;code&gt;p&lt;/code&gt; is ready. Reading special values or not both mean something.&lt;/li&gt;
&lt;li&gt;Increasing-only values. Some situations do not have special values, we can use instructions like &lt;code&gt;fetch_add&lt;/code&gt; to increase variables. As long as the value range is large enough, new values are different from old ones for a long period of time, so that we can distinguish them from each other.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More examples can be found in &lt;a href=&#34;http://www.boost.org/doc/libs/1_56_0/doc/html/atomic/usage_examples.html&#34;&gt;boost.atomic&lt;/a&gt;. Official descriptions of atomics can be found &lt;a href=&#34;http://en.cppreference.com/w/cpp/atomic/atomic&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;wait-free--lock-free&#34;&gt;wait-free &amp;amp; lock-free&lt;/h1&gt;
&lt;p&gt;Atomic instructions provide two important properties: &lt;a href=&#34;http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom&#34;&gt;wait-free&lt;/a&gt; and &lt;a href=&#34;http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&#34;&gt;lock-free&lt;/a&gt;. Wait-free means no matter how OS schedules, all threads are doing useful jobs; lock-free, which is weaker than wait-free, means no matter how OS schedules, at least one thread is doing useful jobs. If locks are used, the thread holding the lock might be paused by OS, in which case all threads trying to hold the lock are blocked. So code using locks are neither lock-free nor wait-free. To make tasks done within given time, critical paths in real-time OS is at least lock-free. Miscellaneous online services inside Baidu also pose serious restrictions on running time. If the critical path in brpc is wait-free or lock-free, many services are benefited from better and stable QoS. Actually, both read(in the sense of even dispatching) and write in brpc are wait-free, check &lt;a href=&#34;../io&#34;&gt;IO&lt;/a&gt; for details.&lt;/p&gt;
&lt;p&gt;Note that it is common to think that wait-free or lock-free algorithms are faster, which may not be true, because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;More complex race conditions and ABA problems must be handled in lock-free and wait-free algorithms, which means the code is often much more complicated than the one using locks. More code, more running time.&lt;/li&gt;
&lt;li&gt;Mutex solves contentions by backoff, which means that when contention happens, another branch is entered to avoid the contention temporarily. Threads failed to lock a mutex are put into sleep, making the thread holding the mutex complete the task or even follow-up tasks exclusively, which may increase the overall throughput.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Low performance caused by mutex is either because of too large critical sections (which limit the concurrency), or too heavy contentions (overhead of context switches becomes dominating). The real value of lock-free/wait-free algorithms is that they guarantee progress of the system, rather than absolutely high performance. Of course lock-free/wait-free algorithms perform better in some situations: if an algorithm is implemented by just one or two atomic instructions, it&amp;rsquo;s probably faster than the one using mutex which needs more atomic instructions in total.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: IO</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/io/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/io/</guid>
      <description>
        
        
        &lt;p&gt;There are three mechanisms to operate IO in general:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blocking IO: once an IO operation is issued, the calling thread is blocked until the IO ends, which is a kind of synchronous IO, such as default actions of posix &lt;a href=&#34;http://linux.die.net/man/2/read&#34;&gt;read&lt;/a&gt; and &lt;a href=&#34;http://linux.die.net/man/2/write&#34;&gt;write&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Non-blocking IO: If there is nothing to read or too much to write, APIs that would block return immediately with an error code. Non-blocking IO is often used with IO multiplexing(&lt;a href=&#34;http://linux.die.net/man/2/poll&#34;&gt;poll&lt;/a&gt;, &lt;a href=&#34;http://linux.die.net/man/2/select&#34;&gt;select&lt;/a&gt;, &lt;a href=&#34;http://linux.die.net/man/4/epoll&#34;&gt;epoll&lt;/a&gt; in Linux or &lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&#34;&gt;kqueue&lt;/a&gt; in BSD).&lt;/li&gt;
&lt;li&gt;Asynchronous IO: Start a read or write operation with a callback, which will be called when the IO is done, such as &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684342(v=vs.85).aspx&#34;&gt;OVERLAPPED&lt;/a&gt; + &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198(v=vs.85).aspx&#34;&gt;IOCP&lt;/a&gt; in Windows. Native AIO in Linux only supports files.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non-blocking IO is usually used for increasing IO concurrency in Linux. When the IO concurrency is low, non-blocking IO is not necessarily more efficient than blocking IO, which is handled completely by the kernel. System calls like read/write are highly optimized and probably more efficient. But when IO concurrency increases, the drawback of blocking-one-thread in blocking IO arises: the kernel keeps switching between threads to do effective jobs, and a CPU core may only do a little bit of work before being replaced by another thread, causing CPU cache not fully utilized. In addition a large number of threads decrease performance of code dependent on thread-local variables, such as tcmalloc. Once malloc slows down, the overall performance of the program decreases as well. As a contrast, non-blocking IO is typically composed with a relatively small number of event dispatching threads and worker threads(running user code), which are reused by different tasks (in another word, part of scheduling work is moved to userland). Event dispatchers and workers run on different CPU cores simultaneously without frequent switches in the kernel. There&amp;rsquo;s no need to have many threads, so the use of thread-local variables is also more adequate. All these factors make non-blocking IO faster than blocking IO. But non-blocking IO also has its own problems, one of which is more system calls, such as &lt;a href=&#34;http://man7.org/linux/man-pages/man2/epoll_ctl.2.html&#34;&gt;epoll_ctl&lt;/a&gt;. Since epoll is implemented as a red-black tree, epoll_ctl is not a very fast operation, especially in multi-threaded environments. Implementations heavily dependent on epoll_ctl is often confronted with multi-core scalability issues. Non-blocking IO also has to solve a lot of multi-threaded problems, producing more complex code than blocking IO.&lt;/p&gt;
&lt;h1 id=&#34;receiving-messages&#34;&gt;Receiving messages&lt;/h1&gt;
&lt;p&gt;A message is a bounded binary data read from a connection, which may be a request from upstream clients or a response from downstream servers. brpc uses one or several &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/event_dispatcher.cpp&#34;&gt;EventDispatcher&lt;/a&gt;(referred to as EDISP) to wait for events from file descriptors. Unlike the common &amp;ldquo;IO threads&amp;rdquo;, EDISP is not responsible for reading or writing. The problem of IO threads is that one thread can only read one fd at a given time, other reads may be delayed when many fds in one IO thread are busy. Multi-tenancy, complicated load balancing and &lt;a href=&#34;../../client/streaming-rpc/&#34;&gt;Streaming RPC&lt;/a&gt; worsen the problem. Under high workloads, regular long delays on one fd may slow down all fds in the IO thread, causing more long tails.&lt;/p&gt;
&lt;p&gt;Because of a &lt;a href=&#34;https://patchwork.kernel.org/patch/1970231/&#34;&gt;bug&lt;/a&gt; of epoll (at the time of developing brpc) and overhead of epoll_ctl, edge triggered mode is used in EDISP. After receiving an event, an atomic variable associated with the fd is added by one atomically. If the variable is zero before addition, a bthread is started to handle the data from the fd. The pthread worker in which EDISP runs is yielded to the newly created bthread to make it start reading ASAP and have a better cache locality. The bthread in which EDISP runs will be stolen to another pthread and keep running, this mechanism is work stealing used in bthreads. To understand exactly how that atomic variable works, you can read &lt;a href=&#34;../atomic-instructions/&#34;&gt;atomic instructions&lt;/a&gt; first, then check &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/socket.cpp&#34;&gt;Socket::StartInputEvent&lt;/a&gt;. These methods make contentions on dispatching events of one fd &lt;a href=&#34;http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom&#34;&gt;wait-free&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/input_messenger.h&#34;&gt;InputMessenger&lt;/a&gt; cuts messages and uses customizable callbacks to handle different format of data. &lt;code&gt;Parse&lt;/code&gt; callback cuts messages from binary data and has relatively stable running time; &lt;code&gt;Process&lt;/code&gt; parses messages further(such as parsing by protobuf) and calls users&#39; callbacks, which vary in running time. If n(n &amp;gt; 1) messages are read from the fd, InputMessenger launches n-1 bthreads to handle first n-1 messages respectively, and processes the last message in-place. InputMessenger tries protocols one by one. Since one connections often has only one type of messages, InputMessenger remembers current protocol to avoid trying for protocols next time.&lt;/p&gt;
&lt;p&gt;It can be seen that messages from different fds or even same fd are processed concurrently in brpc, which makes brpc good at handling large messages and reducing long tails on processing messages from different sources under high workloads.&lt;/p&gt;
&lt;h1 id=&#34;sending-messages&#34;&gt;Sending Messages&lt;/h1&gt;
&lt;p&gt;A message is a bounded binary data written to a connection, which may be a response to upstream clients or a request to downstream servers. Multiple threads may send messages to a fd at the same time, however writing to a fd is non-atomic, so how to queue writes from different thread efficiently is a key technique. brpc uses a special wait-free MPSC list to solve the issue. All data ready to write is put into a node of a singly-linked list, whose next pointer points to a special value(&lt;code&gt;Socket::WriteRequest::UNCONNECTED&lt;/code&gt;). When a thread wants to write out some data, it tries to atomically exchange the node with the list head(Socket::_write_head) first. If the head before exchange is empty, the caller gets the right to write and writes out the data in-place once. Otherwise there must be another thread writing. The caller points the next pointer to the head returned to make the linked list connected. The thread that is writing will see the new head later and write new data.&lt;/p&gt;
&lt;p&gt;This method makes the writing contentions wait-free. Although the thread that gets the right to write is not wait-free nor lock-free in principle and may be blocked by a node that is still UNCONNECTED(the thread issuing write is swapped out by OS just after atomic exchange and before setting the next pointer, within execution time of just one instruction), the blocking rarely happens in practice. In current implementations, if the data cannot be written fully in one call, a KeepWrite bthread is created to write the remaining data. This mechanism is pretty complicated and the principle is depicted below. Read &lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/socket.cpp&#34;&gt;socket.cpp&lt;/a&gt; for more details.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/write.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;Since writes in brpc always complete within short time, the calling thread can handle new tasks more quickly and background KeepWrite threads also get more tasks to write in one batch, forming pipelines and increasing the efficiency of IO at high throughputs.&lt;/p&gt;
&lt;h1 id=&#34;socket&#34;&gt;Socket&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/socket.h&#34;&gt;Socket&lt;/a&gt; contains data structures related to fd and is one of the most complex structure in brpc. The unique feature of this structure is that it uses 64-bit SocketId to refer to a Socket object to facilitate usages of fd in multi-threaded environments. Commonly used methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create: create a Socket and return its SocketId.&lt;/li&gt;
&lt;li&gt;Address: retrieve Socket from an id, and wrap it into a unique_ptr(SocketUniquePtr) that will be automatically released. When Socket is set failed, the pointer returned is empty. As long as Address returns a non-null pointer, the contents are guaranteed to not change until the pointer is destructed. This function is wait-free.&lt;/li&gt;
&lt;li&gt;SetFailed: Mark a Socket as failed and Address() on corresponding SocketId will return empty pointer (until health checking resumes the socket). Sockets are recycled when no one is referencing it anymore. This function is lock-free.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can see that, Socket is similar to &lt;a href=&#34;http://en.cppreference.com/w/cpp/memory/shared_ptr&#34;&gt;shared_ptr&lt;/a&gt; in the sense of referential counting and SocketId is similar to &lt;a href=&#34;http://en.cppreference.com/w/cpp/memory/weak_ptr&#34;&gt;weak_ptr&lt;/a&gt;. The unique &lt;code&gt;SetFailed&lt;/code&gt; prevents Socket from being addressed so that the reference count can hit zero finally. Simply using shared_ptr/weak_ptr cannot guarantee this. For example, when a server needs to quit when requests are still coming in frequently, the reference count of Socket may not hit zero and the server is unable to stop quickly. What&#39; more, weak_ptr cannot be directly put into epoll data, but SocketId can. These factors lead to design of Socket which is stable and rarely changed since 2014.&lt;/p&gt;
&lt;p&gt;Using SocketUniquePtr or SocketId depends on if a strong reference is needed. For example, Controller is used thoroughly inside RPC and has a lot of interactions with Socket, it uses SocketUniquePtr. Epoll notifies events on fds and events of a recycled socket can be ignored, so epoll uses SocketId.&lt;/p&gt;
&lt;p&gt;As long as SocketUniquePtr is valid, the Socket enclosed will not be changed so that users have no need to care about race conditions and ABA problems, being safer to operate the shared socket. This method also circumvents implicit referential counting and makes ownership of memory more clear, producing better-quality programs. brpc uses SocketUniquePtr and SocketId a lot to simplify related issues.&lt;/p&gt;
&lt;p&gt;In fact, Socket manages not only the native fd but also other resources, such as SubChannel in SelectiveChannel is also managed by Socket, making SelectiveChannel choose a SubChannel just like a normal channel choosing a downstream server. The faked Socket even implements health checking. Streaming RPC also uses Socket to reuse the code on wait-free write.&lt;/p&gt;
&lt;h1 id=&#34;the-full-picture&#34;&gt;The full picture&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/rpc_flow.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Threading Overview</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/threading-overview/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/threading-overview/</guid>
      <description>
        
        
        &lt;h1 id=&#34;common-threading-models&#34;&gt;Common threading models&lt;/h1&gt;
&lt;h2 id=&#34;connections-own-threads-or-processes-exclusively&#34;&gt;Connections own threads or processes exclusively&lt;/h2&gt;
&lt;p&gt;In this model, a thread/process handles all messages from a connection and does not quit or do other jobs before the connection is closed. When number of connections increases, resources occupied by threads/processes and costs of context switches becomes more and more overwhelming, making servers perform poorly. This situation is summarized as the &lt;a href=&#34;http://en.wikipedia.org/wiki/C10k_problem&#34;&gt;C10K&lt;/a&gt; problem, which was common in early web servers but rarely present today.&lt;/p&gt;
&lt;h2 id=&#34;single-threaded-reactorhttpenwikipediaorgwikireactor_pattern&#34;&gt;Single-threaded &lt;a href=&#34;http://en.wikipedia.org/wiki/Reactor_pattern&#34;&gt;reactor&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Event-loop libraries such as &lt;a href=&#34;http://libevent.org/&#34;&gt;libevent&lt;/a&gt;, &lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34;&gt;libev&lt;/a&gt; are typical examples. There&amp;rsquo;s usually an event dispatcher in this model responsible for waiting on different kinds of events and calling the corresponding event handler &lt;strong&gt;in-place&lt;/strong&gt; when an event occurs. After all handlers(that need to be called) are called, the dispatcher waits for more events again, which forms a &amp;ldquo;loop&amp;rdquo;. Essentially this model multiplexes(interleaves) code written in different handlers into a system thread. One event-loop can only utilize one core, so this kind of program is either IO-bound or each handler runs within short and deterministic time(such as http servers), otherwise one callback taking long time blocks the whole program and causes high delays. In practice this kind of program is not suitable for involving many developers, because just one person adding inappropriate blocking code may significantly slow down reactivities of all other code. Since event handlers don&amp;rsquo;t run simultaneously, race conditions between callbacks are relatively simple and in some scenarios locks are not needed. These programs are often scaled by deploying more processes.&lt;/p&gt;
&lt;p&gt;How single-threaded reactors work and the problems related are demonstrated below: (The Chinese characters in red: &amp;ldquo;Uncontrollable! unless the service is specialized&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/threading_overview_1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;n1-threading-library&#34;&gt;N:1 threading library&lt;/h2&gt;
&lt;p&gt;Also known as &lt;a href=&#34;http://en.wikipedia.org/wiki/Fiber_(computer_science)&#34;&gt;Fiber&lt;/a&gt;. Typical examples are &lt;a href=&#34;http://www.gnu.org/software/pth/pth-manual.html&#34;&gt;GNU Pth&lt;/a&gt;, &lt;a href=&#34;http://state-threads.sourceforge.net/index.html&#34;&gt;StateThreads&lt;/a&gt;. This model maps N user threads into a single system thread, in which only one user thread runs at the same time and the running user thread does not switch to other user threads until a blocking primitive is called (cooperative). N:1 threading libraries are equal to single-threaded reactors on capabilities, except that callbacks are replaced by contexts (stacks, registers, signals) and running callbacks becomes jumping to contexts. Similar to event-loop libraries, a N:1 threading library cannot utilize multiple CPU cores, thus only suitable for specialized applications. However a single system thread is more friendly to CPU caches, with removal of the support for signal masks, context switches between user threads can be done very fast(100 ~ 200ns). N:1 threading libraries perform as well as event-loop libraries and are also scaled by deploying more processes in general.&lt;/p&gt;
&lt;h2 id=&#34;multi-threaded-reactor&#34;&gt;Multi-threaded reactor&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.boost.org/doc/libs/1_56_0/doc/html/boost_asio.html&#34;&gt;boost::asio&lt;/a&gt; is a typical example. One or several threads run event dispatchers respectively. When an event occurs, the event handler is queued into a worker thread to run. This model is extensible from single-threaded reactor intuitively and able to make use of multiple CPU cores. Since sharing memory addresses makes interactions between threads much cheaper, the worker threads are able to balance loads between each other frequently, as a contrast multiple single-threaded reactors basically depend on the front-end servers to distribute traffic. A well-implemented multi-threaded reactor is likely to utilize CPU cores more evenly than multiple single-threaded reactors on the same machine. However, due to &lt;a href=&#34;../atomic-instructions/#cacheline&#34;&gt;cache coherence&lt;/a&gt;, multi-threaded reactors are unlikely to achieve linear scalability on CPU cores. In particular scenarios, a badly implemented multi-threaded reactor running on 24 cores is even slower than a well-tuned single-threaded reactor. Because a multi-threaded reactor has multiple worker threads, one blocking event handler may not delay other handlers. As a result, event handlers are not required to be non-blocking unless all worker threads are blocked, in which case the overall progress is affected. In fact, most RPC frameworks are implemented in this model with event handlers that may block, such as synchronously waiting for RPCs to downstream servers.&lt;/p&gt;
&lt;p&gt;How multi-threaded reactors work and problems related are demonstrated below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/threading_overview_2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;mn-threading-library&#34;&gt;M:N threading library&lt;/h2&gt;
&lt;p&gt;This model maps M user threads into N system threads. A M:N threading library is able to decide when and where to run a piece of code and when to end the execution, which is more flexible at scheduling compared to multi-threaded reactors. But full-featured M:N threading libraries are difficult to implement and remaining as active research topics. The M:N threading library that we&amp;rsquo;re talking about is specialized for building online services, in which case, some of the requirements can be simplified, namely no (complete) preemptions and priorities. M:N threading libraries can be implemented either in userland or OS kernel. New programming languages prefer implementations in userland, such as GHC thread and goroutine, which is capable of adding brand-new keywords and intercepting related APIs on threading. Implementation in existing languages often have to modify the OS kernel, such as &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85).aspx&#34;&gt;Windows UMS&lt;/a&gt; and google SwicthTo(which is 1:1, however M:N effects can be achieved based on it). Compared to N:1 threading libraries, usages of M:N threading libraries are more similar to system threads, which need locks or message passings to ensure thread safety.&lt;/p&gt;
&lt;h1 id=&#34;issues&#34;&gt;Issues&lt;/h1&gt;
&lt;h2 id=&#34;multi-core-scalability&#34;&gt;Multi-core scalability&lt;/h2&gt;
&lt;p&gt;Ideally capabilities of the reactor model are maximized when all source code is programmed in event-driven manner, but in reality because of the difficulties and maintainability, users are likely to mix usages: synchronous IO is often issued in callbacks, blocking worker threads from processing other requests. A request often goes through dozens of services, making worker threads spend a lot of time waiting for responses from downstream servers. Users have to launch hundreds of threads to maintain enough throughput, which imposes intensive pressure on scheduling and lowers efficiencies of TLS related code. Tasks are often pushed into a queue protected with a global mutex and condition, which performs poorly when many threads are contending for it. A better approach is to deploy more task queues and adjust the scheduling algorithm to reduce global contentions. Namely each system thread has its own runqueue, and one or more schedulers dispatch user threads to different runqueues. Each system thread runs user threads from its own runqueue before considering other runqueues, which is more complicated but more scalable than the global mutex+condition solution. This model is also easier to support NUMA.&lt;/p&gt;
&lt;p&gt;When an event dispatcher passes a task to a worker thread, the user code probably jumps from one CPU core to another, which may need to wait for synchronizations of relevant cachelines, which is not very fast. It would be better that the worker is able to run directly on the CPU core where the event dispatcher runs, since at most of the time, priority of running the worker ASAP is higher than getting new events from the dispatcher. Similarly, it&amp;rsquo;s better to wake up the user thread blocking on RPC on the same CPU core where the response is received.&lt;/p&gt;
&lt;h2 id=&#34;asynchronous-programming&#34;&gt;Asynchronous programming&lt;/h2&gt;
&lt;p&gt;Flow controls in asynchronous programming are even difficult for experts. Any suspending operation such as sleeping for a while or waiting for something to finish, implies that users have to save states explicitly and restore states in callbacks. Asynchronous code is often written as state machines. A few suspensions are troublesome, but still handleable. The problem is that once the suspension occurs inside a condition, loop or sub-function, it&amp;rsquo;s almost impossible to write such a state machine being understood and maintained by many people, although the scenario is quite common in distributed systems where a node often needs to interact with multiple nodes simultaneously. In addition, if the wakeup can be triggered by more than one events (such as either fd has data or timeout is reached), the suspension and resuming are prone to race conditions, which require good multi-threaded programming skills to solve. Syntactic sugars(such as lambda) just make coding less troublesome rather than reducing difficulty.&lt;/p&gt;
&lt;p&gt;Shared pointers are common in asynchronous programming, which seems convenient, but also makes ownerships of memory elusive. If the memory is leaked, it&amp;rsquo;s difficult to locate the code that forgot to release; if segment fault happens, where the double-free occurs is also unknown. Code with a lot of referential countings is hard to remain good-quality and may waste a lot of time on debugging memory related issues. If references are even counted manually, keeping quality of the code is harder and the maintainers are less willing to modify the code. &lt;a href=&#34;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&#34;&gt;RAII&lt;/a&gt; cannot be used in many scenarios in asynchronous programming, sometimes resources need to be locked before a callback and unlocked inside the callback, which is very error-prone in practice.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Load Balancing</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/load-balancing/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/load-balancing/</guid>
      <description>
        
        
        &lt;p&gt;ä¸Šæ¸¸ä¸€èˆ¬é€šè¿‡å‘½åæœåŠ¡å‘çŽ°æ‰€æœ‰çš„ä¸‹æ¸¸èŠ‚ç‚¹ï¼Œå¹¶é€šè¿‡å¤šç§è´Ÿè½½å‡è¡¡æ–¹æ³•æŠŠæµé‡åˆ†é…ç»™ä¸‹æ¸¸èŠ‚ç‚¹ã€‚å½“ä¸‹æ¸¸èŠ‚ç‚¹å‡ºçŽ°é—®é¢˜æ—¶ï¼Œå®ƒå¯èƒ½ä¼šè¢«éš”ç¦»ä»¥æé«˜è´Ÿè½½å‡è¡¡çš„æ•ˆçŽ‡ã€‚è¢«éš”ç¦»çš„èŠ‚ç‚¹å®šæœŸè¢«å¥åº·æ£€æŸ¥ï¼ŒæˆåŠŸåŽé‡æ–°åŠ å…¥æ­£å¸¸èŠ‚ç‚¹ã€‚&lt;/p&gt;
&lt;h1 id=&#34;å‘½åæœåŠ¡&#34;&gt;å‘½åæœåŠ¡&lt;/h1&gt;
&lt;p&gt;åœ¨brpcä¸­ï¼Œ&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/naming_service.h&#34;&gt;NamingService&lt;/a&gt;ç”¨äºŽèŽ·å¾—æœåŠ¡åå¯¹åº”çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚ä¸€ä¸ªç›´è§‚çš„åšæ³•æ˜¯å®šæœŸè°ƒç”¨ä¸€ä¸ªå‡½æ•°ä»¥èŽ·å–æœ€æ–°çš„èŠ‚ç‚¹åˆ—è¡¨ã€‚ä½†è¿™ä¼šå¸¦æ¥ä¸€å®šçš„å»¶æ—¶ï¼ˆå®šæœŸè°ƒç”¨çš„å‘¨æœŸä¸€èˆ¬åœ¨è‹¥å¹²ç§’å·¦å³ï¼‰ï¼Œä½œä¸ºé€šç”¨æŽ¥å£ä¸å¤ªåˆé€‚ã€‚ç‰¹åˆ«å½“å‘½åæœåŠ¡æä¾›äº‹ä»¶é€šçŸ¥æ—¶(æ¯”å¦‚zk)ï¼Œè¿™ä¸ªç‰¹æ€§æ²¡æœ‰è¢«åˆ©ç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬åè½¬äº†æŽ§åˆ¶æƒï¼šä¸æ˜¯æˆ‘ä»¬è°ƒç”¨ç”¨æˆ·å‡½æ•°ï¼Œè€Œæ˜¯ç”¨æˆ·åœ¨èŽ·å¾—åˆ—è¡¨åŽè°ƒç”¨æˆ‘ä»¬çš„æŽ¥å£ï¼Œå¯¹åº”&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/naming_service.h&#34;&gt;NamingServiceActions&lt;/a&gt;ã€‚å½“ç„¶æˆ‘ä»¬è¿˜æ˜¯å¾—å¯åŠ¨è¿›è¡Œè¿™ä¸€è¿‡ç¨‹çš„å‡½æ•°ï¼Œå¯¹åº”NamingService::RunNamingServiceã€‚ä¸‹é¢ä»¥ä¸‰ä¸ªå®žçŽ°è§£é‡Šè¿™å¥—æ–¹å¼ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bnsï¼šæ²¡æœ‰äº‹ä»¶é€šçŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½å®šæœŸåŽ»èŽ·å¾—æœ€æ–°åˆ—è¡¨ï¼Œé»˜è®¤é—´éš”æ˜¯&lt;a href=&#34;http://brpc.baidu.com:8765/flags/ns_access_interval&#34;&gt;5ç§’&lt;/a&gt;ã€‚ä¸ºäº†ç®€åŒ–è¿™ç±»å®šæœŸèŽ·å–çš„é€»è¾‘ï¼Œbrpcæä¾›äº†&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/periodic_naming_service.h&#34;&gt;PeriodicNamingService&lt;/a&gt; ä¾›ç”¨æˆ·ç»§æ‰¿ï¼Œç”¨æˆ·åªéœ€è¦å®žçŽ°å•æ¬¡å¦‚ä½•èŽ·å–ï¼ˆGetServersï¼‰ã€‚èŽ·å–åŽè°ƒç”¨NamingServiceActions::ResetServerså‘Šè¯‰æ¡†æž¶ã€‚æ¡†æž¶ä¼šå¯¹åˆ—è¡¨åŽ»é‡ï¼Œå’Œä¹‹å‰çš„åˆ—è¡¨æ¯”è¾ƒï¼Œé€šçŸ¥å¯¹åˆ—è¡¨æœ‰å…´è¶£çš„è§‚å¯Ÿè€…(NamingServiceWatcher)ã€‚è¿™å¥—é€»è¾‘ä¼šè¿è¡Œåœ¨ç‹¬ç«‹çš„bthreadä¸­ï¼Œå³NamingServiceThreadã€‚ä¸€ä¸ªNamingServiceThreadå¯èƒ½è¢«å¤šä¸ªChannelå…±äº«ï¼Œé€šè¿‡intrusive_ptrç®¡ç†ownershipã€‚&lt;/li&gt;
&lt;li&gt;fileï¼šåˆ—è¡¨å³æ–‡ä»¶ã€‚åˆç†çš„æ–¹å¼æ˜¯åœ¨æ–‡ä»¶æ›´æ–°åŽé‡æ–°è¯»å–ã€‚&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/policy/file_naming_service.cpp&#34;&gt;è¯¥å®žçŽ°&lt;/a&gt;ä½¿ç”¨&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/butil/files/file_watcher.h&#34;&gt;FileWatcher&lt;/a&gt;å…³æ³¨æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´ï¼Œå½“æ–‡ä»¶ä¿®æ”¹åŽï¼Œè¯»å–å¹¶è°ƒç”¨NamingServiceActions::ResetServerså‘Šè¯‰æ¡†æž¶ã€‚&lt;/li&gt;
&lt;li&gt;listï¼šåˆ—è¡¨å°±åœ¨æœåŠ¡åé‡Œï¼ˆé€—å·åˆ†éš”ï¼‰ã€‚åœ¨è¯»å–å®Œä¸€æ¬¡å¹¶è°ƒç”¨NamingServiceActions::ResetServersåŽå°±é€€å‡ºäº†ï¼Œå› ä¸ºåˆ—è¡¨å†ä¸ä¼šæ”¹å˜äº†ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å¦‚æžœç”¨æˆ·éœ€è¦å»ºç«‹è¿™äº›å¯¹è±¡ä»ç„¶æ˜¯ä¸å¤Ÿæ–¹ä¾¿çš„ï¼Œå› ä¸ºæ€»æ˜¯éœ€è¦ä¸€äº›å·¥åŽ‚ä»£ç æ ¹æ®é…ç½®é¡¹å»ºç«‹ä¸åŒçš„å¯¹è±¡ï¼Œé‰´äºŽæ­¤ï¼Œæˆ‘ä»¬æŠŠå·¥åŽ‚ç±»åšè¿›äº†æ¡†æž¶ï¼Œå¹¶ä¸”æ˜¯éžå¸¸æ–¹ä¾¿çš„å½¢å¼ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;protocol://service-name&amp;quot;
 
e.g.
bns://&amp;lt;node-name&amp;gt;            # baidu naming service
file://&amp;lt;file-path&amp;gt;           # load addresses from the file
list://addr1,addr2,...       # use the addresses separated by comma
http://&amp;lt;url&amp;gt;                 # Domain Naming Service, aka DNS.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;è¿™å¥—æ–¹å¼æ˜¯å¯æ‰©å±•çš„ï¼Œå®žçŽ°äº†æ–°çš„NamingServiceåŽåœ¨&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/global.cpp&#34;&gt;global.cpp&lt;/a&gt;ä¸­ä¾è‘«èŠ¦ç”»ç“¢æ³¨å†Œä¸‹å°±è¡Œäº†ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/register_ns.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;çœ‹åˆ°è¿™äº›ç†Ÿæ‚‰çš„å­—ç¬¦ä¸²æ ¼å¼ï¼Œå®¹æ˜“è”æƒ³åˆ°ftp:// zk:// galileo://ç­‰ç­‰éƒ½æ˜¯å¯ä»¥æ”¯æŒçš„ã€‚ç”¨æˆ·åœ¨æ–°å»ºChannelæ—¶ä¼ å…¥è¿™ç±»NamingServiceæè¿°ï¼Œå¹¶èƒ½æŠŠè¿™äº›æè¿°å†™åœ¨å„ç±»é…ç½®æ–‡ä»¶ä¸­ã€‚&lt;/p&gt;
&lt;h1 id=&#34;è´Ÿè½½å‡è¡¡&#34;&gt;è´Ÿè½½å‡è¡¡&lt;/h1&gt;
&lt;p&gt;brpcä¸­&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/brpc/load_balancer.h&#34;&gt;LoadBalancer&lt;/a&gt;ä»Žå¤šä¸ªæœåŠ¡èŠ‚ç‚¹ä¸­é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›®å‰çš„å®žçŽ°è§&lt;a href=&#34;../../client/basics/#load-balancer&#34;&gt;è´Ÿè½½å‡è¡¡&lt;/a&gt;ã€‚&lt;/p&gt;
&lt;p&gt;Load balanceræœ€é‡è¦çš„æ˜¯å¦‚ä½•è®©ä¸åŒçº¿ç¨‹ä¸­çš„è´Ÿè½½å‡è¡¡ä¸äº’æ–¥ï¼Œè§£å†³è¿™ä¸ªé—®é¢˜çš„æŠ€æœ¯æ˜¯&lt;a href=&#34;../locality-aware/#doublybuffereddata&#34;&gt;DoublyBufferedData&lt;/a&gt;ã€‚&lt;/p&gt;
&lt;p&gt;å’ŒNamingServiceç±»ä¼¼ï¼Œæˆ‘ä»¬ä½¿ç”¨å­—ç¬¦ä¸²æ¥æŒ‡ä»£ä¸€ä¸ªload balancerï¼Œåœ¨global.cppä¸­æ³¨å†Œï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/register_lb.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;å¥åº·æ£€æŸ¥&#34;&gt;å¥åº·æ£€æŸ¥&lt;/h1&gt;
&lt;p&gt;å¯¹äºŽé‚£äº›æ— æ³•è¿žæŽ¥å´ä»åœ¨NamingServiceçš„èŠ‚ç‚¹ï¼Œbrpcä¼šå®šæœŸè¿žæŽ¥å®ƒä»¬ï¼ŒæˆåŠŸåŽå¯¹åº”çš„Socketå°†è¢«â€å¤æ´»â€œï¼Œå¹¶å¯èƒ½è¢«LoadBalanceré€‰æ‹©ä¸Šï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯å¥åº·æ£€æŸ¥ã€‚æ³¨æ„ï¼šè¢«å¥åº·æ£€æŸ¥æˆ–åœ¨LoadBalancerä¸­çš„èŠ‚ç‚¹ä¸€å®šåœ¨NamingServiceä¸­ã€‚æ¢å¥è¯è¯´ï¼Œåªè¦ä¸€ä¸ªèŠ‚ç‚¹ä¸ä»ŽNamingServiceåˆ é™¤ï¼Œå®ƒè¦ä¹ˆæ˜¯æ­£å¸¸çš„ï¼ˆä¼šè¢«LoadBalanceré€‰ä¸Šï¼‰ï¼Œè¦ä¹ˆåœ¨åšå¥åº·æ£€æŸ¥ã€‚&lt;/p&gt;
&lt;p&gt;ä¼ ç»Ÿçš„åšæ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹åšæ‰€æœ‰è¿žæŽ¥çš„å¥åº·æ£€æŸ¥ï¼Œbrpcç®€åŒ–äº†è¿™ä¸ªè¿‡ç¨‹ï¼šä¸ºéœ€è¦çš„è¿žæŽ¥åŠ¨æ€åˆ›å»ºä¸€ä¸ªbthreadä¸“é—¨åšå¥åº·æ£€æŸ¥ï¼ˆSocket::HealthCheckThreadï¼‰ã€‚è¿™ä¸ªçº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸè¢«å¯¹åº”è¿žæŽ¥ç®¡ç†ã€‚å…·ä½“æ¥è¯´ï¼Œå½“Socketè¢«SetFailedåŽï¼Œå¥åº·æ£€æŸ¥çº¿ç¨‹å°±å¯èƒ½å¯åŠ¨ï¼ˆå¦‚æžœSocketOptions.health_check_intervalä¸ºæ­£æ•°çš„è¯ï¼‰ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¥åº·æ£€æŸ¥çº¿ç¨‹å…ˆåœ¨ç¡®ä¿æ²¡æœ‰å…¶ä»–äººåœ¨ä½¿ç”¨Socketäº†åŽå…³é—­è¿žæŽ¥ã€‚ç›®å‰æ˜¯é€šè¿‡å¯¹Socketçš„å¼•ç”¨è®¡æ•°åˆ¤æ–­çš„ã€‚è¿™ä¸ªæ–¹æ³•ä¹‹æ‰€ä»¥æœ‰æ•ˆåœ¨äºŽSocketè¢«SetFailedåŽå°±ä¸èƒ½è¢«Addressäº†ï¼Œæ‰€ä»¥å¼•ç”¨è®¡æ•°åªå‡ä¸å¢žã€‚&lt;/li&gt;
&lt;li&gt;å®šæœŸè¿žæŽ¥ç›´åˆ°è¿œç«¯æœºå™¨è¢«è¿žæŽ¥ä¸Šï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¦‚æžœSocketæžæž„äº†ï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹ä¹Ÿå°±éšä¹‹é€€å‡ºäº†ã€‚&lt;/li&gt;
&lt;li&gt;è¿žä¸ŠåŽå¤æ´»Socket(Socket::Revive)ï¼Œè¿™æ ·Socketå°±åˆèƒ½è¢«å…¶ä»–åœ°æ–¹ï¼ŒåŒ…æ‹¬LoadBalancerè®¿é—®åˆ°äº†ï¼ˆé€šè¿‡Socket::Addressï¼‰ã€‚&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Locality-aware</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/locality-aware/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/locality-aware/</guid>
      <description>
        
        
        &lt;h1 id=&#34;æ¦‚è¿°&#34;&gt;æ¦‚è¿°&lt;/h1&gt;
&lt;p&gt;LALBå…¨ç§°Locality-aware load balancingï¼Œæ˜¯ä¸€ä¸ªèƒ½æŠŠè¯·æ±‚åŠæ—¶ã€è‡ªåŠ¨åœ°é€åˆ°å»¶æ—¶æœ€ä½Žçš„ä¸‹æ¸¸çš„è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œç‰¹åˆ«é€‚åˆæ··åˆéƒ¨ç½²çŽ¯å¢ƒã€‚è¯¥ç®—æ³•äº§ç”Ÿè‡ªDPç³»ç»Ÿï¼ŒçŽ°å·²åŠ å…¥brpcï¼&lt;/p&gt;
&lt;p&gt;LALBå¯ä»¥è§£å†³çš„é—®é¢˜ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¸‹æ¸¸çš„æœºå™¨é…ç½®ä¸åŒï¼Œè®¿é—®å»¶æ—¶ä¸åŒï¼Œround-robinå’Œéšæœºåˆ†æµæ•ˆæžœä¸ä½³ã€‚&lt;/li&gt;
&lt;li&gt;ä¸‹æ¸¸æœåŠ¡å’Œç¦»çº¿æœåŠ¡æˆ–å…¶ä»–æœåŠ¡æ··éƒ¨ï¼Œæ€§èƒ½éš¾ä»¥é¢„æµ‹ã€‚&lt;/li&gt;
&lt;li&gt;è‡ªåŠ¨åœ°æŠŠå¤§éƒ¨åˆ†æµé‡é€ç»™åŒæœºéƒ¨ç½²çš„æ¨¡å—ï¼Œå½“åŒæœºæ¨¡å—å‡ºé—®é¢˜æ—¶ï¼Œå†è·¨æœºå™¨ã€‚&lt;/li&gt;
&lt;li&gt;ä¼˜å…ˆè®¿é—®æœ¬æœºæˆ¿æœåŠ¡ï¼Œå‡ºé—®é¢˜æ—¶å†è·¨æœºæˆ¿ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;â€¦&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;èƒŒæ™¯&#34;&gt;èƒŒæ™¯&lt;/h1&gt;
&lt;p&gt;æœ€å¸¸è§çš„åˆ†æµç®—æ³•æ˜¯round robinå’Œéšæœºã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„å‰ææ˜¯ä¸‹æ¸¸çš„æœºå™¨å’Œç½‘ç»œéƒ½æ˜¯ç±»ä¼¼çš„ï¼Œä½†åœ¨ç›®å‰çš„çº¿ä¸ŠçŽ¯å¢ƒä¸‹ï¼Œç‰¹åˆ«æ˜¯æ··éƒ¨çš„äº§å“çº¿ä¸­ï¼Œå·²ç»å¾ˆéš¾æˆç«‹ï¼Œå› ä¸ºï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æ¯å°æœºå™¨è¿è¡Œç€ä¸åŒçš„ç¨‹åºç»„åˆï¼Œå¹¶ä¼´éšç€ä¸€äº›ç¦»çº¿ä»»åŠ¡ï¼Œæœºå™¨çš„å¯ç”¨èµ„æºåœ¨æŒç»­åŠ¨æ€åœ°å˜åŒ–ç€ã€‚&lt;/li&gt;
&lt;li&gt;æœºå™¨é…ç½®ä¸åŒã€‚&lt;/li&gt;
&lt;li&gt;ç½‘ç»œå»¶æ—¶ä¸åŒã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™äº›é—®é¢˜å…¶å®žä¸€ç›´æœ‰ï¼Œä½†å¾€å¾€è¢«OPè¾›å‹¤çš„æœºå™¨ç›‘æŽ§å’Œæ›¿æ¢ç»™éšè—äº†ã€‚æ¡†æž¶å±‚é¢ä¹Ÿæœ‰è¿‡ä¸€äº›åŠªåŠ›ï¼Œæ¯”å¦‚UBä¸­çš„&lt;a href=&#34;https://svn.baidu.com/public/trunk/ub/ub_client/ubclient_weightstrategy.h&#34;&gt;WeightedStrategy&lt;/a&gt;æ˜¯æ ¹æ®ä¸‹æ¸¸çš„cpuå ç”¨çŽ‡æ¥è¿›è¡Œåˆ†æµï¼Œä½†æ˜Žæ˜¾åœ°å®ƒè§£å†³ä¸äº†å»¶æ—¶ç›¸å…³çš„é—®é¢˜ï¼Œç”šè‡³cpuçš„é—®é¢˜ä¹Ÿè§£å†³ä¸äº†ï¼šå› ä¸ºå®ƒè¢«å®žçŽ°ä¸ºå®šæœŸreloadä¸€ä¸ªæƒå€¼åˆ—è¡¨ï¼Œå¯æƒ³è€ŒçŸ¥æ›´æ–°é¢‘çŽ‡é«˜ä¸äº†ï¼Œç­‰åˆ°è´Ÿè½½å‡è¡¡ååº”è¿‡æ¥ï¼Œä¸€å¤§å †è¯·æ±‚å¯èƒ½éƒ½è¶…æ—¶äº†ã€‚å¹¶ä¸”è¿™å„¿æœ‰ä¸ªæ•°å­¦é—®é¢˜ï¼šæ€Žä¹ˆæŠŠcpuå ç”¨çŽ‡è½¬ä¸ºæƒå€¼ã€‚å‡è®¾ä¸‹æ¸¸å·®å¼‚ä»…ä»…ç”±åŒæœºè¿è¡Œçš„å…¶ä»–ç¨‹åºå¯¼è‡´ï¼Œæœºå™¨é…ç½®å’Œç½‘ç»œå®Œå…¨ç›¸åŒï¼Œä¸¤å°æœºå™¨æƒå€¼ä¹‹æ¯”æ˜¯cpu idleä¹‹æ¯”å—ï¼Ÿå‡å¦‚æ˜¯çš„ï¼Œå½“æˆ‘ä»¬ä»¥è¿™ä¸ªæ¯”ä¾‹ç»™ä¸¤å°æœºå™¨åˆ†æµä¹‹åŽï¼Œå®ƒä»¬çš„cpu idleåº”è¯¥ä¼šæ›´æŽ¥è¿‘å¯¹å§ï¼Ÿè€Œè¿™ä¼šå¯¼è‡´æˆ‘ä»¬çš„åˆ†æµæ¯”ä¾‹ä¹Ÿå˜å¾—æŽ¥è¿‘ï¼Œä»Žè€Œä½¿ä¸¤å°æœºå™¨çš„cpu idleåˆå‡ºçŽ°å·®è·ã€‚ä½ æ³¨æ„åˆ°è¿™ä¸ªæ‚–è®ºäº†å—ï¼Ÿè¿™äº›å› ç´ ä½¿å¾—è¿™ç±»ç®—æ³•çš„å®žé™…æ•ˆæžœå’Œé‚£ä¸¤ä¸ªåŸºæœ¬ç®—æ³•æ²¡ä»€ä¹ˆå·®è·ï¼Œç”šè‡³æ›´å·®ï¼Œç”¨è€…ç”šå°‘ã€‚&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬éœ€è¦ä¸€ä¸ªèƒ½è‡ªé€‚åº”ä¸‹æ¸¸è´Ÿè½½ã€è§„é¿æ…¢èŠ‚ç‚¹çš„é€šç”¨åˆ†æµç®—æ³•ã€‚&lt;/p&gt;
&lt;h1 id=&#34;locality-aware&#34;&gt;Locality-aware&lt;/h1&gt;
&lt;p&gt;åœ¨DP 2.0ä¸­æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ç§æ–°çš„ç®—æ³•: Locality-aware load balancingï¼Œèƒ½æ ¹æ®ä¸‹æ¸¸èŠ‚ç‚¹çš„è´Ÿè½½åˆ†é…æµé‡ï¼Œè¿˜èƒ½å¿«é€Ÿè§„é¿å¤±æ•ˆçš„èŠ‚ç‚¹ï¼Œåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šï¼Œè¿™ç§ç®—æ³•çš„å»¶æ—¶ä¹Ÿæ˜¯å…¨å±€æœ€ä¼˜çš„ã€‚åŸºæœ¬åŽŸç†éžå¸¸ç®€å•ï¼š&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ä»¥ä¸‹æ¸¸èŠ‚ç‚¹çš„åžåé™¤ä»¥å»¶æ—¶ä½œä¸ºåˆ†æµæƒå€¼ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;æ¯”å¦‚åªæœ‰ä¸¤å°ä¸‹æ¸¸èŠ‚ç‚¹ï¼ŒWä»£è¡¨æƒå€¼ï¼ŒQPSä»£è¡¨åžåï¼ŒLä»£è¡¨å»¶æ—¶ï¼Œé‚£ä¹ˆW1 = QPS1 / L1å’ŒW2 = QPS2 / L2åˆ†åˆ«æ˜¯è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„åˆ†æµæƒå€¼ï¼Œåˆ†æµæ—¶éšæœºæ•°è½å…¥çš„æƒå€¼åŒºé—´å°±æ˜¯æµé‡çš„ç›®çš„åœ°äº†ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€ç§åˆ†æžæ–¹æ³•å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ç¨³å®šçŠ¶æ€æ—¶çš„QPSæ˜¾ç„¶å’Œå…¶åˆ†æµæƒå€¼Wæˆæ­£æ¯”ï¼Œå³W1 / W2 â‰ˆ QPS1 / QPS2ã€‚&lt;/li&gt;
&lt;li&gt;æ ¹æ®åˆ†æµå…¬å¼åˆæœ‰ï¼šW1 / W2 = QPS1 / QPS2 * (L2 / L1)ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æ•…ç¨³å®šçŠ¶æ€æ—¶L1å’ŒL2åº”å½“æ˜¯è¶‹åŒçš„ã€‚å½“L1å°äºŽL2æ—¶ï¼ŒèŠ‚ç‚¹1ä¼šæ›´èŽ·å¾—ç›¸æ¯”å…¶QPS1æ›´å¤§çš„W1ï¼Œä»Žè€Œåœ¨æœªæ¥èŽ·å¾—æ›´å¤šçš„æµé‡ï¼Œç›´åˆ°&lt;strong&gt;å…¶å»¶æ—¶é«˜äºŽå¹³å‡å€¼æˆ–æ²¡æœ‰æ›´å¤šçš„æµé‡ã€‚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;æ³¨æ„è¿™ä¸ªç®—æ³•å¹¶ä¸æ˜¯æŒ‰ç…§å»¶æ—¶çš„æ¯”ä¾‹æ¥åˆ†æµï¼Œä¸æ˜¯è¯´ä¸€ä¸ªä¸‹æ¸¸30msï¼Œå¦ä¸€ä¸ª60msï¼Œå®ƒä»¬çš„æµé‡æ¯”ä¾‹å°±æ˜¯60 / 30ã€‚è€Œæ˜¯30msçš„èŠ‚ç‚¹ä¼šä¸€ç›´èŽ·å¾—æµé‡ç›´åˆ°å®ƒçš„å»¶æ—¶é«˜äºŽ60msï¼Œæˆ–è€…æ²¡æœ‰æ›´å¤šæµé‡äº†ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œæ›²çº¿1å’Œæ›²çº¿2åˆ†åˆ«æ˜¯èŠ‚ç‚¹1å’ŒèŠ‚ç‚¹2çš„å»¶æ—¶ä¸Žåžåå…³ç³»å›¾ï¼Œéšç€åžåå¢žå¤§å»¶æ—¶ä¼šé€æ¸å‡é«˜ï¼ŒæŽ¥è¿‘æžé™åžåæ—¶ï¼Œå»¶æ—¶ä¼šé£™å‡ã€‚å·¦ä¸‹çš„è™šçº¿æ ‡è®°äº†QPS=400æ—¶çš„å»¶æ—¶ï¼Œæ­¤æ—¶è™½ç„¶èŠ‚ç‚¹1çš„å»¶æ—¶æœ‰æ‰€ä¸Šå‡ï¼Œä½†è¿˜æœªé«˜äºŽèŠ‚ç‚¹2çš„åŸºæœ¬å»¶æ—¶ï¼ˆQPS=0æ—¶çš„å»¶æ—¶ï¼‰ï¼Œæ‰€ä»¥æ‰€æœ‰æµé‡éƒ½ä¼šåˆ†ç»™èŠ‚ç‚¹1ï¼Œè€Œä¸æ˜¯æŒ‰å®ƒä»¬åŸºæœ¬å»¶æ—¶çš„æ¯”ä¾‹ï¼ˆå›¾ä¸­å¤§çº¦2:1ï¼‰ã€‚å½“QPSç»§ç»­ä¸Šå‡è¾¾åˆ°1600æ—¶ï¼Œåˆ†æµæ¯”ä¾‹ä¼šåœ¨ä¸¤ä¸ªèŠ‚ç‚¹å»¶æ—¶ç›¸ç­‰æ—¶å¹³è¡¡ï¼Œå›¾ä¸­ä¸º9 : 7ã€‚å¾ˆæ˜Žæ˜¾è¿™ä¸ªæ¯”ä¾‹æ˜¯é«˜åº¦éžçº¿æ€§çš„ï¼Œå–å†³äºŽä¸åŒæ›²çº¿çš„ç»„åˆï¼Œå’Œå•ä¸€æŒ‡æ ‡çš„æ¯”ä¾‹å…³ç³»æ²¡æœ‰ç›´æŽ¥å…³è”ã€‚åœ¨çœŸå®žç³»ç»Ÿä¸­ï¼Œå»¶æ—¶å’Œåžåçš„æ›²çº¿ä¹Ÿåœ¨åŠ¨æ€å˜åŒ–ç€ï¼Œåˆ†æµæ¯”ä¾‹æ›´åŠ åŠ¨æ€ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/lalb_1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬ç”¨ä¸€ä¸ªä¾‹å­æ¥çœ‹ä¸€ä¸‹å…·ä½“çš„åˆ†æµè¿‡ç¨‹ã€‚å¯åŠ¨3å°serverï¼Œé€»è¾‘åˆ†åˆ«æ˜¯sleep 1msï¼Œ2msï¼Œ3msï¼Œå¯¹äºŽclientæ¥è¯´è¿™äº›å€¼å°±æ˜¯å»¶æ—¶ã€‚å¯åŠ¨clientï¼ˆ50ä¸ªåŒæ­¥è®¿é—®çº¿ç¨‹ï¼‰åŽæ¯ç§’æ‰“å°çš„åˆ†æµç»“æžœå¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/lalb_2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;S[n]ä»£è¡¨ç¬¬nå°serverã€‚ç”±äºŽS[1]å’ŒS[2]çš„å¹³å‡å»¶æ—¶å¤§äºŽ1msï¼ŒLALBä¼šå‘çŽ°è¿™ç‚¹å¹¶é™ä½Žå®ƒä»¬çš„æƒå€¼ã€‚å®ƒä»¬çš„æƒå€¼ä¼šç»§ç»­ä¸‹é™ï¼Œç›´åˆ°è¢«ç®—æ³•è®¾å®šçš„æœ€ä½Žå€¼æ‹¦ä½ã€‚è¿™æ—¶åœæŽ‰serverï¼Œåè½¬å»¶æ—¶å¹¶é‡æ–°å¯åŠ¨ï¼Œå³é€»è¾‘åˆ†åˆ«ä¸ºsleep 3msï¼Œ2msï¼Œ1msï¼Œè¿è¡Œä¸€æ®µæ—¶å€™åŽåˆ†æµæ•ˆæžœå¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/lalb_3.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;åˆšé‡è¿žä¸Šserveræ—¶ï¼Œclientè¿˜æ˜¯æŒ‰ä¹‹å‰çš„æƒå€¼æŠŠå¤§éƒ¨åˆ†æµé‡éƒ½åˆ†ç»™äº†S[0]ï¼Œä½†ç”±äºŽS[0]çš„å»¶æ—¶ä»Ž1msä¸Šå‡åˆ°äº†3msï¼Œclientçš„qpsä¹Ÿé™åˆ°äº†åŽŸæ¥çš„1/3ã€‚éšç€æ•°æ®ç§¯ç´¯ï¼ŒLALBé€æ¸å‘çŽ°S[2]æ‰æ˜¯æœ€å¿«çš„ï¼Œè€ŒæŠŠå¤§éƒ¨åˆ†æµé‡åˆ‡æ¢äº†è¿‡åŽ»ã€‚åŒæ ·çš„æœåŠ¡å¦‚æžœç”¨rræˆ–randomè®¿é—®ï¼Œåˆ™qpsä¼šæ˜¾è‘—ä¸‹é™ï¼š&lt;/p&gt;
&lt;p&gt;&amp;ldquo;rr&amp;rdquo; or &amp;ldquo;random&amp;rdquo;: &lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/lalb_4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;la&amp;rdquo; :                       &lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/lalb_5.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;çœŸå®žçš„åœºæ™¯ä¸­ä¸ä¼šæœ‰è¿™ä¹ˆæ˜¾è‘—çš„å·®å¼‚ï¼Œä½†ä½ åº”è¯¥èƒ½çœ‹åˆ°å·®åˆ«äº†ã€‚&lt;/p&gt;
&lt;p&gt;è¿™æœ‰å¾ˆå¤šåº”ç”¨åœºæ™¯ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¦‚æžœæœ¬æœºæœ‰ä¸‹æ¸¸æœåŠ¡ï¼ŒLALBä¼šä¼˜å…ˆè®¿é—®è¿™äº›æœ€è¿‘çš„èŠ‚ç‚¹ã€‚æ¯”å¦‚CTRåº”ç”¨ä¸­æœ‰ä¸€ä¸ªè®¡ç®—åœ¨1mså·¦å³çš„receiveræ¨¡å—ï¼Œè¢«modelæ¨¡å—è®¿é—®ï¼Œå¾ˆå¤šmodelå’Œreceiveræ˜¯åŒæœºéƒ¨ç½²çš„ï¼Œä»¥å‰çš„åˆ†æµç®—æ³•å¿…é¡»èµ°ç½‘ç»œï¼Œä½¿å¾—receiverçš„å»¶æ—¶å¼€é”€è¾ƒå¤§(3-5ms)ï¼Œç‰¹åˆ«æ˜¯åœ¨æ™šä¸Šç”±äºŽç¦»çº¿ä»»åŠ¡èµ·æ¥ï¼Œå¾ˆä¸ç¨³å®šï¼Œå¤±è´¥çŽ‡åé«˜ï¼Œè€ŒLALBä¼šä¼˜å…ˆè®¿é—®æœ¬æœºæˆ–æœ€è¿‘çš„receiveræ¨¡å—ï¼Œå¾ˆå¤šæµé‡éƒ½ä¸èµ°ç½‘ç»œäº†ï¼ŒæˆåŠŸçŽ‡ä¸€ä¸‹å­æå‡äº†å¾ˆå¤šã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æžœåŒrackæœ‰ä¸‹æ¸¸æœåŠ¡ï¼ŒLALBä¹Ÿä¼šä¼˜å…ˆè®¿é—®ï¼Œå‡å°‘æœºæˆ¿æ ¸å¿ƒè·¯ç”±å™¨çš„åŽ‹åŠ›ã€‚ç”šè‡³ä¸åŒæœºæˆ¿çš„æœåŠ¡å¯èƒ½ä¸å†éœ€è¦éš”ç¦»ï¼ŒLALBä¼šä¼˜å…ˆèµ°æœ¬æœºæˆ¿çš„ä¸‹æ¸¸ï¼Œå½“æœ¬æœºæˆ¿ä¸‹æ¸¸å‡ºé—®é¢˜æ—¶å†è‡ªåŠ¨è®¿é—®å¦ä¸€äº›æœºæˆ¿ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä½†æˆ‘ä»¬ä¹Ÿä¸èƒ½ä»…çœ‹åˆ°â€œåŸºæœ¬åŽŸç†â€ï¼Œè¿™ä¸ªç®—æ³•æœ‰å®ƒå¤æ‚çš„ä¸€é¢ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¼ ç»Ÿçš„ç»éªŒå‘Šè¯‰æˆ‘ä»¬ï¼Œä¸èƒ½æŠŠæ‰€æœ‰é¸¡è›‹æ”¾ä¸€ä¸ªç¯®å­é‡Œï¼Œè€ŒæŒ‰å»¶æ—¶ä¼˜åŒ–ä¸å¯é¿å…åœ°ä¼šæŠŠå¾ˆå¤šæµé‡é€åˆ°åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æžœè¿™ä¸ªèŠ‚ç‚¹å‡ºé—®é¢˜äº†ï¼Œæˆ‘ä»¬å¦‚ä½•å°½å¿«çŸ¥é“å¹¶ç»•å¼€å®ƒã€‚&lt;/li&gt;
&lt;li&gt;å¯¹åžåå’Œå»¶æ—¶çš„ç»Ÿè®¡éƒ½éœ€è¦ç»Ÿè®¡çª—å£ï¼Œçª—å£è¶Šå¤§æ•°æ®è¶Šå¯ä¿¡ï¼Œå™ªå£°è¶Šå°‘ï¼Œä½†ååº”ä¹Ÿæ…¢äº†ï¼Œä¸€ä¸ªå¼‚å¸¸çš„è¯·æ±‚å¯èƒ½å¯¹ç»Ÿè®¡å€¼é€ ä¸æˆä»€ä¹ˆå½±å“ï¼Œç­‰æˆ‘ä»¬çœ‹åˆ°ç»Ÿè®¡å€¼æœ‰æ˜¾è‘—å˜åŒ–æ—¶å¯èƒ½å·²ç»å¤ªæ™šäº†ã€‚&lt;/li&gt;
&lt;li&gt;æˆ‘ä»¬ä¹Ÿä¸èƒ½åªç»Ÿè®¡å·²ç»å›žæ¥çš„ï¼Œè¿˜å¾—ç›¯ç€è·¯ä¸Šçš„è¯·æ±‚ï¼Œå¦åˆ™æˆ‘ä»¬å¯èƒ½ä¼šå‘ä¸€ä¸ªå·²ç»å‡ºé—®é¢˜ï¼ˆæ€»æ˜¯ä¸å›žï¼‰çš„èŠ‚ç‚¹å‚»å‚»åœ°æµªè´¹è¯·æ±‚ã€‚&lt;/li&gt;
&lt;li&gt;â€æŒ‰æƒå€¼åˆ†æµâ€å¬ä¸ŠåŽ»å¥½ç®€å•ï¼Œä½†ä½ èƒ½å†™å‡ºå¤šçº¿ç¨‹å’Œå¯èƒ½ä¿®æ”¹èŠ‚ç‚¹çš„å‰æä¸‹ï¼Œåœ¨O(logN)æ—¶é—´å†…å°½é‡ä¸äº’æ–¥çš„æŸ¥æ‰¾ç®—æ³•å—ï¼Ÿ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™äº›é—®é¢˜å¯ä»¥å½’çº³ä¸ºä»¥ä¸‹å‡ ä¸ªæ–¹é¢ã€‚&lt;/p&gt;
&lt;h2 id=&#34;doublybuffereddata&#34;&gt;DoublyBufferedData&lt;/h2&gt;
&lt;p&gt;LoadBalanceræ˜¯ä¸€ä¸ªè¯»è¿œå¤šäºŽå†™çš„æ•°æ®ç»“æž„ï¼šå¤§éƒ¨åˆ†æ—¶å€™ï¼Œæ‰€æœ‰çº¿ç¨‹ä»Žä¸€ä¸ªä¸å˜çš„serveråˆ—è¡¨ä¸­é€‰å–ä¸€å°serverã€‚å¦‚æžœserveråˆ—è¡¨çœŸæ˜¯â€œä¸å˜çš„â€ï¼Œé‚£ä¹ˆé€‰å–serverçš„è¿‡ç¨‹å°±ä¸ç”¨åŠ é”ï¼Œæˆ‘ä»¬å¯ä»¥å†™æ›´å¤æ‚çš„åˆ†æµç®—æ³•ã€‚ä¸€ä¸ªæ–¹æ³•æ˜¯ç”¨è¯»å†™é”ï¼Œä½†å½“è¯»ä¸´ç•ŒåŒºä¸æ˜¯ç‰¹åˆ«å¤§æ—¶ï¼ˆæ¯«ç§’çº§ï¼‰ï¼Œè¯»å†™é”å¹¶ä¸æ¯”mutexå¿«ï¼Œè€Œå®žç”¨çš„åˆ†æµç®—æ³•ä¸å¯èƒ½åˆ°æ¯«ç§’çº§ï¼Œå¦åˆ™å¼€é”€ä¹Ÿå¤ªå¤§äº†ã€‚å¦ä¸€ä¸ªæ–¹æ³•æ˜¯åŒç¼“å†²ï¼Œå¾ˆå¤šæ£€ç´¢ç«¯ç”¨ç±»ä¼¼çš„æ–¹æ³•å®žçŽ°æ— é”çš„æŸ¥æ‰¾è¿‡ç¨‹ï¼Œå®ƒå¤§æ¦‚è¿™ä¹ˆå·¥ä½œï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æ•°æ®åˆ†å‰å°å’ŒåŽå°ã€‚&lt;/li&gt;
&lt;li&gt;æ£€ç´¢çº¿ç¨‹åªè¯»å‰å°ï¼Œä¸ç”¨åŠ é”ã€‚&lt;/li&gt;
&lt;li&gt;åªæœ‰ä¸€ä¸ªå†™çº¿ç¨‹ï¼šä¿®æ”¹åŽå°æ•°æ®ï¼Œåˆ‡æ¢å‰åŽå°ï¼Œç¡çœ ä¸€æ®µæ—¶é—´ï¼Œä»¥ç¡®ä¿è€å‰å°ï¼ˆæ–°åŽå°ï¼‰ä¸å†è¢«æ£€ç´¢çº¿ç¨‹è®¿é—®ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™ä¸ªæ–¹æ³•çš„é—®é¢˜åœ¨äºŽå®ƒå‡å®šç¡çœ ä¸€æ®µæ—¶é—´åŽå°±èƒ½é¿å…å’Œå‰å°è¯»çº¿ç¨‹å‘ç”Ÿç«žäº‰ï¼Œè¿™ä¸ªæ—¶é—´ä¸€èˆ¬æ˜¯è‹¥å¹²ç§’ã€‚ç”±äºŽå¤šæ¬¡å†™ä¹‹é—´æœ‰é—´éš”ï¼Œè¿™å„¿çš„å†™å¾€å¾€æ˜¯æ‰¹é‡å†™å…¥ï¼Œç¡çœ æ—¶æ­£å¥½ç”¨äºŽç§¯ç´¯æ•°æ®å¢žé‡ã€‚&lt;/p&gt;
&lt;p&gt;ä½†è¿™å¥—æœºåˆ¶å¯¹â€œserveråˆ—è¡¨â€ä¸å¤ªå¥½ç”¨ï¼šæ€»ä¸èƒ½æ’å…¥ä¸€ä¸ªserverå°±å¾—ç­‰å‡ ç§’é’Ÿæ‰èƒ½æ’å…¥ä¸‹ä¸€ä¸ªå§ï¼Œå³ä½¿æˆ‘ä»¬ç”¨æ‰¹é‡æ’å…¥ï¼Œè¿™ä¸ª&amp;quot;å†·å´&amp;quot;é—´éš”å¤šå°‘ä¼šè®©ç”¨æˆ·è§‰å¾—ç–‘æƒ‘ï¼šçŸ­äº†æ‹…å¿ƒå®‰å…¨æ€§ï¼Œé•¿äº†è§‰å¾—æ²¡æœ‰å¿…è¦ã€‚æˆ‘ä»¬èƒ½å°½é‡é™ä½Žè¿™ä¸ªæ—¶é—´å¹¶ä½¿å…¶å®‰å…¨ä¹ˆï¼Ÿ&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬éœ€è¦&lt;strong&gt;å†™ä»¥æŸç§å½¢å¼å’Œè¯»åŒæ­¥ï¼Œä½†è¯»ä¹‹é—´ç›¸äº’æ²¡ç«žäº‰&lt;/strong&gt;ã€‚ä¸€ç§è§£æ³•æ˜¯ï¼Œè¯»æ‹¿ä¸€æŠŠthread-localé”ï¼Œå†™éœ€è¦æ‹¿åˆ°æ‰€æœ‰çš„thread-localé”ã€‚å…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æ•°æ®åˆ†å‰å°å’ŒåŽå°ã€‚&lt;/li&gt;
&lt;li&gt;è¯»æ‹¿åˆ°è‡ªå·±æ‰€åœ¨çº¿ç¨‹çš„thread-localé”ï¼Œæ‰§è¡ŒæŸ¥è¯¢é€»è¾‘åŽé‡Šæ”¾é”ã€‚&lt;/li&gt;
&lt;li&gt;åŒæ—¶åªæœ‰ä¸€ä¸ªå†™ï¼šä¿®æ”¹åŽå°æ•°æ®ï¼Œåˆ‡æ¢å‰åŽå°ï¼Œ&lt;strong&gt;æŒ¨ä¸ª&lt;/strong&gt;èŽ·å¾—æ‰€æœ‰thread-localé”å¹¶ç«‹åˆ»é‡Šæ”¾ï¼Œç»“æŸåŽå†æ”¹ä¸€éæ–°åŽå°ï¼ˆè€å‰å°ï¼‰ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æˆ‘ä»¬æ¥åˆ†æžä¸‹è¿™ä¸ªæ–¹æ³•çš„åŸºæœ¬åŽŸç†ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å½“ä¸€ä¸ªè¯»æ­£åœ¨å‘ç”Ÿæ—¶ï¼Œå®ƒä¼šæ‹¿ç€æ‰€åœ¨çº¿ç¨‹çš„thread-localé”ï¼Œè¿™æŠŠé”ä¼šæŒ¡ä½åŒæ—¶è¿›è¡Œçš„å†™ï¼Œä»Žè€Œä¿è¯å‰å°æ•°æ®ä¸ä¼šè¢«ä¿®æ”¹ã€‚&lt;/li&gt;
&lt;li&gt;åœ¨å¤§éƒ¨åˆ†æ—¶å€™thread-localé”éƒ½æ²¡æœ‰ç«žäº‰ï¼Œå¯¹æ€§èƒ½å½±å“å¾ˆå°ã€‚&lt;/li&gt;
&lt;li&gt;é€ä¸ªèŽ·å–thread-localé”å¹¶ç«‹åˆ»é‡Šæ”¾æ˜¯ä¸ºäº†&lt;strong&gt;ç¡®ä¿å¯¹åº”çš„è¯»çº¿ç¨‹çœ‹åˆ°äº†åˆ‡æ¢åŽçš„æ–°å‰å°&lt;/strong&gt;ã€‚å¦‚æžœæ‰€æœ‰çš„è¯»çº¿ç¨‹éƒ½çœ‹åˆ°äº†æ–°å‰å°ï¼Œå†™çº¿ç¨‹ä¾¿å¯ä»¥å®‰å…¨åœ°ä¿®æ”¹è€å‰å°ï¼ˆæ–°åŽå°ï¼‰äº†ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å…¶ä»–ç‰¹ç‚¹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¸åŒçš„è¯»ä¹‹é—´æ²¡æœ‰ç«žäº‰ï¼Œé«˜åº¦å¹¶å‘ã€‚&lt;/li&gt;
&lt;li&gt;å¦‚æžœæ²¡æœ‰å†™ï¼Œè¯»æ€»æ˜¯èƒ½æ— ç«žäº‰åœ°èŽ·å–å’Œé‡Šæ”¾thread-localé”ï¼Œä¸€èˆ¬å°äºŽ25nsï¼Œå¯¹å»¶æ—¶åŸºæœ¬æ— å½±å“ã€‚å¦‚æžœæœ‰å†™ï¼Œç”±äºŽå…¶ä¸´ç•ŒåŒºæžå°ï¼ˆæ‹¿åˆ°ç«‹åˆ»é‡Šæ”¾ï¼‰ï¼Œè¯»åœ¨å¤§éƒ¨åˆ†æ—¶å€™ä»èƒ½å¿«é€Ÿåœ°èŽ·å¾—é”ï¼Œå°‘æ•°æ—¶å€™é‡Šæ”¾é”æ—¶å¯èƒ½æœ‰å”¤é†’å†™çº¿ç¨‹çš„ä»£ä»·ã€‚ç”±äºŽå†™æœ¬èº«å°±æ˜¯å°‘æ•°æƒ…å†µï¼Œè¯»æ•´ä½“ä¸Šå‡ ä¹Žä¸ä¼šç¢°åˆ°ç«žäº‰é”ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å®Œæˆè¿™äº›åŠŸèƒ½çš„æ•°æ®ç»“æž„æ˜¯&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/butil/containers/doubly_buffered_data.h&#34;&gt;DoublyBufferedData&amp;lt;&amp;gt;&lt;/a&gt;ï¼Œæˆ‘ä»¬å¸¸ç®€ç§°ä¸ºDBDã€‚brpcä¸­çš„æ‰€æœ‰load balanceréƒ½ä½¿ç”¨äº†è¿™ä¸ªæ•°æ®ç»“æž„ï¼Œä½¿ä¸åŒçº¿ç¨‹åœ¨åˆ†æµæ—¶å‡ ä¹Žä¸ä¼šäº’æ–¥ã€‚è€Œå…¶ä»–rpcå®žçŽ°å¾€å¾€ä½¿ç”¨äº†å…¨å±€é”ï¼Œè¿™ä½¿å¾—å®ƒä»¬æ— æ³•å†™å‡ºå¤æ‚çš„åˆ†æµç®—æ³•ï¼šå¦åˆ™åˆ†æµä»£ç å°†ä¼šæˆä¸ºç«žäº‰çƒ­ç‚¹ã€‚&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªç»“æž„æœ‰å¹¿æ³›çš„åº”ç”¨åœºæ™¯ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reloadè¯å…¸ã€‚å¤§éƒ¨åˆ†æ—¶å€™è¯å…¸éƒ½æ˜¯åªè¯»çš„ï¼Œä¸åŒçº¿ç¨‹åŒæ—¶æŸ¥è¯¢æ—¶ä¸åº”äº’æ–¥ã€‚&lt;/li&gt;
&lt;li&gt;å¯æ›¿æ¢çš„å…¨å±€callbackã€‚åƒbutil/logging.cppæ”¯æŒé…ç½®å…¨å±€LogSinkä»¥é‡å®šå‘æ—¥å¿—ï¼Œè¿™ä¸ªLogSinkå°±æ˜¯ä¸€ä¸ªå¸¦çŠ¶æ€çš„callbackã€‚å¦‚æžœåªæ˜¯ç®€å•çš„å…¨å±€å˜é‡ï¼Œåœ¨æ›¿æ¢åŽæˆ‘ä»¬æ— æ³•ç›´æŽ¥åˆ é™¤LogSinkï¼Œå› ä¸ºå¯èƒ½è¿˜æœ‰éƒ½å†™çº¿ç¨‹åœ¨ç”¨ã€‚ç”¨DBDå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;weight-tree&#34;&gt;weight tree&lt;/h2&gt;
&lt;p&gt;LALBçš„æŸ¥æ‰¾è¿‡ç¨‹æ˜¯æŒ‰æƒå€¼åˆ†æµï¼ŒO(N)æ–¹æ³•å¦‚ä¸‹ï¼šèŽ·å¾—æ‰€æœ‰æƒå€¼çš„å’Œtotalï¼Œäº§ç”Ÿä¸€ä¸ªé—´äºŽ[0, total-1]çš„éšæœºæ•°Rï¼Œé€ä¸ªéåŽ†æƒå€¼ï¼Œç›´åˆ°å½“å‰æƒå€¼ä¹‹å’Œä¸å¤§äºŽRï¼Œè€Œä¸‹ä¸€ä¸ªæƒå€¼ä¹‹å’Œå¤§äºŽRã€‚&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªæ–¹æ³•å¯ä»¥å·¥ä½œï¼Œä¹Ÿå¥½ç†è§£ï¼Œä½†å½“Nè¾¾åˆ°å‡ ç™¾æ—¶æ€§èƒ½å·²ç»å¾ˆå·®ï¼Œè¿™å„¿çš„ä¸»è¦å› ç´ æ˜¯cacheä¸€è‡´æ€§ï¼šLALBæ˜¯ä¸€ä¸ªåŸºäºŽåé¦ˆçš„ç®—æ³•ï¼ŒRPCç»“æŸæ—¶ä¿¡æ¯ä¼šè¢«åé¦ˆå…¥LALBï¼Œè¢«éåŽ†çš„æ•°æ®ç»“æž„ä¹Ÿä¸€ç›´åœ¨è¢«ä¿®æ”¹ã€‚è¿™æ„å‘³ç€å‰å°çš„O(N)è¯»å¿…é¡»åˆ·æ–°æ¯ä¸€è¡Œcachelineã€‚å½“Nè¾¾åˆ°æ•°ç™¾æ—¶ï¼Œä¸€æ¬¡æŸ¥æ‰¾è¿‡ç¨‹å¯èƒ½ä¼šè€—æ—¶ç™¾å¾®ç§’ï¼Œæ›´åˆ«ææ›´å¤§çš„Näº†ï¼ŒLALBï¼ˆå°†ï¼‰ä½œä¸ºbrpcçš„é»˜è®¤åˆ†æµç®—æ³•ï¼Œè¿™ä¸ªæ€§èƒ½å¼€é”€æ˜¯æ— æ³•æŽ¥å—çš„ã€‚&lt;/p&gt;
&lt;p&gt;å¦ä¸€ä¸ªåŠžæ³•æ˜¯ç”¨å®Œå…¨äºŒå‰æ ‘ã€‚æ¯ä¸ªèŠ‚ç‚¹è®°å½•äº†å·¦å­æ ‘çš„æƒå€¼ä¹‹å’Œï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½åœ¨O(logN)æ—¶é—´å†…å®ŒæˆæŸ¥æ‰¾ã€‚å½“Nä¸º1024æ—¶ï¼Œæˆ‘ä»¬æœ€å¤šè·³è½¬10æ¬¡å†…å­˜ï¼Œæ€»è€—æ—¶å¯æŽ§åˆ¶åœ¨1å¾®ç§’å†…ï¼Œè¿™ä¸ªæ€§èƒ½æ˜¯å¯æŽ¥å—çš„ã€‚è¿™ä¸ªæ–¹æ³•çš„éš¾ç‚¹æ˜¯å¦‚ä½•å’ŒDoublyBufferedDataç»“åˆã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;æˆ‘ä»¬ä¸è€ƒè™‘ä¸ä½¿ç”¨DoublyBufferedDataï¼Œé‚£æ ·è¦ä¹ˆç»•ä¸å¼€é”ï¼Œè¦ä¹ˆå†™ä¸å‡ºæ­£ç¡®çš„ç®—æ³•ã€‚&lt;/li&gt;
&lt;li&gt;å‰å°åŽå¿…é¡»å…±äº«æƒå€¼æ•°æ®ï¼Œå¦åˆ™åˆ‡æ¢å‰åŽå°æ—¶ï¼Œå‰å°ç§¯ç´¯çš„æƒå€¼æ•°æ®æ²¡æ³•åŒæ­¥åˆ°åŽå°ã€‚&lt;/li&gt;
&lt;li&gt;â€œå·¦å­æ ‘æƒå€¼ä¹‹å’Œâ€ä¹Ÿè¢«å‰åŽå°å…±äº«ï¼Œä½†å’Œæƒå€¼æ•°æ®ä¸åŒï¼Œå®ƒå’Œä½ç½®ç»‘å®šã€‚æ¯”å¦‚æƒå€¼ç»“æž„çš„æŒ‡é’ˆå¯èƒ½ä»Žä½ç½®10ç§»åŠ¨åˆ°ä½ç½®5ï¼Œä½†â€œå·¦å­æ ‘æƒå€¼ä¹‹å’Œâ€çš„æŒ‡é’ˆä¸ä¼šç§»åŠ¨ï¼Œç®—æ³•éœ€è¦ä»ŽåŽŸä½ç½®å‡æŽ‰å·®å€¼ï¼Œè€Œå‘æ–°ä½ç½®åŠ ä¸Šå·®å€¼ã€‚&lt;/li&gt;
&lt;li&gt;æˆ‘ä»¬ä¸è¿½æ±‚ä¸€è‡´æ€§ï¼Œåªè¦æœ€ç»ˆä¸€è‡´å³å¯ï¼Œè¿™èƒ½è®©æˆ‘ä»¬å°‘åŠ é”ã€‚è¿™ä¹Ÿæ„å‘³ç€â€œæƒå€¼ä¹‹å’Œâ€ï¼Œâ€œå·¦å­æ ‘æƒå€¼ä¹‹å’Œâ€ï¼Œâ€œèŠ‚ç‚¹æƒå€¼â€æœªå¿…èƒ½ç²¾ç¡®å»åˆï¼ŒæŸ¥æ‰¾ç®—æ³•è¦èƒ½é€‚åº”è¿™ä¸€ç‚¹ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æœ€å›°éš¾çš„éƒ¨åˆ†æ˜¯å¢žåŠ å’Œåˆ é™¤èŠ‚ç‚¹ï¼Œå®ƒä»¬éœ€è¦åœ¨æ•´ä½“ä¸Šå¯¹å‰å°æŸ¥æ‰¾ä¸é€ æˆä»€ä¹ˆå½±å“ï¼Œè¯¦ç»†è¿‡ç¨‹è¯·å‚è€ƒä»£ç ã€‚&lt;/p&gt;
&lt;h2 id=&#34;base_weight&#34;&gt;base_weight&lt;/h2&gt;
&lt;p&gt;QPSå’Œlatencyä½¿ç”¨ä¸€ä¸ªå¾ªçŽ¯é˜Ÿåˆ—ç»Ÿè®¡ï¼Œé»˜è®¤å®¹é‡128ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¹ˆå°çš„ç»Ÿè®¡çª—å£ï¼Œæ˜¯å› ä¸ºinflight delayèƒ½åŠæ—¶çº æ­£è¿‡åº¦ååº”ï¼Œè€Œ128ä¹Ÿå…·å¤‡äº†ä¸€å®šçš„ç»Ÿè®¡å¯ä¿¡åº¦ã€‚ä¸è¿‡ï¼Œè¿™ä¹ˆè®¡ç®—latencyçš„ç¼ºç‚¹æ˜¯ï¼šå¦‚æžœserverçš„æ€§èƒ½å‡ºçŽ°å¾ˆå¤§çš„å˜åŒ–ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ç§¯ç´¯ä¸€æ®µæ—¶é—´æ‰èƒ½çœ‹åˆ°å¹³å‡å»¶æ—¶çš„å˜åŒ–ã€‚å°±åƒä¸ŠèŠ‚ä¾‹å­ä¸­é‚£æ ·ï¼Œserveråè½¬å»¶æ—¶åŽclientéœ€è¦ç§¯ç´¯å¾ˆå¤šç§’çš„æ•°æ®æ‰èƒ½çœ‹åˆ°çš„å¹³å‡å»¶æ—¶çš„å˜åŒ–ã€‚ç›®å‰æˆ‘ä»¬å¹¶ä¹ˆæœ‰å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºçœŸå®žç”Ÿäº§çŽ¯å¢ƒä¸­çš„serverä¸å¤ªä¼šåƒä¾‹å­ä¸­é‚£æ ·è·³å˜å»¶æ—¶ï¼Œå¤§éƒ½æ˜¯ç¼“ç¼“å˜æ…¢ã€‚å½“é›†ç¾¤æœ‰å‡ ç™¾å°æœºå™¨æ—¶ï¼Œå³ä½¿æˆ‘ä»¬ååº”æ…¢ç‚¹ç»™ä¸ªåˆ«æœºå™¨å°‘åˆ†æµç‚¹ä¹Ÿä¸ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ã€‚å¦‚æžœåœ¨äº§å“çº¿ä¸­ç¡®å®žå‡ºçŽ°äº†æ€§èƒ½è·³å˜ï¼Œå¹¶ä¸”é›†ç¾¤è§„æ¨¡ä¸å¤§ï¼Œæˆ‘ä»¬å†å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚&lt;/p&gt;
&lt;p&gt;æƒå€¼çš„è®¡ç®—æ–¹æ³•æ˜¯base_weight = QPS * WEIGHT_SCALE / latency ^ pã€‚å…¶ä¸­WEIGHT_SCALEæ˜¯ä¸€ä¸ªæ”¾å¤§ç³»æ•°ï¼Œä¸ºäº†èƒ½ç”¨æ•´æ•°å­˜å‚¨æƒå€¼ï¼Œåˆèƒ½è®©æƒå€¼æœ‰è¶³å¤Ÿçš„ç²¾åº¦ï¼Œç±»ä¼¼å®šç‚¹æ•°ã€‚pé»˜è®¤ä¸º2ï¼Œå»¶æ—¶çš„æ”¶æ•›é€Ÿåº¦å¤§çº¦ä¸ºp=1æ—¶çš„på€ï¼Œé€‰é¡¹quadratic_latency=falseå¯ä½¿p=1ã€‚&lt;/p&gt;
&lt;p&gt;æƒå€¼è®¡ç®—åœ¨å„ä¸ªçŽ¯èŠ‚éƒ½æœ‰æœ€å°å€¼é™åˆ¶ï¼Œä¸ºäº†é˜²æ­¢æŸä¸ªèŠ‚ç‚¹çš„æƒå€¼è¿‡ä½Žè€Œä½¿å…¶å®Œå…¨æ²¡æœ‰è®¿é—®æœºä¼šã€‚å³ä½¿ä¸€äº›å»¶æ—¶è¿œå¤§äºŽå¹³å‡å»¶æ—¶çš„èŠ‚ç‚¹ï¼Œä¹Ÿåº”è¯¥æœ‰è¶³å¤Ÿçš„æƒå€¼ï¼Œä»¥ç¡®ä¿å®ƒä»¬å¯ä»¥è¢«å®šæœŸè®¿é—®ï¼Œå¦åˆ™å³ä½¿å®ƒä»¬å˜å¿«äº†ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šçŸ¥é“ã€‚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;é™¤äº†å¾…åˆ é™¤èŠ‚ç‚¹ï¼Œæ‰€æœ‰èŠ‚ç‚¹çš„æƒå€¼ç»å¯¹ä¸ä¼šä¸º0ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;è¿™ä¹Ÿåˆ¶é€ äº†ä¸€ä¸ªé—®é¢˜ï¼šå³ä½¿ä¸€ä¸ªserveréžå¸¸ç¼“æ…¢ï¼ˆä½†æ²¡æœ‰æ–­å¼€è¿žæŽ¥ï¼‰ï¼Œå®ƒçš„æƒå€¼ä¹Ÿä¸ä¼šä¸º0ï¼Œæ‰€ä»¥æ€»ä¼šæœ‰ä¸€äº›è¯·æ±‚è¢«å®šæœŸé€è¿‡åŽ»è€Œé“å®šè¶…æ—¶ã€‚å½“qpsä¸é«˜æ—¶ï¼Œä¸ºäº†é™ä½Žå½±å“é¢ï¼ŒæŽ¢æµ‹é—´éš”å¿…é¡»æ‹‰é•¿ã€‚æ¯”å¦‚ä¸ºäº†æŠŠå¯¹qps=1000çš„å½±å“æŽ§åˆ¶åœ¨1%%å†…ï¼Œæ•…éšœserverçš„æƒå€¼å¿…é¡»ä½Žè‡³ä½¿å…¶æŽ¢æµ‹é—´éš”ä¸º10ç§’ä»¥ä¸Šï¼Œè¿™é™ä½Žäº†æˆ‘ä»¬å‘çŽ°serverå˜å¿«çš„é€Ÿåº¦ã€‚è¿™ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ³•æœ‰ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä»€ä¹ˆéƒ½ä¸å¹²ã€‚è¿™ä¸ªé—®é¢˜ä¹Ÿè®¸æ²¡æœ‰æƒ³è±¡ä¸­é‚£ä¹ˆä¸¥é‡ï¼Œç”±äºŽæŒç»­çš„èµ„æºç›‘æŽ§ï¼Œçº¿ä¸ŠæœåŠ¡å¾ˆå°‘å‡ºçŽ°â€œéžå¸¸ç¼“æ…¢â€çš„æƒ…å†µï¼Œä¸€èˆ¬æ€§çš„å˜æ…¢å¹¶ä¸ä¼šå¯¼è‡´è¯·æ±‚è¶…æ—¶ã€‚&lt;/li&gt;
&lt;li&gt;ä¿å­˜ä¸€äº›æ›¾ç»å‘å‘ç¼“æ…¢serverçš„è¯·æ±‚ï¼Œç”¨è¿™äº›è¯·æ±‚æŽ¢æµ‹ã€‚è¿™ä¸ªåŠžæ³•çš„å¥½å¤„æ˜¯ä¸æµªè´¹è¯·æ±‚ã€‚ä½†å®žçŽ°èµ·æ¥è€¦åˆå¾ˆå¤šï¼Œæ¯”è¾ƒéº»çƒ¦ã€‚&lt;/li&gt;
&lt;li&gt;å¼ºåˆ¶backup requestã€‚&lt;/li&gt;
&lt;li&gt;å†é€‰ä¸€æ¬¡ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;inflight-delay&#34;&gt;inflight delay&lt;/h2&gt;
&lt;p&gt;æˆ‘ä»¬å¿…é¡»è¿½è¸ªè¿˜æœªç»“æŸçš„RPCï¼Œå¦åˆ™æˆ‘ä»¬å°±å¿…é¡»ç­‰å¾…åˆ°è¶…æ—¶æˆ–å…¶ä»–é”™è¯¯å‘ç”Ÿï¼Œè€Œè¿™å¯èƒ½ä¼šå¾ˆæ…¢ï¼ˆè¶…æ—¶ä¸€èˆ¬ä¼šæ˜¯æ­£å¸¸å»¶æ—¶çš„è‹¥å¹²å€ï¼‰ï¼Œåœ¨è¿™æ®µæ—¶é—´å†…æˆ‘ä»¬å¯èƒ½åšå‡ºäº†å¾ˆå¤šé”™è¯¯çš„åˆ†æµã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯ç»Ÿè®¡æœªç»“æŸRPCçš„è€—æ—¶ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;é€‰æ‹©serveræ—¶ç´¯åŠ å‘å‡ºæ—¶é—´å’Œæœªç»“æŸæ¬¡æ•°ã€‚&lt;/li&gt;
&lt;li&gt;åé¦ˆæ—¶æ‰£é™¤å‘å‡ºæ—¶é—´å’Œæœªç»“æŸæ¬¡æ•°ã€‚&lt;/li&gt;
&lt;li&gt;æ¡†æž¶ä¿è¯æ¯ä¸ªé€‰æ‹©æ€»å¯¹åº”ä¸€æ¬¡åé¦ˆã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™æ ·â€œå½“å‰æ—¶é—´ - å‘å‡ºæ—¶é—´ä¹‹å’Œ / æœªç»“æŸæ¬¡æ•°â€ä¾¿æ˜¯æœªç»“æŸRPCçš„å¹³å‡è€—æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºinflight delayã€‚å½“inflight delayå¤§äºŽå¹³å‡å»¶æ—¶æ—¶ï¼Œæˆ‘ä»¬å°±çº¿æ€§åœ°æƒ©ç½šèŠ‚ç‚¹æƒå€¼ï¼Œå³weight = base_weight * avg_latency / inflight_delayã€‚å½“å‘å‘ä¸€ä¸ªèŠ‚ç‚¹çš„è¯·æ±‚æ²¡æœ‰åœ¨å¹³å‡å»¶æ—¶å†…å›žæ¥æ—¶ï¼Œå®ƒçš„æƒå€¼å°±ä¼šå¾ˆå¿«ä¸‹é™ï¼Œä»Žè€Œçº æ­£æˆ‘ä»¬çš„è¡Œä¸ºï¼Œè¿™æ¯”ç­‰å¾…è¶…æ—¶å¿«å¤šäº†ã€‚ä¸è¿‡è¿™æ²¡æœ‰è€ƒè™‘å»¶æ—¶çš„æ­£å¸¸æŠ–åŠ¨ï¼Œæˆ‘ä»¬è¿˜å¾—æœ‰æ–¹å·®ï¼Œæ–¹å·®å¯ä»¥æ¥è‡ªç»Ÿè®¡ï¼Œä¹Ÿå¯ç®€å•çº¿æ€§äºŽå¹³å‡å»¶æ—¶ã€‚ä¸ç®¡æ€Žæ ·ï¼Œæœ‰äº†æ–¹å·®boundåŽï¼Œå½“inflight delay &amp;gt; avg_latency + max(bound * 3, MIN_BOUND)æ—¶æ‰ä¼šæƒ©ç½šæƒå€¼ã€‚3æ˜¯æ­£æ€åˆ†å¸ƒä¸­çš„ç»éªŒæ•°å€¼ã€‚&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Consistent Hashing</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/consistent-hashing/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/consistent-hashing/</guid>
      <description>
        
        
        &lt;h1 id=&#34;æ¦‚è¿°&#34;&gt;æ¦‚è¿°&lt;/h1&gt;
&lt;p&gt;ä¸€äº›åœºæ™¯å¸Œæœ›åŒæ ·çš„è¯·æ±‚å°½é‡è½åˆ°ä¸€å°æœºå™¨ä¸Šï¼Œæ¯”å¦‚è®¿é—®ç¼“å­˜é›†ç¾¤æ—¶ï¼Œæˆ‘ä»¬å¾€å¾€å¸Œæœ›åŒä¸€ç§è¯·æ±‚èƒ½è½åˆ°åŒä¸€ä¸ªåŽç«¯ä¸Šï¼Œä»¥å……åˆ†åˆ©ç”¨å…¶ä¸Šå·²æœ‰çš„ç¼“å­˜ï¼Œä¸åŒçš„æœºå™¨æ‰¿è½½ä¸åŒçš„ç¨³å®šworking setã€‚è€Œä¸æ˜¯éšæœºåœ°æ•£è½åˆ°æ‰€æœ‰æœºå™¨ä¸Šï¼Œé‚£æ ·çš„è¯ä¼šè¿«ä½¿æ‰€æœ‰æœºå™¨ç¼“å­˜æ‰€æœ‰çš„å†…å®¹ï¼Œæœ€ç»ˆç”±äºŽå­˜ä¸ä¸‹å½¢æˆé¢ ç°¸è€Œè¡¨çŽ°ç³Ÿç³•ã€‚ æˆ‘ä»¬éƒ½çŸ¥é“hashèƒ½æ»¡è¶³è¿™ä¸ªè¦æ±‚ï¼Œæ¯”å¦‚å½“æœ‰nå°æœåŠ¡å™¨æ—¶ï¼Œè¾“å…¥xæ€»æ˜¯ä¼šå‘é€åˆ°ç¬¬hash(x) % nå°æœåŠ¡å™¨ä¸Šã€‚ä½†å½“æœåŠ¡å™¨å˜ä¸ºmå°æ—¶ï¼Œhash(x) % nå’Œhash(x) % må¾ˆå¯èƒ½éƒ½ä¸ç›¸ç­‰ï¼Œè¿™ä¼šä½¿å¾—å‡ ä¹Žæ‰€æœ‰è¯·æ±‚çš„å‘é€ç›®çš„åœ°éƒ½å‘ç”Ÿå˜åŒ–ï¼Œå¦‚æžœç›®çš„åœ°æ˜¯ç¼“å­˜æœåŠ¡ï¼Œæ‰€æœ‰ç¼“å­˜å°†å¤±æ•ˆï¼Œç»§è€Œå¯¹åŽŸæœ¬è¢«ç¼“å­˜é®æŒ¡çš„æ•°æ®åº“æˆ–è®¡ç®—æœåŠ¡é€ æˆè¯·æ±‚é£Žæš´ï¼Œè§¦å‘é›ªå´©ã€‚ä¸€è‡´æ€§å“ˆå¸Œæ˜¯ä¸€ç§ç‰¹æ®Šçš„å“ˆå¸Œç®—æ³•ï¼Œåœ¨å¢žåŠ æœåŠ¡å™¨æ—¶ï¼Œå‘å‘æ¯ä¸ªè€èŠ‚ç‚¹çš„è¯·æ±‚ä¸­åªä¼šæœ‰ä¸€éƒ¨åˆ†è½¬å‘æ–°èŠ‚ç‚¹ï¼Œä»Žè€Œå®žçŽ°å¹³æ»‘çš„è¿ç§»ã€‚&lt;a href=&#34;http://blog.phpdr.net/wp-content/uploads/2012/08/Consistent-Hashing-and-Random-Trees.pdf&#34;&gt;è¿™ç¯‡è®ºæ–‡&lt;/a&gt;ä¸­æå‡ºäº†ä¸€è‡´æ€§hashçš„æ¦‚å¿µã€‚&lt;/p&gt;
&lt;p&gt;ä¸€è‡´æ€§hashæ»¡è¶³ä»¥ä¸‹å››ä¸ªæ€§è´¨ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¹³è¡¡æ€§ (Balance) : æ¯ä¸ªèŠ‚ç‚¹è¢«é€‰åˆ°çš„æ¦‚çŽ‡æ˜¯O(1/n)ã€‚&lt;/li&gt;
&lt;li&gt;å•è°ƒæ€§ (Monotonicity) : å½“æ–°èŠ‚ç‚¹åŠ å…¥æ—¶ï¼Œ ä¸ä¼šæœ‰è¯·æ±‚åœ¨è€èŠ‚ç‚¹é—´ç§»åŠ¨ï¼Œ åªä¼šä»Žè€èŠ‚ç‚¹ç§»åŠ¨åˆ°æ–°èŠ‚ç‚¹ã€‚å½“æœ‰èŠ‚ç‚¹è¢«åˆ é™¤æ—¶ï¼Œä¹Ÿä¸ä¼šå½±å“è½åœ¨åˆ«çš„èŠ‚ç‚¹ä¸Šçš„è¯·æ±‚ã€‚&lt;/li&gt;
&lt;li&gt;åˆ†æ•£æ€§ (Spread) : å½“ä¸Šæ¸¸çš„æœºå™¨çœ‹åˆ°ä¸åŒçš„ä¸‹æ¸¸åˆ—è¡¨æ—¶(åœ¨ä¸Šçº¿æ—¶åŠä¸ç¨³å®šçš„ç½‘ç»œä¸­æ¯”è¾ƒå¸¸è§),  åŒä¸€ä¸ªè¯·æ±‚å°½é‡æ˜ å°„åˆ°å°‘é‡çš„èŠ‚ç‚¹ä¸­ã€‚&lt;/li&gt;
&lt;li&gt;è´Ÿè½½ (Load) : å½“ä¸Šæ¸¸çš„æœºå™¨çœ‹åˆ°ä¸åŒçš„ä¸‹æ¸¸åˆ—è¡¨çš„æ—¶å€™ï¼Œ ä¿è¯æ¯å°ä¸‹æ¸¸åˆ†åˆ°çš„è¯·æ±‚æ•°é‡å°½é‡ä¸€è‡´ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;å®žçŽ°æ–¹å¼&#34;&gt;å®žçŽ°æ–¹å¼&lt;/h1&gt;
&lt;p&gt;æ‰€æœ‰serverçš„32ä½hashå€¼åœ¨32ä½æ•´æ•°å€¼åŸŸä¸Šæž„æˆä¸€ä¸ªçŽ¯(Hash Ring)ï¼ŒçŽ¯ä¸Šçš„æ¯ä¸ªåŒºé—´å’Œä¸€ä¸ªserverå”¯ä¸€å¯¹åº”ï¼Œå¦‚æžœä¸€ä¸ªkeyè½åœ¨æŸä¸ªåŒºé—´å†…ï¼Œ å®ƒå°±è¢«åˆ†æµåˆ°å¯¹åº”çš„serverä¸Šã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/chash.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;å½“åˆ é™¤ä¸€ä¸ªserverçš„ï¼Œå®ƒå¯¹åº”çš„åŒºé—´ä¼šå½’å±žäºŽç›¸é‚»çš„serverï¼Œæ‰€æœ‰çš„è¯·æ±‚éƒ½ä¼šè·‘è¿‡åŽ»ã€‚å½“å¢žåŠ ä¸€ä¸ªserveræ—¶ï¼Œå®ƒä¼šåˆ†å‰²æŸä¸ªserverçš„åŒºé—´å¹¶æ‰¿è½½è½åœ¨è¿™ä¸ªåŒºé—´ä¸Šçš„æ‰€æœ‰è¯·æ±‚ã€‚å•çº¯ä½¿ç”¨Hash Ringå¾ˆéš¾æ»¡è¶³æˆ‘ä»¬ä¸ŠèŠ‚æåˆ°çš„å±žæ€§ï¼Œä¸»è¦ä¸¤ä¸ªé—®é¢˜ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨æœºå™¨æ•°é‡è¾ƒå°‘çš„æ—¶å€™ï¼Œ åŒºé—´å¤§å°ä¼šä¸å¹³è¡¡ã€‚&lt;/li&gt;
&lt;li&gt;å½“ä¸€å°æœºå™¨æ•…éšœçš„æ—¶å€™ï¼Œ å®ƒçš„åŽ‹åŠ›ä¼šå®Œå…¨è½¬ç§»åˆ°å¦å¤–ä¸€å°æœºå™¨ï¼Œ å¯èƒ½æ— æ³•æ‰¿è½½ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªserverè®¡ç®—mä¸ªhashå€¼ï¼Œä»Žè€ŒæŠŠ32ä½æ•´æ•°å€¼åŸŸåˆ’åˆ†ä¸ºn*mä¸ªåŒºé—´ï¼Œå½“keyè½åˆ°æŸä¸ªåŒºé—´æ—¶ï¼Œåˆ†æµåˆ°å¯¹åº”çš„serverä¸Šã€‚é‚£äº›é¢å¤–çš„hashå€¼ä½¿å¾—åŒºé—´åˆ’åˆ†æ›´åŠ å‡åŒ€ï¼Œè¢«ç§°ä¸ºè™šæ‹ŸèŠ‚ç‚¹ï¼ˆVirtual Nodeï¼‰ã€‚å½“åˆ é™¤ä¸€ä¸ªserveræ—¶ï¼Œå®ƒå¯¹åº”çš„mä¸ªåŒºé—´ä¼šåˆ†åˆ«åˆå…¥ç›¸é‚»çš„åŒºé—´ä¸­ï¼Œé‚£ä¸ªserverä¸Šçš„è¯·æ±‚ä¼šè¾ƒä¸ºå¹³å‡åœ°è½¬ç§»åˆ°å…¶ä»–serverä¸Šã€‚å½“å¢žåŠ serveræ—¶ï¼Œå®ƒä¼šåˆ†å‰²mä¸ªçŽ°æœ‰åŒºé—´ï¼Œä»Žå¯¹åº”serverä¸Šåˆ†åˆ«è½¬ç§»ä¸€äº›è¯·æ±‚è¿‡æ¥ã€‚&lt;/p&gt;
&lt;p&gt;ç”±äºŽèŠ‚ç‚¹æ•…éšœå’Œå˜åŒ–ä¸å¸¸å‘ç”Ÿï¼Œæˆ‘ä»¬é€‰æ‹©äº†ä¿®æ”¹å¤æ‚åº¦ä¸ºO(n)çš„æœ‰åºæ•°ç»„æ¥å­˜å‚¨hash ringï¼Œæ¯æ¬¡åˆ†æµä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥é€‰æ‹©å¯¹åº”çš„æœºå™¨ï¼Œç”±äºŽå­˜å‚¨æ˜¯è¿žç»­çš„ï¼ŒæŸ¥æ‰¾æ•ˆçŽ‡æ¯”åŸºäºŽå¹³è¡¡äºŒå‰æ ‘çš„å®žçŽ°é«˜ã€‚çº¿ç¨‹å®‰å…¨æ€§è¯·å‚ç…§&lt;a href=&#34;../locality-aware/#doublybuffereddata&#34;&gt;Double Buffered Data&lt;/a&gt;ç« èŠ‚.&lt;/p&gt;
&lt;h1 id=&#34;ä½¿ç”¨æ–¹å¼&#34;&gt;ä½¿ç”¨æ–¹å¼&lt;/h1&gt;
&lt;p&gt;æˆ‘ä»¬å†…ç½®äº†åˆ†åˆ«åŸºäºŽmurmurhash3å’Œmd5ä¸¤ç§hashç®—æ³•çš„å®žçŽ°ï¼Œä½¿ç”¨è¦åšä¸¤ä»¶äº‹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨Channel.Init æ—¶æŒ‡å®š&lt;em&gt;load_balancer_name&lt;/em&gt;ä¸º &amp;ldquo;c_murmurhash&amp;rdquo; æˆ– &amp;ldquo;c_md5&amp;rdquo;ã€‚&lt;/li&gt;
&lt;li&gt;å‘èµ·rpcæ—¶é€šè¿‡Controller::set_request_code(uint64_t)å¡«å…¥è¯·æ±‚çš„hash codeã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;requestçš„hashç®—æ³•å¹¶ä¸éœ€è¦å’Œlbçš„hashç®—æ³•ä¿æŒä¸€è‡´ï¼Œåªéœ€è¦hashçš„å€¼åŸŸæ˜¯32ä½æ— ç¬¦å·æ•´æ•°ã€‚ç”±äºŽmemcacheé»˜è®¤ä½¿ç”¨md5ï¼Œè®¿é—®memcachedé›†ç¾¤æ—¶è¯·é€‰æ‹©c_md5ä¿è¯å…¼å®¹æ€§ï¼Œå…¶ä»–åœºæ™¯å¯ä»¥é€‰æ‹©c_murmurhashä»¥èŽ·å¾—æ›´é«˜çš„æ€§èƒ½å’Œæ›´å‡åŒ€çš„åˆ†å¸ƒã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;è™šæ‹ŸèŠ‚ç‚¹ä¸ªæ•°&#34;&gt;è™šæ‹ŸèŠ‚ç‚¹ä¸ªæ•°&lt;/h1&gt;
&lt;p&gt;é€šè¿‡-chash_num_replicaså¯è®¾ç½®é»˜è®¤çš„è™šæ‹ŸèŠ‚ç‚¹ä¸ªæ•°ï¼Œé»˜è®¤å€¼ä¸º100ã€‚å¯¹äºŽæŸäº›ç‰¹æ®Šåœºåˆï¼Œå¯¹è™šæ‹ŸèŠ‚ç‚¹ä¸ªæ•°æœ‰è‡ªå®šä¹‰çš„éœ€æ±‚ï¼Œå¯ä»¥é€šè¿‡å°†&lt;em&gt;load_balancer_name&lt;/em&gt;åŠ ä¸Šå‚æ•°replicas=&lt;num&gt;é…ç½®ï¼Œå¦‚ï¼š&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;channel&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Init&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;http://...&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;c_murmurhash:replicas=150&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;options&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Memory Management</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/memory-management/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/memory-management/</guid>
      <description>
        
        
        &lt;p&gt;å†…å­˜ç®¡ç†æ€»æ˜¯ç¨‹åºä¸­çš„é‡è¦ä¸€çŽ¯ï¼Œåœ¨å¤šçº¿ç¨‹æ—¶ä»£ï¼Œä¸€ä¸ªå¥½çš„å†…å­˜åˆ†é…å¤§éƒ½åœ¨å¦‚ä¸‹ä¸¤ç‚¹é—´æƒè¡¡ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;çº¿ç¨‹é—´ç«žäº‰å°‘ã€‚å†…å­˜åˆ†é…çš„ç²’åº¦å¤§éƒ½æ¯”è¾ƒå°ï¼Œå¯¹æ€§èƒ½æ•æ„Ÿï¼Œå¦‚æžœä¸åŒçš„çº¿ç¨‹åœ¨å¤§å¤šæ•°åˆ†é…æ—¶ä¼šç«žäº‰åŒä¸€ä»½èµ„æºæˆ–åŒä¸€æŠŠé”ï¼Œæ€§èƒ½å°†ä¼šéžå¸¸ç³Ÿç³•ï¼ŒåŽŸå› æ— å¤–ä¹Žå’Œcacheä¸€è‡´æ€§æœ‰å…³ï¼Œå·²è¢«å¤§é‡çš„mallocæ–¹æ¡ˆè¯æ˜Žã€‚&lt;/li&gt;
&lt;li&gt;æµªè´¹çš„ç©ºé—´å°‘ã€‚å¦‚æžœæ¯ä¸ªçº¿ç¨‹å„ç”³è¯·å„çš„ï¼Œé€Ÿåº¦ä¹Ÿè®¸ä¸é”™ï¼Œä½†ä¸‡ä¸€ä¸€ä¸ªçº¿ç¨‹æ€»æ˜¯ç”³è¯·ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹æ€»æ˜¯é‡Šæ”¾ï¼Œå†…å­˜å°±çˆ†ç‚¸äº†ã€‚çº¿ç¨‹ä¹‹é—´æ€»æ˜¯è¦å…±äº«å†…å­˜çš„ï¼Œå¦‚ä½•å…±äº«å°±æ˜¯æ–¹æ¡ˆçš„å…³é”®äº†ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸€èˆ¬çš„åº”ç”¨å¯ä»¥ä½¿ç”¨&lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;tcmalloc&lt;/a&gt;ã€&lt;a href=&#34;https://github.com/jemalloc/jemalloc&#34;&gt;jemalloc&lt;/a&gt;ç­‰æˆç†Ÿçš„å†…å­˜åˆ†é…æ–¹æ¡ˆï¼Œä½†è¿™å¯¹äºŽè¾ƒä¸ºåº•å±‚ï¼Œå…³æ³¨æ€§èƒ½é•¿å°¾çš„åº”ç”¨æ˜¯ä¸å¤Ÿçš„ã€‚å¤šçº¿ç¨‹æ¡†æž¶å¹¿æ³›åœ°é€šè¿‡ä¼ é€’å¯¹è±¡çš„ownershipæ¥è®©é—®é¢˜å¼‚æ­¥åŒ–ï¼Œå¦‚ä½•è®©åˆ†é…è¿™äº›å°å¯¹è±¡çš„å¼€é”€å˜çš„æ›´å°æ˜¯å€¼å¾—ç ”ç©¶çš„é—®é¢˜ã€‚å…¶ä¸­çš„ä¸€ä¸ªç‰¹ç‚¹è¾ƒä¸ºæ˜¾è‘—ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å¤§å¤šæ•°ç»“æž„æ˜¯ç­‰é•¿çš„ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™ä¸ªå±žæ€§å¯ä»¥å¤§å¹…ç®€åŒ–å†…å­˜åˆ†é…çš„è¿‡ç¨‹ï¼ŒèŽ·å¾—æ¯”é€šç”¨mallocæ›´ç¨³å®šã€å¿«é€Ÿçš„æ€§èƒ½ã€‚brpcä¸­çš„ResourcePool&lt;T&gt;å’ŒObjectPool&lt;T&gt;å³æä¾›è¿™ç±»åˆ†é…ã€‚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;è¿™ç¯‡æ–‡ç« ä¸é¼“åŠ±ç”¨æˆ·ä½¿ç”¨ResourcePool&lt;T&gt;æˆ–ObjectPool&lt;T&gt;ï¼Œäº‹å®žä¸Šæˆ‘ä»¬åå¯¹ç”¨æˆ·åœ¨ç¨‹åºä¸­ä½¿ç”¨è¿™ä¸¤ä¸ªç±»ã€‚å› ä¸ºâ€ç­‰é•¿â€œçš„å‰¯ä½œç”¨æ˜¯æŸä¸ªç±»åž‹ç‹¬å äº†ä¸€éƒ¨åˆ†å†…å­˜ï¼Œè¿™äº›å†…å­˜æ— æ³•å†è¢«å…¶ä»–ç±»åž‹ä½¿ç”¨ï¼Œå¦‚æžœä¸åŠ æŽ§åˆ¶çš„æ»¥ç”¨ï¼Œåè€Œä¼šåœ¨ç¨‹åºä¸­äº§ç”Ÿå¤§é‡å½¼æ­¤éš”ç¦»çš„å†…å­˜åˆ†é…ä½“ç³»ï¼Œæ—¢æµªè´¹å†…å­˜ä¹Ÿä¸è§å¾—ä¼šæœ‰æ›´å¥½çš„æ€§èƒ½ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;resourcepoolt&#34;&gt;ResourcePool&lt;T&gt;&lt;/h1&gt;
&lt;p&gt;åˆ›å»ºä¸€ä¸ªç±»åž‹ä¸ºTçš„å¯¹è±¡å¹¶è¿”å›žä¸€ä¸ªåç§»é‡ï¼Œè¿™ä¸ªåç§»é‡å¯ä»¥åœ¨O(1)æ—¶é—´å†…è½¬æ¢ä¸ºå¯¹è±¡æŒ‡é’ˆã€‚è¿™ä¸ªåç§»é‡ç›¸å½“äºŽæŒ‡é’ˆï¼Œä½†å®ƒçš„å€¼åœ¨ä¸€èˆ¬æƒ…å†µä¸‹å°äºŽ2^32ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠå®ƒä½œä¸º64ä½idçš„ä¸€éƒ¨åˆ†ã€‚å¯¹è±¡å¯ä»¥è¢«å½’è¿˜ï¼Œä½†å½’è¿˜åŽå¯¹è±¡å¹¶æ²¡æœ‰åˆ é™¤ï¼Œä¹Ÿæ²¡æœ‰è¢«æžæž„ï¼Œè€Œæ˜¯ä»…ä»…è¿›å…¥freelistã€‚ä¸‹æ¬¡ç”³è¯·æ—¶å¯èƒ½ä¼šå–åˆ°è¿™ç§ä½¿ç”¨è¿‡çš„å¯¹è±¡ï¼Œéœ€è¦é‡ç½®åŽæ‰èƒ½ä½¿ç”¨ã€‚å½“å¯¹è±¡è¢«å½’è¿˜åŽï¼Œé€šè¿‡å¯¹åº”çš„åç§»é‡ä»å¯ä»¥è®¿é—®åˆ°å¯¹è±¡ï¼Œå³ResourcePoolåªè´Ÿè´£å†…å­˜åˆ†é…ï¼Œå¹¶ä¸è§£å†³ABAé—®é¢˜ã€‚ä½†å¯¹äºŽè¶Šç•Œçš„åç§»é‡ï¼ŒResourcePoolä¼šè¿”å›žç©ºã€‚&lt;/p&gt;
&lt;p&gt;ç”±äºŽå¯¹è±¡ç­‰é•¿ï¼ŒResourcePoolé€šè¿‡æ‰¹é‡åˆ†é…å’Œå½’è¿˜å†…å­˜ä»¥é¿å…å…¨å±€ç«žäº‰ï¼Œå¹¶é™ä½Žå•æ¬¡çš„å¼€é”€ã€‚æ¯ä¸ªçº¿ç¨‹çš„åˆ†é…æµç¨‹å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;æŸ¥çœ‹thread-local free blockã€‚å¦‚æžœè¿˜æœ‰freeçš„å¯¹è±¡ï¼Œè¿”å›žã€‚æ²¡æœ‰çš„è¯æ­¥éª¤2ã€‚&lt;/li&gt;
&lt;li&gt;å°è¯•ä»Žå…¨å±€å–ä¸€ä¸ªfree blockï¼Œè‹¥å–åˆ°çš„è¯å›žåˆ°æ­¥éª¤1ï¼Œå¦åˆ™æ­¥éª¤3ã€‚&lt;/li&gt;
&lt;li&gt;ä»Žå…¨å±€å–ä¸€ä¸ªblockï¼Œè¿”å›žå…¶ä¸­ç¬¬ä¸€ä¸ªå¯¹è±¡ã€‚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;åŽŸç†æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚å·¥ç¨‹å®žçŽ°ä¸Šæ•°æ®ç»“æž„ã€åŽŸå­å˜é‡ã€memory fenceç­‰é—®é¢˜ä¼šå¤æ‚ä¸€äº›ã€‚ä¸‹é¢ä»¥bthread_tçš„ç”Ÿæˆè¿‡ç¨‹è¯´æ˜ŽResourcePoolæ˜¯å¦‚ä½•è¢«åº”ç”¨çš„ã€‚&lt;/p&gt;
&lt;h1 id=&#34;objectpoolt&#34;&gt;ObjectPool&lt;T&gt;&lt;/h1&gt;
&lt;p&gt;è¿™æ˜¯ResourcePool&lt;T&gt;çš„å˜ç§ï¼Œä¸è¿”å›žåç§»é‡ï¼Œè€Œç›´æŽ¥è¿”å›žå¯¹è±¡æŒ‡é’ˆã€‚å†…éƒ¨ç»“æž„å’ŒResourcePoolç±»ä¼¼ï¼Œä¸€äº›ä»£ç æ›´åŠ ç®€å•ã€‚å¯¹äºŽç”¨æˆ·æ¥è¯´ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªå¤šçº¿ç¨‹ä¸‹çš„å¯¹è±¡æ± ï¼Œbrpcé‡Œä¹Ÿæ˜¯è¿™ä¹ˆç”¨çš„ã€‚æ¯”å¦‚Socket::Writeä¸­æŠŠæ¯ä¸ªå¾…å†™å‡ºçš„è¯·æ±‚åŒ…è£…ä¸ºWriteRequestï¼Œè¿™ä¸ªå¯¹è±¡å°±æ˜¯ç”¨ObjectPool&lt;WriteRequest&gt;åˆ†é…çš„ã€‚&lt;/p&gt;
&lt;h1 id=&#34;ç”Ÿæˆbthread_t&#34;&gt;ç”Ÿæˆbthread_t&lt;/h1&gt;
&lt;p&gt;ç”¨æˆ·æœŸæœ›é€šè¿‡åˆ›å»ºbthreadèŽ·å¾—æ›´é«˜çš„å¹¶å‘åº¦ï¼Œæ‰€ä»¥åˆ›å»ºbthreadå¿…é¡»å¾ˆå¿«ã€‚ åœ¨ç›®å‰çš„å®žçŽ°ä¸­åˆ›å»ºä¸€ä¸ªbthreadçš„å¹³å‡è€—æ—¶å°äºŽ200nsã€‚å¦‚æžœæ¯æ¬¡éƒ½è¦ä»Žå¤´åˆ›å»ºï¼Œæ˜¯ä¸å¯èƒ½è¿™ä¹ˆå¿«çš„ã€‚åˆ›å»ºè¿‡ç¨‹æ›´åƒæ˜¯ä»Žä¸€ä¸ªbthreadæ± å­ä¸­å–ä¸€ä¸ªå®žä¾‹ï¼Œæˆ‘ä»¬åˆåŒæ—¶éœ€è¦ä¸€ä¸ªidæ¥æŒ‡ä»£ä¸€ä¸ªbthreadï¼Œæ‰€ä»¥è¿™å„¿æ­£æ˜¯ResourcePoolçš„ç”¨æ­¦ä¹‹åœ°ã€‚bthreadåœ¨ä»£ç ä¸­è¢«ç§°ä½œTaskï¼Œå…¶ç»“æž„è¢«ç§°ä¸ºTaskMetaï¼Œå®šä¹‰åœ¨&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/bthread/task_meta.h&#34;&gt;task_meta.h&lt;/a&gt;ä¸­ï¼Œæ‰€æœ‰çš„TaskMetaç”±ResourcePool&lt;TaskMeta&gt;åˆ†é…ã€‚&lt;/p&gt;
&lt;p&gt;bthreadçš„å¤§éƒ¨åˆ†å‡½æ•°éƒ½éœ€è¦åœ¨O(1)æ—¶é—´å†…é€šè¿‡bthread_tè®¿é—®åˆ°TaskMetaï¼Œå¹¶ä¸”å½“bthread_tå¤±æ•ˆåŽï¼Œè®¿é—®åº”è¿”å›žNULLä»¥è®©å‡½æ•°åšå‡ºè¿”å›žé”™è¯¯ã€‚è§£å†³æ–¹æ³•æ˜¯ï¼šbthread_tç”±32ä½çš„ç‰ˆæœ¬å’Œ32ä½çš„åç§»é‡ç»„æˆã€‚ç‰ˆæœ¬è§£å†³&lt;a href=&#34;http://en.wikipedia.org/wiki/ABA_problem&#34;&gt;ABAé—®é¢˜&lt;/a&gt;ï¼Œåç§»é‡ç”±ResourcePool&lt;TaskMeta&gt;åˆ†é…ã€‚æŸ¥æ‰¾æ—¶å…ˆé€šè¿‡åç§»é‡èŽ·å¾—TaskMetaï¼Œå†æ£€æŸ¥ç‰ˆæœ¬ï¼Œå¦‚æžœç‰ˆæœ¬ä¸åŒ¹é…ï¼Œè¯´æ˜Žbthreadå¤±æ•ˆäº†ã€‚æ³¨æ„ï¼šè¿™åªæ˜¯å¤§æ¦‚çš„è¯´æ³•ï¼Œåœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸‹ï¼Œå³ä½¿ç‰ˆæœ¬ç›¸ç­‰ï¼Œbthreadä»å¯èƒ½éšæ—¶å¤±æ•ˆï¼Œåœ¨ä¸åŒçš„bthreadå‡½æ•°ä¸­å¤„ç†æ–¹æ³•éƒ½æ˜¯ä¸åŒçš„ï¼Œæœ‰äº›å‡½æ•°ä¼šåŠ é”ï¼Œæœ‰äº›åˆ™èƒ½å¿å—ç‰ˆæœ¬ä¸ç›¸ç­‰ã€‚&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://brpc.incubator.apache.org/images/docs/resource_pool.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;è¿™ç§idç”Ÿæˆæ–¹å¼åœ¨brpcä¸­åº”ç”¨å¹¿æ³›ï¼Œbrpcä¸­çš„SocketIdï¼Œbthread_id_tä¹Ÿæ˜¯ç”¨ç±»ä¼¼çš„æ–¹æ³•åˆ†é…çš„ã€‚&lt;/p&gt;
&lt;h1 id=&#34;æ ˆ&#34;&gt;æ ˆ&lt;/h1&gt;
&lt;p&gt;ä½¿ç”¨ResourcePoolåŠ å¿«åˆ›å»ºçš„å‰¯ä½œç”¨æ˜¯ï¼šä¸€ä¸ªpoolä¸­æ‰€æœ‰bthreadçš„æ ˆå¿…é¡»æ˜¯ä¸€æ ·å¤§çš„ã€‚è¿™ä¼¼ä¹Žé™åˆ¶äº†ç”¨æˆ·çš„é€‰æ‹©ï¼Œä¸è¿‡åŸºäºŽæˆ‘ä»¬çš„è§‚å¯Ÿï¼Œå¤§éƒ¨åˆ†ç”¨æˆ·å¹¶ä¸å…³å¿ƒæ ˆçš„å…·ä½“å¤§å°ï¼Œè€Œåªéœ€è¦ä¸¤ç§å¤§å°çš„æ ˆï¼šå°ºå¯¸æ™®é€šä½†æ•°é‡è¾ƒå°‘ï¼Œå°ºå¯¸å°ä½†æ•°é‡ä¼—å¤šã€‚æ‰€ä»¥æˆ‘ä»¬ç”¨ä¸åŒçš„poolç®¡ç†ä¸åŒå¤§å°çš„æ ˆï¼Œç”¨æˆ·å¯ä»¥æ ¹æ®åœºæ™¯é€‰æ‹©ã€‚ä¸¤ç§æ ˆåˆ†åˆ«å¯¹åº”å±žæ€§BTHREAD_ATTR_NORMALï¼ˆæ ˆé»˜è®¤ä¸º1Mï¼‰å’ŒBTHREAD_ATTR_SMALLï¼ˆæ ˆé»˜è®¤ä¸º32Kï¼‰ã€‚ç”¨æˆ·è¿˜å¯ä»¥æŒ‡å®šBTHREAD_ATTR_LARGEï¼Œè¿™ä¸ªå±žæ€§çš„æ ˆå¤§å°å’Œpthreadä¸€æ ·ï¼Œç”±äºŽå°ºå¯¸è¾ƒå¤§ï¼Œbthreadä¸ä¼šå¯¹å…¶åšcachingï¼Œåˆ›å»ºé€Ÿåº¦è¾ƒæ…¢ã€‚serveré»˜è®¤ä½¿ç”¨BTHREAD_ATTR_NORMALè¿è¡Œç”¨æˆ·ä»£ç ã€‚&lt;/p&gt;
&lt;p&gt;æ ˆä½¿ç”¨&lt;a href=&#34;http://linux.die.net/man/2/mmap&#34;&gt;mmap&lt;/a&gt;åˆ†é…ï¼Œbthreadè¿˜ä¼šç”¨mprotectåˆ†é…4Kçš„guard pageä»¥æ£€æµ‹æ ˆæº¢å‡ºã€‚ç”±äºŽmmap+mprotectä¸èƒ½è¶…è¿‡max_map_countï¼ˆé»˜è®¤ä¸º65536ï¼‰ï¼Œå½“bthreadéžå¸¸å¤šåŽå¯èƒ½è¦è°ƒæ•´æ­¤å‚æ•°ã€‚å¦å¤–å½“æœ‰å¾ˆå¤šbthreadæ—¶ï¼Œå†…å­˜é—®é¢˜å¯èƒ½ä¸ä»…ä»…æ˜¯æ ˆï¼Œä¹ŸåŒ…æ‹¬å„ç±»ç”¨æˆ·å’Œç³»ç»Ÿbufferã€‚&lt;/p&gt;
&lt;p&gt;goroutineåœ¨1.3å‰é€šè¿‡&lt;a href=&#34;https://gcc.gnu.org/wiki/SplitStacks&#34;&gt;segmented stacks&lt;/a&gt;åŠ¨æ€åœ°è°ƒæ•´æ ˆå¤§å°ï¼Œå‘çŽ°æœ‰&lt;a href=&#34;https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub&#34;&gt;hot split&lt;/a&gt;é—®é¢˜åŽæ¢æˆäº†å˜é•¿è¿žç»­æ ˆï¼ˆç±»ä¼¼äºŽvector resizingï¼Œåªé€‚åˆå†…å­˜æ‰˜ç®¡çš„è¯­è¨€ï¼‰ã€‚ç”±äºŽbthreadåŸºæœ¬åªä¼šåœ¨64ä½å¹³å°ä¸Šä½¿ç”¨ï¼Œè™šå­˜ç©ºé—´åºžå¤§ï¼Œå¯¹å˜é•¿æ ˆéœ€æ±‚ä¸æ˜Žç¡®ã€‚åŠ ä¸Šsegmented stacksçš„æ€§èƒ½æœ‰å½±å“ï¼Œbthreadæš‚æ—¶æ²¡æœ‰å˜é•¿æ ˆçš„è®¡åˆ’ã€‚&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Timer keeping</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/timer-keeping/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/timer-keeping/</guid>
      <description>
        
        
        &lt;p&gt;åœ¨å‡ ç‚¹å‡ åˆ†åšæŸä»¶äº‹æ˜¯RPCæ¡†æž¶çš„åŸºæœ¬éœ€æ±‚ï¼Œè¿™ä»¶äº‹æ¯”çœ‹ä¸ŠåŽ»éš¾ã€‚&lt;/p&gt;
&lt;p&gt;è®©æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ç³»ç»Ÿæä¾›äº†äº›ä»€ä¹ˆï¼š posixç³»ç»Ÿèƒ½ä»¥&lt;a href=&#34;http://man7.org/linux/man-pages/man2/timer_create.2.html&#34;&gt;signalæ–¹å¼&lt;/a&gt;å‘ŠçŸ¥timerè§¦å‘ï¼Œä¸è¿‡signalé€¼è¿«æˆ‘ä»¬ä½¿ç”¨å…¨å±€å˜é‡ï¼Œå†™&lt;a href=&#34;https://docs.oracle.com/cd/E19455-01/806-5257/gen-26/index.html&#34;&gt;async-signal-safe&lt;/a&gt;çš„å‡½æ•°ï¼Œåœ¨é¢å‘ç”¨æˆ·çš„ç¼–ç¨‹æ¡†æž¶ä¸­ï¼Œæˆ‘ä»¬åº”å½“å°½åŠ›é¿å…ä½¿ç”¨signalã€‚linuxè‡ª2.6.27åŽèƒ½ä»¥&lt;a href=&#34;http://man7.org/linux/man-pages/man2/timerfd_create.2.html&#34;&gt;fdæ–¹å¼&lt;/a&gt;é€šçŸ¥timerè§¦å‘ï¼Œè¿™ä¸ªfdå¯ä»¥æ”¾åˆ°epollä¸­å’Œä¼ è¾“æ•°æ®çš„fdç»Ÿä¸€ç®¡ç†ã€‚å”¯ä¸€é—®é¢˜æ˜¯ï¼šè¿™æ˜¯ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä¸”æˆ‘ä»¬ä¸æ¸…æ¥šå®ƒåœ¨å¤šçº¿ç¨‹ä¸‹çš„è¡¨çŽ°ã€‚&lt;/p&gt;
&lt;p&gt;ä¸ºä»€ä¹ˆè¿™ä¹ˆå…³æ³¨timerçš„å¼€é”€?è®©æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹RPCåœºæ™¯ä¸‹ä¸€èˆ¬æ˜¯æ€Žä¹ˆä½¿ç”¨timerçš„ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨å‘èµ·RPCè¿‡ç¨‹ä¸­è®¾å®šä¸€ä¸ªtimerï¼Œåœ¨è¶…æ—¶æ—¶é—´åŽå–æ¶ˆè¿˜åœ¨ç­‰å¾…ä¸­çš„RPCã€‚å‡ ä¹Žæ‰€æœ‰çš„RPCè°ƒç”¨éƒ½æœ‰è¶…æ—¶é™åˆ¶ï¼Œéƒ½ä¼šè®¾ç½®è¿™ä¸ªtimerã€‚&lt;/li&gt;
&lt;li&gt;RPCç»“æŸå‰åˆ é™¤timerã€‚å¤§éƒ¨åˆ†RPCéƒ½ç”±æ­£å¸¸è¿”å›žçš„responseå¯¼è‡´ç»“æŸï¼Œtimerå¾ˆå°‘è§¦å‘ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä½ æ³¨æ„åˆ°äº†ä¹ˆï¼Œåœ¨RPCä¸­timeræ›´åƒæ˜¯â€ä¿é™©æœºåˆ¶â€ï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹éƒ½ä¸ä¼šå‘æŒ¥ä½œç”¨ï¼Œè‡ªç„¶åœ°æˆ‘ä»¬å¸Œæœ›å®ƒçš„å¼€é”€è¶Šå°è¶Šå¥½ã€‚ä¸€ä¸ªå‡ ä¹Žä¸è§¦å‘çš„åŠŸèƒ½éœ€è¦ä¸¤æ¬¡ç³»ç»Ÿè°ƒç”¨ä¼¼ä¹Žå¹¶ä¸ç†æƒ³ã€‚é‚£åœ¨åº”ç”¨æ¡†æž¶ä¸­ä¸€èˆ¬æ˜¯å¦‚ä½•å®žçŽ°timerçš„å‘¢ï¼Ÿè°ˆè®ºè¿™ä¸ªé—®é¢˜éœ€è¦åŒºåˆ†â€œå•çº¿ç¨‹â€å’Œâ€œå¤šçº¿ç¨‹â€:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨å•çº¿ç¨‹æ¡†æž¶ä¸­ï¼Œæ¯”å¦‚ä»¥&lt;a href=&#34;http://libevent.org/&#34;&gt;libevent&lt;/a&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Reactor_pattern&#34;&gt;, &lt;/a&gt;&lt;a href=&#34;http://software.schmorp.de/pkg/libev.html&#34;&gt;libev&lt;/a&gt;ä¸ºä»£è¡¨çš„eventloopç±»åº“ï¼Œæˆ–ä»¥&lt;a href=&#34;http://www.gnu.org/software/pth/pth-manual.html&#34;&gt;GNU Pth&lt;/a&gt;, &lt;a href=&#34;http://state-threads.sourceforge.net/index.html&#34;&gt;StateThreads&lt;/a&gt;ä¸ºä»£è¡¨çš„coroutine / fiberç±»åº“ä¸­ï¼Œä¸€èˆ¬æ˜¯ä»¥&lt;a href=&#34;https://en.wikipedia.org/wiki/Heap_(data_structure)&#34;&gt;å°é¡¶å †&lt;/a&gt;è®°å½•è§¦å‘æ—¶é—´ã€‚&lt;a href=&#34;http://man7.org/linux/man-pages/man2/epoll_wait.2.html&#34;&gt;epoll_wait&lt;/a&gt;å‰ä»¥å †é¡¶çš„æ—¶é—´è®¡ç®—å‡ºå‚æ•°timeoutçš„å€¼ï¼Œå¦‚æžœåœ¨è¯¥æ—¶é—´å†…æ²¡æœ‰å…¶ä»–äº‹ä»¶ï¼Œepoll_waitä¹Ÿä¼šé†’æ¥ï¼Œä»Žå †ä¸­å¼¹å‡ºå·²è¶…æ—¶çš„å…ƒç´ ï¼Œè°ƒç”¨ç›¸åº”çš„å›žè°ƒå‡½æ•°ã€‚æ•´ä¸ªæ¡†æž¶å‘¨è€Œå¤å§‹åœ°è¿™ä¹ˆè¿è½¬ï¼Œtimerçš„å»ºç«‹ï¼Œç­‰å¾…ï¼Œåˆ é™¤éƒ½å‘ç”Ÿåœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ã€‚åªè¦æ‰€æœ‰çš„å›žè°ƒéƒ½æ˜¯éžé˜»å¡žçš„ï¼Œä¸”é€»è¾‘ä¸å¤æ‚ï¼Œè¿™å¥—æœºåˆ¶å°±èƒ½æä¾›åŸºæœ¬å‡†ç¡®çš„timerã€‚ä¸è¿‡å°±åƒ&lt;a href=&#34;../threading-overview/&#34;&gt;Threading Overview&lt;/a&gt;ä¸­è¯´çš„é‚£æ ·ï¼Œè¿™ä¸æ˜¯RPCçš„åœºæ™¯ã€‚&lt;/li&gt;
&lt;li&gt;åœ¨å¤šçº¿ç¨‹æ¡†æž¶ä¸­ï¼Œä»»ä½•çº¿ç¨‹éƒ½å¯èƒ½è¢«ç”¨æˆ·é€»è¾‘é˜»å¡žè¾ƒé•¿çš„æ—¶é—´ï¼Œæˆ‘ä»¬éœ€è¦ç‹¬ç«‹çš„çº¿ç¨‹å®žçŽ°timerï¼Œè¿™ç§çº¿ç¨‹æˆ‘ä»¬å«å®ƒTimerThreadã€‚ä¸€ä¸ªéžå¸¸è‡ªç„¶çš„åšæ³•ï¼Œå°±æ˜¯ä½¿ç”¨ç”¨é”ä¿æŠ¤çš„å°é¡¶å †ã€‚å½“ä¸€ä¸ªçº¿ç¨‹éœ€è¦åˆ›å»ºtimeræ—¶ï¼Œå®ƒå…ˆèŽ·å¾—é”ï¼Œç„¶åŽæŠŠå¯¹åº”çš„æ—¶é—´æ’å…¥å †ï¼Œå¦‚æžœæ’å…¥çš„å…ƒç´ æˆä¸ºäº†æœ€æ—©çš„ï¼Œå”¤é†’TimerThreadã€‚TimerThreadä¸­çš„é€»è¾‘å’Œå•çº¿ç¨‹ç±»ä¼¼ï¼Œå°±æ˜¯ç­‰ç€å †é¡¶çš„å…ƒç´ è¶…æ—¶ï¼Œå¦‚æžœåœ¨ç­‰å¾…è¿‡ç¨‹ä¸­æœ‰æ›´æ—©çš„æ—¶é—´æ’å…¥äº†ï¼Œè‡ªå·±ä¼šè¢«æ’å…¥çº¿ç¨‹å”¤é†’ï¼Œè€Œä¸ä¼šç¡è¿‡å¤´ã€‚è¿™ä¸ªæ–¹æ³•çš„é—®é¢˜åœ¨äºŽæ¯ä¸ªtimeréƒ½éœ€è¦ç«žäº‰ä¸€æŠŠå…¨å±€é”ï¼Œæ“ä½œä¸€ä¸ªå…¨å±€å°é¡¶å †ï¼Œå°±åƒåœ¨å…¶ä»–æ–‡ç« ä¸­åå¤è°ˆåˆ°çš„é‚£æ ·ï¼Œè¿™ä¼šè§¦å‘cache bouncingã€‚åŒæ ·æ•°é‡çš„timeræ“ä½œæ¯”å•çº¿ç¨‹ä¸‹çš„æ…¢10å€æ˜¯éžå¸¸æ­£å¸¸çš„ï¼Œå°´å°¬çš„æ˜¯è¿™äº›timeråŸºæœ¬ä¸è§¦å‘ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æˆ‘ä»¬é‡ç‚¹è°ˆæ€Žä¹ˆè§£å†³å¤šçº¿ç¨‹ä¸‹çš„é—®é¢˜ã€‚&lt;/p&gt;
&lt;p&gt;ä¸€ä¸ªæƒ¯ä¾‹æ€è·¯æ˜¯æŠŠtimerçš„éœ€æ±‚æ•£åˆ—åˆ°å¤šä¸ªTimerThreadï¼Œä½†è¿™å¯¹TimerThreadæ•ˆæžœä¸å¥½ã€‚æ³¨æ„æˆ‘ä»¬ä¸Šé¢æåŠåˆ°äº†é‚£ä¸ªâ€œåˆ¶çº¦å› ç´ â€ï¼šä¸€æ—¦æ’å…¥çš„å…ƒç´ æ˜¯æœ€æ—©çš„ï¼Œè¦å”¤é†’TimerThreadã€‚å‡è®¾TimerThreadè¶³å¤Ÿå¤šï¼Œä»¥è‡³äºŽæ¯ä¸ªtimeréƒ½æ•£åˆ—åˆ°ç‹¬ç«‹çš„TimerThreadï¼Œé‚£ä¹ˆæ¯æ¬¡å®ƒéƒ½è¦å”¤é†’é‚£ä¸ªTimerThreadã€‚ â€œå”¤é†’â€æ„å‘³ç€è§¦å‘linuxçš„è°ƒåº¦å‡½æ•°ï¼Œè§¦å‘ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚åœ¨éžå¸¸æµç•…çš„ç³»ç»Ÿä¸­ï¼Œè¿™ä¸ªå¼€é”€å¤§çº¦æ˜¯3-5å¾®ç§’ï¼Œè¿™å¯æ¯”æŠ¢é”å’ŒåŒæ­¥cacheè¿˜æ…¢ã€‚è¿™ä¸ªå› ç´ æ˜¯æé«˜TimerThreadæ‰©å±•æ€§çš„ä¸€ä¸ªéš¾ç‚¹ã€‚å¤šä¸ªTimerThreadå‡å°‘äº†å¯¹å•ä¸ªå°é¡¶å †çš„ç«žäº‰åŽ‹åŠ›ï¼Œä½†åŒæ—¶ä¹Ÿå¼•å…¥äº†æ›´å¤šå”¤é†’ã€‚&lt;/p&gt;
&lt;p&gt;å¦ä¸€ä¸ªéš¾ç‚¹æ˜¯åˆ é™¤ã€‚ä¸€èˆ¬ç”¨idæŒ‡ä»£ä¸€ä¸ªTimerã€‚é€šè¿‡è¿™ä¸ªidåˆ é™¤Timeræœ‰ä¸¤ç§æ–¹å¼ï¼š1.æŠ¢é”ï¼Œé€šè¿‡ä¸€ä¸ªmapæŸ¥åˆ°å¯¹åº”timeråœ¨å°é¡¶å †ä¸­çš„ä½ç½®ï¼Œå®šç‚¹åˆ é™¤ï¼Œè¿™ä¸ªmapè¦å’Œå †åŒæ­¥ç»´æŠ¤ã€‚2.é€šè¿‡idæ‰¾åˆ°Timerçš„å†…å­˜ç»“æž„ï¼Œåšä¸ªæ ‡è®°ï¼Œç•™å¾…TimerThreadè‡ªè¡Œå‘çŽ°å’Œåˆ é™¤ã€‚ç¬¬ä¸€ç§æ–¹æ³•è®©æ’å…¥é€»è¾‘æ›´å¤æ‚äº†ï¼Œåˆ é™¤ä¹Ÿè¦æŠ¢é”ï¼Œçº¿ç¨‹ç«žäº‰æ›´æ¿€çƒˆã€‚ç¬¬äºŒç§æ–¹æ³•åœ¨å°é¡¶å †å†…ç•™äº†ä¸€å¤§å †å·²åˆ é™¤çš„å…ƒç´ ï¼Œè®©å †æ˜Žæ˜¾å˜å¤§ï¼Œæ’å…¥å’Œåˆ é™¤éƒ½å˜æ…¢ã€‚&lt;/p&gt;
&lt;p&gt;ç¬¬ä¸‰ä¸ªéš¾ç‚¹æ˜¯TimerThreadä¸åº”è¯¥ç»å¸¸é†’ã€‚ä¸€ä¸ªæžç«¯æ˜¯TimerThreadæ°¸è¿œé†’ç€æˆ–ä»¥è¾ƒé«˜é¢‘çŽ‡é†’è¿‡æ¥ï¼ˆæ¯”å¦‚æ¯1msé†’ä¸€æ¬¡ï¼‰ï¼Œè¿™æ ·æ’å…¥timerçš„çº¿ç¨‹å°±ä¸ç”¨è´Ÿè´£å”¤é†’äº†ï¼Œç„¶åŽæˆ‘ä»¬æŠŠæ’å…¥è¯·æ±‚æ•£åˆ—åˆ°å¤šä¸ªå †é™ä½Žç«žäº‰ï¼Œé—®é¢˜çœ‹ä¼¼è§£å†³äº†ã€‚ä½†äº‹å®žä¸Šè¿™ä¸ªæ–¹æ¡ˆæä¾›çš„timerç²¾åº¦è¾ƒå·®ï¼Œä¸€èˆ¬é«˜äºŽ2msã€‚ä½ å¾—æƒ³è¿™ä¸ªTimerThreadæ€Žä¹ˆå†™é€»è¾‘ï¼Œå®ƒæ˜¯æ²¡æ³•æŒ‰å †é¡¶å…ƒç´ çš„æ—¶é—´ç­‰å¾…çš„ï¼Œç”±äºŽæ’å…¥çº¿ç¨‹ä¸å”¤é†’ï¼Œä¸€æ—¦æœ‰æ›´æ—©çš„å…ƒç´ æ’å…¥ï¼ŒTimerThreadå°±ä¼šç¡è¿‡å¤´ã€‚å®ƒå”¯ä¸€èƒ½åšçš„æ˜¯ç¡çœ å›ºå®šçš„æ—¶é—´ï¼Œä½†è¿™å’ŒçŽ°ä»£OS schedulerçš„å‡è®¾å†²çªï¼šé¢‘ç¹sleepçš„çº¿ç¨‹çš„ä¼˜å…ˆçº§æœ€ä½Žã€‚åœ¨linuxä¸‹çš„ç»“æžœå°±æ˜¯ï¼Œå³ä½¿åªsleepå¾ˆçŸ­çš„æ—¶é—´ï¼Œæœ€ç»ˆé†’è¿‡æ¥ä¹Ÿå¯èƒ½è¶…è¿‡2msï¼Œå› ä¸ºåœ¨OSçœ‹æ¥ï¼Œè¿™ä¸ªçº¿ç¨‹ä¸é‡è¦ã€‚ä¸€ä¸ªé«˜ç²¾åº¦çš„TimerThreadæœ‰å”¤é†’æœºåˆ¶ï¼Œè€Œä¸æ˜¯å®šæœŸé†’ã€‚&lt;/p&gt;
&lt;p&gt;å¦å¤–ï¼Œæ›´å¹¶å‘çš„æ•°æ®ç»“æž„ä¹Ÿéš¾ä»¥å¥æ•ˆï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥åŽ»æœç´¢&amp;quot;concurrent priority queue&amp;quot;æˆ–&amp;quot;concurrent skip list&amp;quot;ï¼Œè¿™äº›æ•°æ®ç»“æž„ä¸€èˆ¬å‡è®¾æ’å…¥çš„æ•°å€¼è¾ƒä¸ºæ•£å¼€ï¼Œæ‰€ä»¥å¯ä»¥åŒæ—¶ä¿®æ”¹ç»“æž„å†…çš„ä¸åŒéƒ¨åˆ†ã€‚ä½†è¿™åœ¨RPCåœºæ™¯ä¸­ä¹Ÿä¸æˆç«‹ï¼Œç›¸äº’ç«žäº‰çš„çº¿ç¨‹è®¾å®šçš„æ—¶é—´å¾€å¾€èšé›†åœ¨åŒä¸€ä¸ªåŒºåŸŸï¼Œå› ä¸ºç¨‹åºçš„è¶…æ—¶å¤§éƒ½æ˜¯ä¸€ä¸ªå€¼ï¼ŒåŠ ä¸Šå½“å‰æ—¶é—´åŽéƒ½å·®ä¸å¤šã€‚&lt;/p&gt;
&lt;p&gt;è¿™äº›å› ç´ è®©TimerThreadçš„è®¾è®¡ç›¸å½“æ£˜æ‰‹ã€‚ç”±äºŽå¤§éƒ¨åˆ†ç”¨æˆ·çš„qpsè¾ƒä½Žï¼Œä¸è¶³ä»¥æ˜Žæ˜¾æš´éœ²è¿™ä¸ªæ‰©å±•æ€§é—®é¢˜ï¼Œåœ¨r31791å‰æˆ‘ä»¬ä¸€ç›´æ²¿ç”¨â€œç”¨ä¸€æŠŠé”ä¿æŠ¤çš„TimerThreadâ€ã€‚TimerThreadæ˜¯brpcåœ¨é»˜è®¤é…ç½®ä¸‹å”¯ä¸€çš„é«˜é¢‘ç«žäº‰ç‚¹ï¼Œè¿™ä¸ªé—®é¢˜æ˜¯æˆ‘ä»¬ä¸€ç›´æ¸…æ¥šçš„æŠ€æœ¯å€ºã€‚éšç€brpcåœ¨é«˜qpsç³»ç»Ÿä¸­åº”ç”¨è¶Šæ¥è¶Šå¤šï¼Œæ˜¯æ—¶å€™è§£å†³è¿™ä¸ªé—®é¢˜äº†ã€‚r31791åŽçš„TimerThreadè§£å†³äº†ä¸Šè¿°ä¸‰ä¸ªéš¾ç‚¹ï¼Œtimeræ“ä½œå‡ ä¹Žå¯¹RPCæ€§èƒ½æ²¡æœ‰å½±å“ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹æ€§èƒ½å·®å¼‚ã€‚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;åœ¨ç¤ºä¾‹ç¨‹åºexample/mutli_threaded_echo_c++ä¸­ï¼Œr31791åŽTimerThreadç›¸æ¯”è€TimerThreadåœ¨24æ ¸E5-2620ä¸Šï¼ˆè¶…çº¿ç¨‹ï¼‰ï¼Œä»¥50ä¸ªbthreadåŒæ­¥å‘é€æ—¶ï¼ŒèŠ‚çœ4%cpuï¼ˆå·®ä¸å¤š1ä¸ªæ ¸ï¼‰ï¼Œqpsæå‡10%å·¦å³ï¼›åœ¨400ä¸ªbthreadåŒæ­¥å‘é€æ—¶ï¼Œqpsä»Ž30ä¸‡ä¸Šå‡åˆ°60ä¸‡ã€‚æ–°TimerThreadçš„è¡¨çŽ°å’Œå®Œå…¨å…³é—­è¶…æ—¶æ—¶æŽ¥è¿‘ã€‚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;é‚£æ–°TimerThreadæ˜¯å¦‚ä½•åšåˆ°çš„ï¼Ÿ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ä¸€ä¸ªTimerThreadè€Œä¸æ˜¯å¤šä¸ªã€‚&lt;/li&gt;
&lt;li&gt;åˆ›å»ºçš„timeræ•£åˆ—åˆ°å¤šä¸ªBucketä»¥é™ä½Žçº¿ç¨‹é—´çš„ç«žäº‰ï¼Œé»˜è®¤13ä¸ªBucketã€‚&lt;/li&gt;
&lt;li&gt;Bucketå†…ä¸ä½¿ç”¨å°é¡¶å †ç®¡ç†æ—¶é—´ï¼Œè€Œæ˜¯é“¾è¡¨ + nearest_run_timeå­—æ®µï¼Œå½“æ’å…¥çš„æ—¶é—´æ—©äºŽnearest_run_timeæ—¶è¦†ç›–è¿™ä¸ªå­—æ®µï¼Œä¹‹åŽåŽ»å’Œå…¨å±€nearest_run_timeï¼ˆå’ŒBucketçš„nearest_run_timeä¸åŒï¼‰æ¯”è¾ƒï¼Œå¦‚æžœä¹Ÿæ—©äºŽè¿™ä¸ªæ—¶é—´ï¼Œä¿®æ”¹å¹¶å”¤é†’TimerThreadã€‚é“¾è¡¨èŠ‚ç‚¹åœ¨é”å¤–ä½¿ç”¨&lt;a href=&#34;../memory-management/&#34;&gt;ResourcePool&lt;/a&gt;åˆ†é…ã€‚&lt;/li&gt;
&lt;li&gt;åˆ é™¤æ—¶é€šè¿‡idç›´æŽ¥å®šä½åˆ°timerå†…å­˜ç»“æž„ï¼Œä¿®æ”¹ä¸€ä¸ªæ ‡å¿—ï¼Œtimerç»“æž„æ€»æ˜¯ç”±TimerThreadé‡Šæ”¾ã€‚&lt;/li&gt;
&lt;li&gt;TimerThreadè¢«å”¤é†’åŽé¦–å…ˆæŠŠå…¨å±€nearest_run_timeè®¾ç½®ä¸ºå‡ ä¹Žæ— é™å¤§(max of int64)ï¼Œç„¶åŽå–å‡ºæ‰€æœ‰Bucketå†…çš„é“¾è¡¨ï¼Œå¹¶æŠŠBucketçš„nearest_run_timeè®¾ç½®ä¸ºå‡ ä¹Žæ— é™å¤§(max of int64)ã€‚TimerThreadæŠŠæœªåˆ é™¤çš„timeræ’å…¥å°é¡¶å †ä¸­ç»´æŠ¤ï¼Œè¿™ä¸ªå †å°±å®ƒä¸€ä¸ªçº¿ç¨‹ç”¨ã€‚åœ¨æ¯æ¬¡è¿è¡Œå›žè°ƒæˆ–å‡†å¤‡ç¡çœ å‰éƒ½ä¼šæ£€æŸ¥å…¨å±€nearest_run_timeï¼Œ å¦‚æžœå…¨å±€æ›´æ—©ï¼Œè¯´æ˜Žæœ‰æ›´æ—©çš„æ—¶é—´åŠ å…¥äº†ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™é‡Œå‹¾å‹’äº†TimerThreadçš„å¤§è‡´å·¥ä½œåŽŸç†ï¼Œå·¥ç¨‹å®žçŽ°ä¸­è¿˜æœ‰ä¸å°‘ç»†èŠ‚é—®é¢˜ï¼Œå…·ä½“è¯·é˜…è¯»&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/bthread/timer_thread.h&#34;&gt;timer_thread.h&lt;/a&gt;å’Œ&lt;a href=&#34;https://github.com/brpc/brpc/blob/master/src/bthread/timer_thread.cpp&#34;&gt;timer_thread.cpp&lt;/a&gt;ã€‚&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªæ–¹æ³•ä¹‹æ‰€ä»¥æœ‰æ•ˆï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bucketé”å†…çš„æ“ä½œæ˜¯O(1)çš„ï¼Œå°±æ˜¯æ’å…¥ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ï¼Œä¸´ç•ŒåŒºå¾ˆå°ã€‚èŠ‚ç‚¹æœ¬èº«çš„å†…å­˜åˆ†é…æ˜¯åœ¨é”å¤–çš„ã€‚&lt;/li&gt;
&lt;li&gt;ç”±äºŽå¤§éƒ¨åˆ†æ’å…¥çš„æ—¶é—´æ˜¯é€’å¢žçš„ï¼Œæ—©äºŽBucket::nearest_run_timeè€Œå‚ä¸Žå…¨å±€ç«žäº‰çš„timerå¾ˆå°‘ã€‚&lt;/li&gt;
&lt;li&gt;å‚ä¸Žå…¨å±€ç«žäº‰çš„timerä¹Ÿå°±æ˜¯å’Œå…¨å±€nearest_run_timeæ¯”ä¸€ä¸‹ï¼Œä¸´ç•ŒåŒºå¾ˆå°ã€‚&lt;/li&gt;
&lt;li&gt;å’ŒBucketå†…ç±»ä¼¼ï¼Œæžå°‘æ•°Timerä¼šæ—©äºŽå…¨å±€nearest_run_timeå¹¶åŽ»å”¤é†’TimerThreadã€‚å”¤é†’ä¹Ÿåœ¨å…¨å±€é”å¤–ã€‚&lt;/li&gt;
&lt;li&gt;åˆ é™¤ä¸å‚ä¸Žå…¨å±€ç«žäº‰ã€‚&lt;/li&gt;
&lt;li&gt;TimerThreadè‡ªå·±ç»´æŠ¤å°é¡¶å †ï¼Œæ²¡æœ‰ä»»ä½•cache bouncingï¼Œæ•ˆçŽ‡å¾ˆé«˜ã€‚&lt;/li&gt;
&lt;li&gt;TimerThreadé†’æ¥çš„é¢‘çŽ‡å¤§çº¦æ˜¯RPCè¶…æ—¶çš„å€’æ•°ï¼Œæ¯”å¦‚è¶…æ—¶=100msï¼ŒTimerThreadä¸€ç§’å†…å¤§çº¦é†’10æ¬¡ï¼Œå·²ç»æœ€ä¼˜ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è‡³æ­¤brpcåœ¨é»˜è®¤é…ç½®ä¸‹ä¸å†æœ‰å…¨å±€ç«žäº‰ç‚¹ï¼Œåœ¨400ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡Œæ—¶ï¼Œprofilingä¹Ÿæ˜¾ç¤ºå‡ ä¹Žæ²¡æœ‰å¯¹é”çš„ç­‰å¾…ã€‚&lt;/p&gt;
&lt;p&gt;ä¸‹é¢æ˜¯ä¸€äº›å’Œlinuxä¸‹æ—¶é—´ç®¡ç†ç›¸å…³çš„çŸ¥è¯†ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epoll_waitçš„è¶…æ—¶ç²¾åº¦æ˜¯æ¯«ç§’ï¼Œè¾ƒå·®ã€‚pthread_cond_timedwaitçš„è¶…æ—¶ä½¿ç”¨timespecï¼Œç²¾åº¦åˆ°çº³ç§’ï¼Œä¸€èˆ¬æ˜¯60å¾®ç§’å·¦å³çš„å»¶æ—¶ã€‚&lt;/li&gt;
&lt;li&gt;å‡ºäºŽæ€§èƒ½è€ƒè™‘ï¼ŒTimerThreadä½¿ç”¨wall-timeï¼Œè€Œä¸æ˜¯å•è°ƒæ—¶é—´ï¼Œå¯èƒ½å—åˆ°ç³»ç»Ÿæ—¶é—´è°ƒæ•´çš„å½±å“ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æžœåœ¨æµ‹è¯•ä¸­æŠŠç³»ç»Ÿæ—¶é—´å¾€å‰æˆ–å¾€åŽè°ƒä¸€ä¸ªå°æ—¶ï¼Œç¨‹åºè¡Œä¸ºå°†å®Œå…¨undefinedã€‚æœªæ¥å¯èƒ½ä¼šè®©ç”¨æˆ·é€‰æ‹©å•è°ƒæ—¶é—´ã€‚&lt;/li&gt;
&lt;li&gt;åœ¨cpuæ”¯æŒnonstop_tscå’Œconstant_tscçš„æœºå™¨ä¸Šï¼Œbrpcå’Œbthreadä¼šä¼˜å…ˆä½¿ç”¨åŸºäºŽrdtscçš„cpuwide_time_usã€‚é‚£ä¸¤ä¸ªflagè¡¨ç¤ºrdtscå¯ä½œä¸ºwall-timeä½¿ç”¨ï¼Œä¸æ”¯æŒçš„æœºå™¨ä¸Šä¼šè½¬è€Œä½¿ç”¨è¾ƒæ…¢çš„å†…æ ¸æ—¶é—´ã€‚æˆ‘ä»¬çš„æœºå™¨ï¼ˆIntel Xeonç³»åˆ—ï¼‰å¤§éƒ½æœ‰é‚£ä¸¤ä¸ªflagã€‚rdtscä½œä¸ºwall-timeä½¿ç”¨æ—¶æ˜¯å¦ä¼šå—åˆ°ç³»ç»Ÿè°ƒæ•´æ—¶é—´çš„å½±å“ï¼Œæœªæµ‹è¯•ä¸æ¸…æ¥šã€‚&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: bthread_id</title>
      <link>https://brpc.incubator.apache.org/docs/rpc-in-depth/bthread_id/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brpc.incubator.apache.org/docs/rpc-in-depth/bthread_id/</guid>
      <description>
        
        
        &lt;p&gt;bthread_idæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„åŒæ­¥ç»“æž„ï¼Œå®ƒå¯ä»¥äº’æ–¥RPCè¿‡ç¨‹ä¸­çš„ä¸åŒçŽ¯èŠ‚ï¼Œä¹Ÿå¯ä»¥O(1)æ—¶é—´å†…æ‰¾åˆ°RPCä¸Šä¸‹æ–‡(å³Controller)ã€‚æ³¨æ„ï¼Œè¿™é‡Œæˆ‘ä»¬è°ˆè®ºçš„æ˜¯bthread_id_tï¼Œä¸æ˜¯bthread_tï¼ˆbthreadçš„tidï¼‰ï¼Œè¿™ä¸ªåå­—èµ·çš„ç¡®å®žä¸å¤ªå¥½ï¼Œå®¹æ˜“æ··æ·†ã€‚&lt;/p&gt;
&lt;p&gt;å…·ä½“æ¥è¯´ï¼Œbthread_idè§£å†³çš„é—®é¢˜æœ‰ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;åœ¨å‘é€RPCè¿‡ç¨‹ä¸­responseå›žæ¥äº†ï¼Œå¤„ç†responseçš„ä»£ç å’Œå‘é€ä»£ç äº§ç”Ÿç«žäº‰ã€‚&lt;/li&gt;
&lt;li&gt;è®¾ç½®timeråŽå¾ˆå¿«è§¦å‘äº†ï¼Œè¶…æ—¶å¤„ç†ä»£ç å’Œå‘é€ä»£ç äº§ç”Ÿç«žäº‰ã€‚&lt;/li&gt;
&lt;li&gt;é‡è¯•äº§ç”Ÿçš„å¤šä¸ªresponseåŒæ—¶å›žæ¥äº§ç”Ÿçš„ç«žäº‰ã€‚&lt;/li&gt;
&lt;li&gt;é€šè¿‡correlation_idåœ¨O(1)æ—¶é—´å†…æ‰¾åˆ°å¯¹åº”çš„RPCä¸Šä¸‹æ–‡ï¼Œè€Œæ— éœ€å»ºç«‹ä»Žcorrelation_idåˆ°RPCä¸Šä¸‹æ–‡çš„å…¨å±€å“ˆå¸Œè¡¨ã€‚&lt;/li&gt;
&lt;li&gt;å–æ¶ˆRPCã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸Šæ–‡æåˆ°çš„bugåœ¨å…¶ä»–rpcæ¡†æž¶ä¸­å¹¿æ³›å­˜åœ¨ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸‹brpcæ˜¯å¦‚ä½•é€šè¿‡bthread_idè§£å†³è¿™äº›é—®é¢˜çš„ã€‚&lt;/p&gt;
&lt;p&gt;bthread_idåŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯ç”¨æˆ·å¯è§çš„64ä½idï¼Œå¦ä¸€ä¸ªæ˜¯å¯¹åº”çš„ä¸å¯è§çš„bthread::Idç»“æž„ä½“ã€‚ç”¨æˆ·æŽ¥å£éƒ½æ˜¯æ“ä½œidçš„ã€‚ä»Židæ˜ å°„åˆ°ç»“æž„ä½“çš„æ–¹å¼å’Œbrpcä¸­çš„&lt;a href=&#34;../memory-management/&#34;&gt;å…¶ä»–ç»“æž„&lt;/a&gt;ç±»ä¼¼ï¼š32ä½æ˜¯å†…å­˜æ± çš„ä½ç§»ï¼Œ32ä½æ˜¯versionã€‚å‰è€…O(1)æ—¶é—´å®šä½ï¼ŒåŽè€…é˜²æ­¢ABAé—®é¢˜ã€‚&lt;/p&gt;
&lt;p&gt;bthread_idçš„æŽ¥å£ä¸å¤ªç®€æ´ï¼Œæœ‰ä¸å°‘APIï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;li&gt;unlock&lt;/li&gt;
&lt;li&gt;unlock_and_destroy&lt;/li&gt;
&lt;li&gt;join&lt;/li&gt;
&lt;li&gt;error&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;è¿™ä¹ˆå¤šæŽ¥å£æ˜¯ä¸ºäº†æ»¡è¶³ä¸åŒçš„ä½¿ç”¨æµç¨‹ã€‚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å‘é€requestçš„æµç¨‹ï¼šbthread_id_create -&amp;gt; bthread_id_lock -&amp;gt; &amp;hellip; register timer and send RPC &amp;hellip; -&amp;gt; bthread_id_unlock&lt;/li&gt;
&lt;li&gt;æŽ¥æ”¶responseçš„æµç¨‹ï¼šbthread_id_lock -&amp;gt; ..process response -&amp;gt; bthread_id_unlock_and_destroy&lt;/li&gt;
&lt;li&gt;å¼‚å¸¸å¤„ç†æµç¨‹ï¼štimeout/socket fail -&amp;gt; bthread_id_error -&amp;gt; æ‰§è¡Œon_errorå›žè°ƒ(è¿™é‡Œä¼šåŠ é”)ï¼Œåˆ†ä¸¤ç§æƒ…å†µ
&lt;ul&gt;
&lt;li&gt;è¯·æ±‚é‡è¯•/backup requestï¼š é‡æ–°register timer and send RPC -&amp;gt; bthread_id_unlock&lt;/li&gt;
&lt;li&gt;æ— æ³•é‡è¯•ï¼Œæœ€ç»ˆå¤±è´¥ï¼šbthread_id_unlock_and_destroy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;åŒæ­¥ç­‰å¾…RPCç»“æŸï¼šbthread_id_join&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸ºäº†å‡å°‘ç­‰å¾…ï¼Œbthread_idåšäº†ä¸€äº›ä¼˜åŒ–çš„æœºåˆ¶ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;errorå‘ç”Ÿçš„æ—¶å€™ï¼Œå¦‚æžœbthread_idå·²ç»è¢«é”ä½ï¼Œä¼šæŠŠerrorä¿¡æ¯æ”¾åˆ°ä¸€ä¸ªpending queueä¸­ï¼Œbthread_id_errorå‡½æ•°ç«‹å³è¿”å›žã€‚å½“bthread_id_unlockçš„æ—¶å€™ï¼Œå¦‚æžœpending queueé‡Œé¢æœ‰ä»»åŠ¡å°±å–å‡ºæ¥æ‰§è¡Œã€‚&lt;/li&gt;
&lt;li&gt;RPCç»“æŸçš„æ—¶å€™ï¼Œå¦‚æžœå­˜åœ¨ç”¨æˆ·å›žè°ƒï¼Œå…ˆæ‰§è¡Œä¸€ä¸ªbthread_id_about_to_destroyï¼Œè®©æ­£åœ¨ç­‰å¾…çš„bthread_id_lockæ“ä½œç«‹å³å¤±è´¥ï¼Œå†æ‰§è¡Œç”¨æˆ·å›žè°ƒï¼ˆè¿™ä¸ªå¯èƒ½è€—æ—¶è¾ƒé•¿ï¼Œä¸å¯æŽ§ï¼‰ï¼Œæœ€åŽå†æ‰§è¡Œbthread_id_unlock_and_destroy&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
